[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python Book",
    "section": "",
    "text": "1 Preface｜为什么要了解 Python\n编程语言本身不是目的，它只是人类与计算机之间的一种协作媒介。选择了解一门语言，实际上是在选择一种解决问题的方式、一种与复杂系统打交道的工具形态。Python 正是在这种意义下值得被认真对待的。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "12  总结",
    "section": "",
    "text": "目前这本书只有一些文本内容，以及基础的示例代码，部分课后习题。还有一些课程的小项目没有组织出来。\n在习题设计上，本书对入门难度的练习做了取舍，当前版本暂未全部收录，后续将根据整体结构需要逐步补充。\n对于树、图及算法相关章节，本书当前版本以概念理解、基本用法与示例代码为主，更系统的项目将作为后续内容逐步加入。\nTo be continued…….",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>总结</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html#为什么是-python",
    "href": "index.html#为什么是-python",
    "title": "Python Book",
    "section": "1.1 为什么是 Python",
    "text": "1.1 为什么是 Python\nPython 并不是最快的语言，也不是最底层的语言，但它在表达效率、生态成熟度与应用覆盖面之间取得了一个相对罕见的平衡。\n对初学者而言，Python 的语法负担较低，代码更接近自然语言，能够把注意力从“语言细节”转移到“问题本身”。对有经验的开发者而言，Python 提供了大量成熟的库和工具，使得从想法到可运行系统的距离显著缩短。\n这使 Python 成为一种“思考型语言”：它更强调把问题描述清楚、把逻辑组织清楚，而不是过早陷入实现细节。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "index.html#python-与其他语言的差异",
    "href": "index.html#python-与其他语言的差异",
    "title": "Python Book",
    "section": "1.2 Python 与其他语言的差异",
    "text": "1.2 Python 与其他语言的差异\n不同语言在设计目标上存在天然差异：\n\n与 C / C++ 相比\nPython 不追求极致性能和内存控制，而是牺牲一部分运行效率，换取更高的开发效率与可读性。底层性能敏感的模块，通常通过 C/C++ 扩展来补足。\n与 Java / C# 相比\nPython 的类型系统更灵活，开发流程更轻量，适合快速试验和迭代；而 Java、C# 在大型工程、强类型约束和长期维护方面更具结构性优势。\n与 JavaScript 相比\nPython 的核心使用场景偏向计算、数据处理、自动化和后端逻辑；JavaScript 则天然围绕浏览器和前端生态展开。两者并非替代关系，而是分工不同。\n\n理解这些差异，有助于避免一个常见误区：用不合适的语言，解决不适合的问题。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "index.html#python-的优势与边界",
    "href": "index.html#python-的优势与边界",
    "title": "Python Book",
    "section": "1.3 Python 的优势与边界",
    "text": "1.3 Python 的优势与边界\n主要优势：\n\n语法简洁，可读性高\n标准库与第三方生态极其丰富\n在数据分析、机器学习、自动化、科学计算等领域形成事实标准\n跨平台、跨领域，学习投入的复用率高\n\n客观边界：\n\n单线程性能受限，不适合极端高性能场景\n动态类型在大型项目中需要额外的工程纪律\n运行时错误更依赖测试与规范，而非编译期保障\n\n理解这些边界，并不会削弱 Python 的价值，反而能帮助你更理性地使用它。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "index.html#了解-python-能带来什么",
    "href": "index.html#了解-python-能带来什么",
    "title": "Python Book",
    "section": "1.4 了解 Python 能带来什么",
    "text": "1.4 了解 Python 能带来什么\n学习 Python 并不意味着你必须成为“Python 工程师”。它更像是一种基础能力放大器：\n\n帮助你更快地把想法变成可执行的程序\n帮助你理解数据、模型和自动化系统的基本工作方式\n帮助你与 AI、数据、工程系统建立更直接的连接\n为进一步学习其他语言或系统打下通用的编程思维基础\n\n在很多场景下，Python 是“第一门值得学会的语言”，但它同样也是一门值得长期使用、不断深化理解的语言。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "cp_1.html",
    "href": "cp_1.html",
    "title": "2  Python基础",
    "section": "",
    "text": "2.1 Python介绍",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#introduction-to-python",
    "href": "cp_1.html#introduction-to-python",
    "title": "2  1 Python基础",
    "section": "",
    "text": "2.1.1 What Is Python and What Are Some Common Uses in the Industry?\nPython 是一种通用编程语言，以其简洁性和易用性而闻名。这种易用性使 Python 成为当今最受欢迎的编程语言。2024 年，Python 正式超越 JavaScript，成为 GitHub 上最流行的语言。\nPython 被广泛应用于许多领域，如数据科学和机器学习、Web 开发、脚本和自动化、嵌入式系统、物联网（IoT）等等。\nPython 是目前大多数数据科学家和机器学习工程师使用的主要语言。Pandas 和 Numpy 等库让数据分析不再枯燥乏味，而 Tensorflow 和 Scikit 等库则让机器学习和使用 AI 模型变得更加触手可及。\n在 Web 开发领域，Django、FastAPI 和 Flask 等 Python 框架让开发者能够以最少的精力构建可扩展且安全的后端系统。许多社交媒体平台，如 Instagram 和 Pinterest，都在后端使用了 Python。\n网络安全专家和道德黑客（ethical hackers）使用 Python 来检测恶意软件和其他病毒等漏洞，构建自动化的安全扫描程序，并分析威胁。\nPython 在 Raspberry Pi 和支持 MicroPython 的开发板等微型计算机上运行良好，因此你可以构建各种物联网项目，如智能家居设备、气象监测站等。\n最后，Python 最大的优势之一就是自动化。你可以编写简单的脚本来帮助完成重复性任务，例如从电子表格中提取数据、发送电子邮件以及处理本地机器上的文件。\nSelenium 和 BeautifulSoup 等库也让与网站进行交互变得轻而易举，因此你可以抓取公开数据、通过 Web 界面自动化任务，甚至管理项目的云部署。\n由此可见，Python 是一种非常强大的语言，但学习起来却很容易。从简单的自动化脚本到大规模的工业级应用，几乎所有事情你都可以使用 Python 来完成。\n无论你以后选择专攻哪个领域，Python 都是任何想要学习编程的人的绝佳选择。\n\n\n2.1.2 How Do You Install,Confgure and Use Python in Your Local Environment?\n以下是您要求翻译的内容：\n在上一课中，你了解了什么是 Python 以及你可以用它做什么。现在，让我们来看看如何在你的本地机器上设置 Python。\n在 Windows 和 Mac 上安装 Python 最简单的方法是从官方 Python 网站下载安装程序。在本课的后面部分，我们还将介绍如何在 Linux 上运行 Python。\n访问 https://www.python.org/，并将鼠标悬停在“Downloads”（下载）上。一个弹窗会出现，显示你当前操作系统（OS）的 Python 版本。\n我们首先来看看如何在运行 macOS 的电脑上安装 Python：\n点击弹窗中显示的当前 Python 版本按钮，你会自动开始下载一个 .pkg 安装文件。\n当 .pkg 安装程序下载完成后，打开它，然后在弹出的窗口中点击“Continue”（继续）。\n继续点击“Continue”（继续）按钮，直到你进入“Installation Type”（安装类型）部分。在那里，点击“Install”（安装）按钮。\n如有必要，请输入你的密码，然后开始安装。\n之后，你应该会收到一条恭喜消息，提示 Python 已成功安装。\n点击“Close”（关闭）按钮，大功告成！\n你可以通过打开终端并运行 python --version 或 python3 --version 来验证安装。\n你也可以通过在终端中运行 python 或 python3 来打开 Python 解释器。\n终端是一种基于文本的界面，允许你通过输入命令与电脑交互。每个操作系统都自带一个默认的终端应用程序。在 macOS 上，你可以使用终端（Terminal）应用程序。在 Windows 上，你可以使用命令提示符（Command Prompt）或 PowerShell。在 Linux 上，每个桌面环境都有其默认的终端应用程序，例如 GNOME 终端或 Konsole。\n请注意，在一些较旧的 macOS 和 Linux 系统中，python 可能保留给 Python 2 使用，而 python3 则专门用于 Python 3。如果你运行 python --version 并看到 Python 2 的版本（例如 Python 2.7.18），那么你的操作系统可能依赖于一些用旧版 Python 编写的软件。如果是这种情况，你应该在今后使用 python3 来运行你的 Python 代码。Python 2 已停止维护，不应在任何新开发中使用。\n要在 Windows 上安装 Python，请按照以下步骤操作：\n访问 https://www.python.org/，并将鼠标悬停在“Downloads”（下载）上。你应该会看到一个写着“Download for Windows”（下载 Windows 版）的弹窗和一个带有当前 Python 版本的下载按钮。\n点击版本号，你会自动开始下载一个 Windows 可执行文件（.exe）。\n当你下载完 Windows 版 Python 安装程序后，双击它，然后按照说明操作。\n当你看到“Add python.exe to Path”（将 python.exe 添加到路径）选项时，勾选该选项，然后点击“Install Now”（立即安装）。这样做会让你后续的工作更加轻松。\n你可以通过打开命令行 shell（如 PowerShell）并运行 python --version 来验证安装。你也可以通过运行 python 来打开 Python 解释器。\n关于 Linux 上的 Python，大多数主流发行版（如 Ubuntu、Debian 和 Fedora）都自带 Python。\n只需打开一个终端并运行 python --version 或 python3 --version：\n如果任一命令都没有显示 Python 版本，你可以在 https://www.python.org 上搜索适用于你 Linux 发行版的安装包，或者在网上搜索针对你的发行版推荐的 Python 安装方法。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#understanding-variables-and-data-types",
    "href": "cp_1.html#understanding-variables-and-data-types",
    "title": "2  1 Python基础",
    "section": "2.2 Understanding Variables and Data Types",
    "text": "2.2 Understanding Variables and Data Types\n\n2.2.1 How Do You Declare Variables and What Are Naming Conventions to Name Variables?\n在 Python 中，变量就像一个贴有标签的盒子，用于存储和引用不同类型的数据。要在 Python 中声明变量，你只需使用赋值（=）运算符将一个值分配给一个标识符即可。你不需要像在 JavaScript 中那样使用 let 或 const 这样的特殊关键字，也不需要像在 C# 中那样使用 char。\n在 Python 中，你只需在等号左边写上变量名，接着是赋值运算符，最后是在右边你想赋给该变量的值。下面是一个如何声明 name 和 age 变量的例子：\n示例代码\nname = 'John Doe'\nage = 25\n在上面的例子中，变量 name 保存的值是 'John Doe'。这个值是一个字符串（string），即用于表示文本的一系列字符。字符串用单引号或双引号括起来，例如 'Hello' 或 \"Hello\"。在后续的课程中，你将学习更多关于在 Python 中处理字符串的知识。\n在 Python 中命名变量时，有一些重要的规则需要牢记：\n\n变量名只能以字母或下划线（**_**）开头，不能以数字开头。\n变量名只能包含字母数字字符（a-z, A-Z, 0-9）和下划线（**_**）。\n变量名区分大小写 —— age、Age 和 AGE 都被视为不同的变量。\n变量名不能是 Python 的保留关键字，例如 if、class 或 def。\n\n如果你违反了其中任何一条规则，你的 Python 程序将抛出一个 SyntaxError（语法错误）：\n示例代码\n5variable_name = 5\n     ^\nSyntaxError: invalid syntax\n现在让我们来看看 Python 中一些常见的变量命名惯例。\n首先，变量名应该使用小写字母，单词之间用下划线分隔。这被称为蛇形命名法（snake case）：\n示例代码\nmy_variable_name = 'freeCodeCamp'\n其次，你应该为变量使用描述性的名称。例如，如果你想将用户的年龄保存为一个变量，user_age 就比 age 或 ua 这样的缩写要好：\n示例代码\nuser_age = 30\n这样一来，在一个庞大的代码库中，你就可以轻松地向其他团队成员（或者未来的自己）传达变量的用途。\n另一个惯例是避免使用单个字母的变量名。这在 Python 中很常见，但应该尽量避免，因为单个字母的变量名无法传达任何目的或含义：\n示例代码\nx = 56 # x 代表什么意思？\n不过，如果你是在循环（loop）或类似结构中，使用 i、j、k 等作为变量名是很常见且可以接受的。\n另外，上面例子中 # 符号及其后面的文字被称为注释（comment）。你可能已经熟悉注释了，让我们快速回顾一下并解释它们是如何工作的。\n在 Python 中，注释以井号（#）开头，解释器会忽略该行 # 符号之后的所有内容：\n示例代码\n# 这是一行单行注释\n多行注释可以通过连续使用单行注释来创建：\n示例代码\n# 这是一个\n# 多行\n# 注释\n你可以使用注释来解释你的代码、给自己留备忘录，或者阐明某一行代码存在的原因。注释在学习或团队协作时尤其有用。\n但是，你不应该使用注释来解释变量名的含义。相反，你为变量选择的名称应该是描述性的，并传达它们的用途，同时遵循前面提到的其他命名规则以防止语法错误。\n\n\n2.2.2 How Does the Print Function Work?\n每种编程语言都有一些内置的方法、函数、属性或关键字，用于将数据输出到终端。在 Python 中，你可以使用 print 函数将数据打印到终端。让我们仔细看看 print 函数，这样你就可以开始自信地使用它了。\n当你学习任何编程语言时，要做的第一件事通常就是编写一个简单的“Hello world!”（你好，世界！）程序。在 Python 中，你只需使用 print 函数就能非常轻松地做到这一点。\n要做到这一点，你只需要把字符串 Hello world! 放在调用 print 函数所用的左右括号之间即可：\n示例代码\nprint('Hello world!') # Hello world!\n在后续的课程中，你将学习更多关于 Python 中的字符串和函数的知识。现在，你可以把字符串理解为被单引号（’）或双引号（“）包围的一系列字符。\n在 print('Hello world!') 这个例子中，字符串 'Hello world!' 就是传递给 print 函数的一个参数。你也可以使用 print 函数一次性显示多个值（或参数），只需用逗号将它们分隔开即可。例如：\n示例代码\nprint('My favorite colors are', 'blue', 'green', 'red')\n输出结果：My favorite colors are blue green red\n当你用逗号分隔各个元素时，Python 会自动在它们之间添加一个空格。当你想把几条信息一起打印出来时，这非常有用。\n\n\n2.2.3 What Are Common Data Types in Python and How Do You Get the Type of a Variable?\n在使用 Python 变量之前，了解数据类型非常重要。数据类型描述了变量所持有的值的种类。例如，一个数字、一段文本或一个元素列表。编程语言使用数据类型以便知道如何存储和处理不同类型的信息。\nPython 是一种像 JavaScript 一样的动态类型语言，这意味着你不需要显式地为变量声明类型。语言会根据你分配给它的值来判断它是什么数据类型。\n这里有一些例子：\n示例代码\nname = 'John Doe' # Python 知道这是一个字符串\nage = 25 # Python 知道这是一个整数\n这与一些静态类型语言（如 C#、Java 和 C++）形成对比，在这些语言中，你必须在声明变量时指定类型，像这样：\n示例代码\nstring name = 'John Doe'\nint age = 25\nPython 的动态类型特性使得编码速度非常快且更加灵活，但它也可能导致意想不到的错误，因为类型错误只有在程序运行时才会被检测到，而不是在编译时。\n由于 Python 是在你的程序运行时确定数据类型的，所以类型相关的错误只有在那时才会被发现。当程序运行时，Python 会逐行执行你的代码。如果它到达了一行，发现某个对象被期望以一种它无法做到的方式行事，Python 就会停止并显示一个错误。\n相比之下，有些语言在运行前会先编译你的程序。编译意味着计算机会提前检查你的代码并准备运行它。在这个步骤中，那些语言可以在程序甚至开始运行之前就捕获类型错误。\n你暂时不需要了解那些语言。重要的概念很简单：\n\n在 Python 中，类型错误可能在执行期间暴露出来，也就是程序实际运行并使用你的代码时。\n编译型语言则在编译步骤（即程序被允许运行之前）捕获类型错误。\n\n正因为如此，你可能要等到程序在运行时到达那特定的一行代码，才会发现 Python 中的类型错误。\n以下是您在 Python 中将要使用的一些最常见的数据类型：\n整数 (Integer): 没有小数的整数，例如 10 或 -5。\n示例代码\nmy_integer_var = 10\nprint('Integer:', my_integer_var) # Integer: 10\n浮点数 (Float): 带有小数点的数字，比如 4.41 或 -0.4。\n示例代码\nmy_float_var = 4.50\nprint('Float:', my_float_var) # Float: 4.5\n字符串 (String): 用单引号或双引号括起来的一系列字符，比如 ‘Hello world!’。\n示例代码\nmy_string_var = 'hello'\nprint('String:', my_string_var) # String: hello\n布尔值 (Boolean): 布尔类型，即 True 或 False。\n示例代码\nmy_boolean_var = True\nprint('Boolean:', my_boolean_var) # Boolean: True\n集合 (Set): 无序的唯一元素集合，比如 {4, 2, 0}。\n示例代码\nmy_set_var = {7, 5, 8}\nprint('Set:', my_set_var) # Set: {7, 5, 8}\n字典 (Dictionary): 用花括号括起来的键值对集合，比如 {‘name’: ‘John Doe’, ‘age’: 28}。\n示例代码\nmy_dictionary_var = {'name': 'Alice', 'age': 25}\nprint('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}\n元组 (Tuple): 不可变的有序集合，用括号括起来，比如 (7, 8, 4)。\n示例代码\nmy_tuple_var = (7, 5, 8)\nprint('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)\n范围 (Range): 一个数字序列，常用于循环中，例如 range(5)。\n示例代码\nmy_range_var = range(5)\nprint('Range:', my_range_var) # Range: range(0, 5)\n列表 (List): 支持不同数据类型的有序元素集合。\n示例代码\nmy_list = [22, 'Hello world', 3.14, True]\nprint(my_list) # [22, 'Hello world', 3.14, True]\n空值 (None): 代表没有值的特殊值。\n示例代码\nmy_none_var = None\nprint('None:', my_none_var) # None: None\n要获取变量的数据类型，你可以使用 type() 函数：\n示例代码\nmy_var_1 = 'Hello world'\nmy_var_2 = 21\n\nprint(type(my_var_1)) # &lt;class 'str'&gt;\nprint(type (my_var_2)) # &lt;class 'int'&gt;\n以下是本课涵盖的所有数据类型以及它们在终端中显示的类型：\n示例代码\nmy_integer_var = 10\nprint(type(my_integer_var))  # &lt;class 'int'&gt;\n\nmy_float_var = 4.50\nprint(type(my_float_var))  # &lt;class 'float'&gt;\n\nmy_string_var = 'hello'\nprint(type(my_string_var))  # &lt;class 'str'&gt;\n\nmy_boolean_var = True\nprint(type(my_boolean_var))  # &lt;class 'bool'&gt;\n\nmy_set_var = {7, 5, 8}\nprint(type(my_set_var))  # &lt;class 'set'&gt;\n\nmy_dictionary_var = {'name': 'Alice', 'age': 25}\nprint(type(my_dictionary_var))  # &lt;class 'dict'&gt;\n\nmy_tuple_var = (7, 5, 8)\nprint(type(my_tuple_var))  # &lt;class 'tuple'&gt;\n\nmy_range_var = range(5)\nprint(type(my_range_var))  # &lt;class 'range'&gt;\n\nmy_list = [22, 'Hello world', 3.14, True]\nprint(type(my_list)) # &lt;class 'list'&gt;\n\nmy_none_var = None\nprint(type(my_none_var))  # &lt;class 'NoneType'&gt;\n内置的 isinstance() 函数允许你检查变量是否匹配特定的数据类型。它接收一个对象和你想要检查的类型，然后返回一个布尔值。这里有一些例子：\n示例代码\nisinstance('Hello world', str) # True\nisinstance(True, bool) # True\nisinstance(42, int) # True\nisinstance('John Doe', int) # False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#introduction-to-strings",
    "href": "cp_1.html#introduction-to-strings",
    "title": "2  1 Python基础",
    "section": "2.3 Introduction to Strings",
    "text": "2.3 Introduction to Strings\n\n2.3.1 What Are Strings and What Is String Immutability?\n字符串是由单引号或双引号包围的一系列字符。在某些编程语言中，被单引号包围的字符与被双引号包围的字符处理方式不同，但在 Python 中，它们被视为相等的。因此，在处理字符串时，你可以任选其一。以下是一些字符串的例子：\n示例代码\nmy_str_1 = 'Hello'\nmy_str_2 = \"World\"\n如果你需要一个多行字符串，可以使用三个双引号或三个单引号：\n示例代码\nmy_str_3 = \"\"\"Multiline\nstring\"\"\"\nmy_str_4 = '''Another\nmultiline\nstring'''\n如果你的字符串包含单引号或双引号，那么你有两个选择：\n\n使用相反类型的引号。也就是说，如果你的字符串包含单引号，请使用双引号来包裹字符串，反之亦然：\n示例代码\n\nmsg = \"It's a sunny day\"\nquote = 'She said, \"Hello World!\"'\n\n使用反斜杠（\\）对字符串中的单引号或双引号进行转义。使用此方法，你可以任选单引号或双引号来包裹字符串本身：\n示例代码\n\nmsg = 'It\\'s a sunny day'\nquote = \"She said, \\\"Hello!\\\"\"\n有时，你可能需要检查一个字符串是否包含一个或多个字符。为此，Python 提供了 in 运算符，它返回一个布尔值，指明该字符或字符序列是否存在于字符串中。以下是一些例子：\n示例代码\nmy_str = 'Hello world'\n\nprint('Hello' in my_str)  # True\nprint('hey' in my_str)    # False\nprint('hi' in my_str)     # False\nprint('e' in my_str)      # True\nprint('f' in my_str)      # False\n现在，让我们看看如何获取字符串的长度以及如何处理字符串中的单个字符，这个过程称为索引（indexing）。要获取字符串的长度，可以使用内置的 len() 函数。以下是一个例子：\n示例代码\nmy_str = 'Hello world'\nprint(len(my_str))  # 11\n字符串中的每个字符都有一个位置，称为索引。索引是基于零的，这意味着字符串的第一个字符的索引是 0，第二个字符的索引是 1，以此类推。要通过索引访问字符，你使用方括号（[]），并在其中放入你想访问的字符的索引。以下是一些例子：\n示例代码\nmy_str = \"Hello world\"\n\nprint(my_str[0])  # H\nprint(my_str[6])  # w\n也支持负数索引，因此你可以使用 -1 获取任何字符串的最后一个字符，使用 -2 获取倒数第二个字符，以此类推：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[-1])  # d\nprint(my_str[-2])  # l\n许多其他编程语言将数据类型广泛地分为基本类型（primitive）或引用类型（reference）。基本类型是简单的且不可变的，意味着一旦声明就不能更改。引用类型可以包含多个值，并且要么是可变的，要么是不可变的。但 Python 并不在这两组之间划出一条严格的界限。相反，所有数据都被视为对象，其中一些对象是不可变的，而另一些是可变的。\n不可变数据类型一旦声明，就无法被修改或更改。你可以将变量重新指向新的东西，这称为重新赋值，但你不能通过添加、删除或替换其任何元素来更改原始对象本身。\n字符串是 Python 中的不可变数据类型。这意味着你可以将一个不同的字符串重新赋值给一个变量：\n示例代码\ngreeting = 'hi'\ngreeting = 'hello'\nprint(greeting) # hello\n但不允许直接修改字符串：\n示例代码\ngreeting = 'hi'\ngreeting[0] = 'H' # TypeError: 'str' object does not support item assignment\nPython 中其他不可变数据类型的例子包括整数（integer）、浮点数（float）、布尔值（boolean）、元组（tuple）和范围（range）。在接下来的课程中，你将逐一了解这些类型。\n\n\n2.3.2 What Are String Concatenation and String Interpolation?\n在处理字符串时，你经常会遇到需要将不同文本片段组合在一起的情况。\n在 Python 中，你可以使用加号（+）运算符将多个字符串组合在一起。这个过程被称为字符串拼接（string concatenation）。以下是使用加号运算符拼接两个字符串的方法：\n示例代码\nmy_str_1 = 'Hello'\nmy_str_2 = \"World\"\n\nstr_plus_str = my_str_1 + ' ' + my_str_2\nprint(str_plus_str) # Hello World\n但请注意，这只适用于字符串。如果你试图将字符串与数字拼接，你会得到一个 TypeError（类型错误）：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name + age\nprint(name_and_age) # TypeError: can only concatenate str (not \"int\") to str\n发生这种情况是因为当你拼接它们时，Python 不会自动将其他数据类型（如整数）转换为字符串。Python 要求所有元素在拼接之前都必须是字符串。为了解决这个问题，你可以使用内置的 str() 函数将数字转换为字符串，该函数返回给定对象的字符串表示形式，而不会修改原始对象：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name + str(age)\nprint(name_and_age) # John Doe26\n你也可以使用增强赋值运算符（augmented assignment operator）来进行拼接。它由一个加号和一个等号（+=）表示，可以在一步内同时完成拼接和赋值。以下是它的实际应用：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name  # 从名字开始\nname_and_age += str(age)  # 追加年龄（字符串形式）\n\nprint(name_and_age)  # John Doe26\n将变量和表达式插入字符串的过程被称为字符串插值（string interpolation）。Python 有一种名为 f-strings（格式化字符串字面值的缩写）的字符串，它允许你使用简洁且易读的语法来处理插值。\nf-strings 在引号前以 f（小写或大写均可）开头，并允许你将变量或表达式嵌入由大括号（{}）指示的替换字段中。以下是一个例子：\n示例代码\nname = 'John Doe'\nage = 26\nname_and_age = f'My name is {name} and I am {age} years old'\nprint(name_and_age) # My name is John Doe and I am 26 years old\n\nnum1 = 5\nnum2 = 10\nprint(f'The sum of {num1} and {num2} is {num1 + num2}') # The sum of 5 and 10 is 15\n请注意，在插值过程中，你不需要使用 str() 函数来转换非字符串类型。在上面的例子中，age、num1 和 num2 变量的值在底层被自动转换成了字符串。\n\n\n2.3.3 What Is String Slicing and How Does It Work?\n在上一课中，你学习了字符串中的每个字符如何通过其索引（从零开始）来识别，并使用方括号表示法进行访问：\n示例代码\nmy_str = \"Hello world\"\n\nprint(my_str[0])  # H\nprint(my_str[6])  # w\nprint(my_str[-1]) # d\n字符串切片（String slicing）让你可以提取字符串的一部分，或者只处理其中特定的部分。以下是基本语法：\n示例代码\nstring[start:stop]\n如果你想从某个特定索引提取到另一个索引，只需用冒号分隔起始和结束索引即可：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[1:4]) # ell\n请注意，结束索引是不包含的，因此 [1:4] 只提取了从索引 1 开始，一直到（但不包含）索引 4 的字符。\n你也可以省略起始或结束索引，Python 会默认分别从 0 或字符串末尾开始。例如，如果你省略起始索引：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[:7])  # Hello w\n这将提取从索引 0 开始，一直到（但不包含）索引 7 的所有内容。如果你省略结束索引，情况如下：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[8:])  # rld\n这将提取从索引 8 的字符开始，直到字符串末尾的所有内容。\n请注意，切片字符串不会修改原始字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[8:])  # rld\nprint(my_str)  # Hello world\n你也可以同时省略起始和结束索引，这将提取整个字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[:])  # Hello world\n除了起始和结束索引外，还有一个可选的步长（step）参数，用于指定切片中每个索引之间的增量。\n其语法如下：\n示例代码\nstring[start:stop:step]\n在下面的例子中，切片从索引 0 开始，到 11 之前结束，并提取每隔一个字符（即每第二个字符）：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[0:11:2])  # Hlowrd\n利用步长参数，一个很有用的技巧是将步长设为 -1，并留空起始和结束索引，从而反转字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[::-1]) # dlrow olleH\n\n\n2.3.4 What Are Some Common String Methods?\nPython 提供了许多内置方法，让处理字符串变得轻而易举。这些方法包括但不限于以下内容：\n\nupper(): 返回一个新字符串，其中所有字符都转换为大写。\n示例代码\n\nmy_str = 'hello world'\n\nuppercase_my_str = my_str.upper()\nprint(uppercase_my_str)  # HELLO WORLD\n\nlower(): 返回一个新字符串，其中所有字符都转换为小写。\n示例代码\n\nmy_str = 'Hello World'\n\nlowercase_my_str = my_str.lower()\nprint(lowercase_my_str)  # hello world\n\nstrip(): 返回一个新字符串，其中移除了指定的首尾字符。如果不传递参数，则移除首尾的空白字符（如空格、换行符等）。\n示例代码\n\nmy_str = '  hello world  '\n\ntrimmed_my_str = my_str.strip()\nprint(trimmed_my_str)  # \"hello world\"\n\nreplace(old, new): 返回一个新字符串，其中所有 old 的出现都被替换为 new。\n示例代码\n\nmy_str = 'hello world'\n\nreplaced_my_str = my_str.replace('hello', 'hi')\nprint(replaced_my_str)  # hi world\n\nsplit(separator): 根据指定的分隔符将字符串拆分为一个字符串列表。如果没有指定分隔符，则根据空白字符进行拆分。\n示例代码\n\nmy_str = 'hello world'\n\nsplit_words = my_str.split()\nprint(split_words)  # ['hello', 'world']\n\njoin(iterable): 将可迭代对象的元素用指定的字符串连接成一个新字符串。\n示例代码\n\nmy_list = ['hello', 'world']\n\njoined_my_str = ' '.join(my_list)\nprint(joined_my_str)  # hello world\n\nstartswith(prefix): 返回一个布尔值，指示字符串是否以指定的前缀开头。\n示例代码\n\nmy_str = 'hello world'\n\nstarts_with_hello = my_str.startswith('hello')\nprint(starts_with_hello)  # True\n\nendswith(suffix): 返回一个布尔值，指示字符串是否以指定的后缀结尾。\n示例代码\n\nmy_str = 'hello world'\n\nends_with_world = my_str.endswith('world')\nprint(ends_with_world)  # True\n\nfind(substring): 返回子字符串第一次出现的索引，如果未找到则返回 -1。\n示例代码\n\nmy_str = 'hello world'\n\nworld_index = my_str.find('world')\nprint(world_index)  # 6\n\ncount(substring): 返回子字符串在字符串中出现的次数。\n示例代码\n\nmy_str = 'hello world'\n\no_count = my_str.count('o')\nprint(o_count)  # 2\n\ncapitalize(): 返回一个新字符串，其中首字母大写，其余字母小写。\n示例代码\n\nmy_str = 'hello world'\n\ncapitalized_my_str = my_str.capitalize()\nprint(capitalized_my_str)  # Hello world\n\nisupper(): 如果字符串中的所有字母都是大写，则返回 True，否则返回 False。\n示例代码\n\nmy_str = 'hello world'\n\nis_all_upper = my_str.isupper()\nprint(is_all_upper)  # False\n\nislower(): 如果字符串中的所有字母都是小写，则返回 True，否则返回 False。\n示例代码\n\nmy_str = 'hello world'\n\nis_all_lower = my_str.islower()\nprint(is_all_lower)  # True\n\ntitle(): 返回一个新字符串，其中每个单词的首字母都大写。\n示例代码\n\nmy_str = 'hello world'\n\ntitle_case_my_str = my_str.title()\nprint(title_case_my_str)  # Hello World",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#numbers-and-mathematical-operations",
    "href": "cp_1.html#numbers-and-mathematical-operations",
    "title": "2  1 Python基础",
    "section": "2.4 Numbers and Mathematical Operations",
    "text": "2.4 Numbers and Mathematical Operations\n\n2.4.1 How Do You Work With Integers and Floating Point Numbers?\n整数和浮点数是 Python 中主要的数值数据类型。使用它们，你可以存储数值数据并执行数学运算。\n让我们来看看什么是整数和浮点数，如何用它们进行算术计算，以及 Python 提供的用于处理这两种类型的一些方法。\n整数 (Integers) 是没有小数点的整数，可以是正数或负数：\n示例代码\nmy_int_1 = 56\nmy_int_2 = -4\n\nprint(type(my_int_1)) # &lt;class 'int'&gt;\nprint(type(my_int_2)) # &lt;class 'int'&gt;\n以下是使用整数执行加法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nsum_ints = my_int_1 + my_int_2\nprint('Integer Addition:', sum_ints) # Integer Addition: 68\n以下是使用整数执行减法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\n# Subtraction\ndiff_ints = my_int_1 - my_int_2\nprint('Integer Subtraction:', diff_ints) # Integer Subtraction: 44\n以下是使用整数执行乘法运算的方法：\n示例代码\nmy_int_1 = 12\nmy_int_2 = 4\n\n# Multiplication\nproduct_ints = my_int_1 * my_int_2\nprint('Integer Multiplication:', product_ints) # Integer Multiplication: 48\n以下是使用整数执行除法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\n# Division\ndiv_ints = my_int_1 / my_int_2\nprint('Integer Division:', div_ints) # Integer Division: 4.666666666666667\n浮点数 (Floats) 是带有小数点的正数或负数，例如 3.14、-0.5 或 0.0。\n示例代码\nmy_float_1 = -12.0\nmy_float_2 = 4.9\n\nprint(type(my_float_1)) # &lt;class 'float'&gt;\nprint(type(my_float_2)) # &lt;class 'float'&gt;\n以下是使用浮点数执行加法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_addition = my_float_1 + my_float_2\nprint('Float Addition:', float_addition) # Float Addition: 17.4\n以下是使用浮点数执行减法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_subtraction = my_float_2 - my_float_1\nprint('Float Subtraction:', float_subtraction) # Float Subtraction: 6.6\n以下是使用浮点数执行乘法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_multiplication = my_float_2 * my_float_1\nprint('Float Multiplication:', float_multiplication) # Float Multiplication: 64.80000000000001\n以下是使用浮点数执行除法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_division = my_float_2 / my_float_1\nprint('Float Division:', float_division) # Float Division: 2.222222222222222\n如果你将一个整数和一个浮点数相加，结果会自动转换为浮点数：\n示例代码\nmy_int = 56\nmy_float = 5.4\n\nsum_int_and_float = my_int + my_float\n\nprint(sum_int_and_float) # 61.4\nprint(type(sum_int_and_float)) # &lt;class 'float'&gt;\n对于其他基本算术运算也是如此，比如减法、乘法和除法。如果你混合使用整数和浮点数，Python 将返回一个浮点数作为结果。\n你也可以执行更复杂的算术计算，例如使用取模运算符获取两个数的余数、向下取整除法以及使用整数和浮点数进行幂运算。\n取模运算符 (%) 返回左边的值除以右边的值时的余数：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nmod_ints = my_int_1 % my_int_2\nmod_floats = my_float_2 % my_float_1\n\nprint('Integer Modulus:', mod_ints) # Integer Modulus: 8\nprint('Float Modulus:', mod_floats) # Float Modulus: 1.1999999999999993\n向下取整除法 (Floor division) 将两个数相除并返回小于或等于结果的最大整数。这是通过双正斜杠运算符 (//) 完成的：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloor_div_ints = my_int_1 // my_int_2\nfloor_div_floats = my_float_2 // my_float_1\n\nprint('Integer Floor Division:', floor_div_ints) # Integer Floor Division: 4\nprint('Float Floor Division:', floor_div_floats) # Float Floor Division: 2.0\n幂运算 (Exponentiation) 将一个数提升为另一个数的幂，使用双星号运算符 (**) 完成：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nexp_ints = my_int_1 ** my_int_2\nexp_floats = my_float_1 ** my_float_2\n\nprint('Integer Exponentiation:', exp_ints) # Integer Exponentiation: 951166013805414055936\nprint('Float Exponentiation:',  exp_floats) # Float Exponentiation: 614787626.1765089\nPython 还提供了内置函数，用于将数值数据或字符串转换为整数或浮点数。\nfloat() 函数返回从给定数字构造的浮点数：\n示例代码\nmy_int_1 = 56\nmy_float_1 = float(my_int_1)\n\nprint(my_float_1)  # 56.0\nprint(type(my_float_1))  # &lt;class 'float'&gt;\nint() 函数返回从给定数字构造的整数：\n示例代码\nmy_float = 12.92563\nmy_int = int(my_float)\n\nprint(my_int)  # 12\nprint(type(my_int))  # &lt;class 'int'&gt;\n此外，你可以使用相同的内置函数将字符串转换为浮点数或整数：\n示例代码\nmy_str_int = '45'\nmy_str_float = '7.8'\n\nconverted_int = int(my_str_int)\nconverted_float = float(my_str_float)\n\nprint(converted_int, type(converted_int))  # 45 &lt;class 'int'&gt;\nprint(converted_float, type(converted_float))  # 7.8 &lt;class 'float'&gt;\n以下是 Python 提供的用于处理整数和浮点数的其他一些方法。\nround(): 将数字四舍五入到指定的小数位数。默认情况下，此函数四舍五入到最接近的整数，并返回一个没有小数位的整数：\n示例代码\nmy_int_1 = 4.798\nmy_int_2 = 4.253\n\nrounded_int_1 = round(my_int_1)\nrounded_int_2 = round(my_int_2, 1)\n\nprint(rounded_int_1) # 5\nprint(rounded_int_2) # 4.3\nabs(): 返回数字的绝对值，\n示例代码\nnum = -15\n\nabsolute_value = abs(num)\nprint(absolute_value) # 15\npow(): 将一个数提升为另一个数的幂，或执行模幂运算。\n示例代码\nresult_1 = pow(2, 3)  # Equivalent to 2 ** 3\nprint(result_1)  # 8\n\nresult_2 = pow(2, 3, 5)  # (2 ** 3) % 5\nprint(result_2)  # 3\n\n\n2.4.2 How Do Augmented Assignments Work?\n增强赋值（Augmented assignment）将二元运算和赋值合并为一个步骤。它接收一个变量，将其与另一个值进行运算，并将结果存回同一个变量中。\n如果你熟悉 JavaScript 等语言，你可能听说过加法赋值运算符（+=）、减法赋值（-=）等。这些在 Python 中也存在。唯一的区别是，在 Python 中它们被称为增强赋值（augmented assignments）。\n增强赋值的基本语法如下：\n示例代码\nvariable &lt;operator&gt;= value\n这比下面这种写法更高效：\n示例代码\nvariable = variable &lt;operator&gt; value\n例如，以下是如何使用增强赋值将 5 加到现有变量中的例子：\n示例代码\nmy_var = 10\nmy_var += 5\n\nprint(my_var) # 15\n下面是不使用增强赋值的同样操作：\n示例代码\nmy_var = 10\nmy_var = my_var + 5\n\nprint(my_var) # 15\n增强赋值的优势在于，它提供了一种简洁且易读的方式来更新变量值，而无需重复变量名。这样一来，它减少了冗余，并避免了因打字错误之类的问题而可能产生的错误。\n每个运算符都可以使用增强赋值。我们已经看过了加法赋值运算符（+=），让我们来看看其他的。\n减法赋值运算符 (**-=**) 用左变量减去右操作数，并将差值存回左变量：\n示例代码\ncount = 14\ncount -= 3\n\nprint(count) # 11\n乘法赋值运算符 (***=**) 将左变量乘以右操作数，并将乘积存回左变量：\n示例代码\nproduct = 65\nproduct *= 7\n\nprint(product) # 455\n除法赋值运算符 (**/=**) 用左变量除以右操作数，并将结果存回左变量：\n示例代码\nprice = 100\nprice /= 4\n\nprint(price) # 25.0\n向下取整除法运算符 (**//=**) 将左变量向下取整除以右操作数，并将结果存回左变量：\n示例代码\ntotal_pages = 23\ntotal_pages //= 5\n\nprint(total_pages) # 4\n取模赋值运算符 (**%=**) 计算左变量除以右操作数的余数，并将其存回左变量：\n示例代码\nbits = 35\nbits %= 2\n\nprint(bits) # 1\n幂赋值运算符 (****=**) 将左变量提升为右操作数的幂，并将结果存回左变量：\n示例代码\npower = 2\npower **= 3\n\nprint(power) # 8\n你也可以对字符串使用一些增强赋值运算符。例如，加法赋值运算符可以轻松地拼接字符串：\n示例代码\ngreet = 'Hello'\ngreet += ' World'\n\nprint(greet) # Hello World\n乘法赋值运算符可以用来重复一个字符串：\n示例代码\ngreet = 'Hello'\ngreet *= 3\n\nprint(greet) # HelloHelloHello\n其他增强赋值运算符与字符串一起使用时会抛出 TypeError（类型错误）：\n示例代码\ngreet = 'Hello'\ngreet -= ' World'\n\nprint(greet) # TypeError: unsupported operand type(s) for -=: 'str' and 'str'\n示例代码\ngreet = 'Hello'\ngreet /= 'World'\n\nprint(greet) # TypeError: unsupported operand type(s) for /=: 'str' and 'str'\n如果你想知道自增和自减运算符（++ 和 --）在 Python 中是否有效，答案是无效的。这是因为 Python 故意避免了 C 风格的自增和自减快捷方式，以便保持语言的清晰和明确。\n你可以简单地写 x += 1 来代替 x++，这清楚地表明你将变量 x 的值增加了 1。\n在 Python 中编写 ++x 只是两次应用了一元加号，而不会对任何东西进行自增：\n示例代码\nmy_var = 5\n\nprint(+my_var)   # 5\nprint(++my_var)  # 5\nprint(+++my_var) # 5\n\nmy_var += 1\n\nprint(my_var) # 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#booleans-and-conditionals",
    "href": "cp_1.html#booleans-and-conditionals",
    "title": "2  1 Python基础",
    "section": "2.5 Booleans and Conditionals",
    "text": "2.5 Booleans and Conditionals\n\n2.5.1 How Do Conditional Statements and Logical Operators Work?\n条件语句（Conditionals）让你可以根据特定条件是真还是假来控制程序的流程。\n但在深入探讨所有这些之前，让我们先回顾一下条件语句的基本构成要素，从比较运算符开始。比较运算符允许你比较两个或多个值，并返回一个布尔值。\n在上一课中，你了解到布尔值（Booleans）是 Python 中的一种数据类型，其值只能是 True 或 False。\n以下是 Python 中比较运算符的表格：\n\n\n\n运算符\n名称\n描述\n\n\n\n\n==\n等于\n检查两个值是否相等\n\n\n!=\n不等于\n检查两个值是否不相等\n\n\n&gt;\n大于\n检查左侧的值是否大于右侧的值\n\n\n&lt;\n小于\n检查左侧的值是否小于右侧的值\n\n\n&gt;=\n大于或等于\n检查左侧的值是否大于或等于右侧的值\n\n\n&lt;=\n小于或等于\n检查左侧的值是否小于或等于右侧的值\n\n\n\n以下是其中一些表达式，它们的值为 True 或 False：\n示例代码\nprint(3 &gt; 4) # False\nprint(3 &lt; 4) # True\nprint(3 == 4) # False\nprint(4 == 4) # True\nprint(3 != 4) # True\nprint(3 &gt;= 4) # False\nprint(3 &lt;= 4) # True\n这些运算符可以在条件语句中用来比较值，并根据条件语句的真假来运行特定的代码。\n在 Python 中，最基本的条件语句是 if 语句。其基本语法如下：\n示例代码\nif condition:\n    pass # 如果条件为 True，则执行这里的代码\n\nif 语句以 if 关键字开头。\ncondition 是一个表达式，其值为 True 或 False，后面跟着一个冒号 (:)。\nif 语句的主体构成一个代码块，即一组属于在一起的语句。在 Python 中，缩进级别定义了代码块。\n在上面的例子中，if 语句的主体包含一个 pass 语句。当执行 pass 语句时，什么也不会发生。这是一个特殊的关键字，可以用作未来代码的占位符，当不允许出现空代码块时，它非常有用。\n\n只有当条件为 True 时，if 语句内的代码才会运行。例如：\n示例代码\nage = 18\n\nif age &gt;= 18:\n    print('You are an adult') # You are an adult\n请注意 print('You are an adult') 前面的缩进。虽然其他编程语言使用花括号等字符来定义代码块，仅将缩进用于提高可读性，但在 Python 中，代码块是由缩进决定的。\n以下代码将引发 IndentationError（缩进错误），这是 Python 指出在代码的某处需要缩进的方式：\n示例代码\nage = 18\n\nif age &gt;= 18:\nprint('You are an adult') # IndentationError: expected an indented block after 'if' statement on line 3\n尽管你可以使用任意数量的空格（只要你保持一致）来确定每一级缩进，但 Python 风格指南建议使用四个空格。\n代码块也出现在循环和函数中，你将在以后的课程中学习到它们。\n回到我们的例子，如果 age 小于 18，终端中将不会打印任何内容：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult') # 终端中不会显示任何内容\n但是，如果你想在 age 小于 18 时也打印一些内容怎么办？这就是 else 子句的用处。当 if 条件为假时，else 子句就会运行。以下是 if...else 语句的语法：\n示例代码\nif condition:\n   pass # 如果条件为 True，则执行这里的代码\nelse:\n   pass # 如果条件为 False，则执行这里的代码\n例如：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult')\nelse:\n    print('You are not an adult yet') # You are not an adult yet\n在某些情况下，你可能需要考虑多个条件。为此，Python 允许你使用 elif（else if 的缩写）关键字来扩展你的 if 语句。\n其语法如下：\n示例代码\nif condition:\n   pass # 如果条件为 True，则执行这里的代码\nelif condition2:\n   pass # 如果条件2为 True，则执行这里的代码\nelse:\n   pass # 如果所有条件都为 False，则执行这里的代码\n例如：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult')\nelif age &gt;= 13:\n    print('You are a teenager')\nelse:\n    print('You are a child') # You are a child\n请注意，你可以根据需要使用任意数量的 elif 语句：\n示例代码\nage = 2\n\nif age &gt;= 65:\n    print('You are a senior citizen')\nelif age &gt;= 30:\n    print('You are an adult in your prime')\nelif age &gt;= 18:\n    print('You are a young adult')\nelif age &gt;= 13:\n    print('You are a teenager')\nelif age &gt;= 3:\n    print('You are a young child')\nelse:\n    print('You are a toddler or an infant') # You are a toddler or an infant\n现在你已经了解了 Python 中的比较运算符和条件语句是如何工作的，你可以开始编写基于逻辑和输入做出决策的程序了。无论你是比较值还是通过多个条件进行分支，这些工具都是编写灵活、响应式代码的基础。\n\n\n2.5.2 What Are Truthy and Falsy Values, and How Do Boolean Operators and Short Circuiting Work?\n在上一课中，你学习了如何使用比较运算符和条件语句来控制程序的流程。\n虽然这些功能非常强大，但你经常会遇到需要同时比较多个值的情况。这可能会导致嵌套的条件语句，例如：\n示例代码\nis_citizen = True\nage = 25\n\nif is_citizen:\n    if age &gt;= 18:\n        print('You are eligible to vote') # You are eligible to vote\nelse:\n    print('You are not eligible to vote')\n上面的例子将首先检查 is_citizen 是否为 True。如果是，它将进入嵌套的 if 语句并检查 age 是否大于或等于 18。由于 age 大于或等于 18，打印到终端的消息将是 “You are eligible to vote”。如果 is_citizen 为 False，那么打印到终端的消息将是 “You are not eligible to vote”。\n如果你正在处理更复杂的条件语句，那么你可以使用 Python 的 and、or 和 not 运算符。\n但在深入研究这些运算符之前，让我们先看看什么是“真值（truthy）”和“假值（falsy）”。\n在 Python 中，每个值都有一个固有的布尔值，即在逻辑上下文中它应该被视为 True 还是 False 的内置判断。许多值被认为是“真值”，也就是说，它们在逻辑上下文中会被求值为 True。其他的则是“假值”，意味着它们会被求值为 False。\n以下是几个“假值”的例子：\n\nNone\nFalse\n整数 0\n浮点数 0.0\n空字符串 “”\n\n其他值，如非零数字和非空字符串，都是“真值”。\n如果你想检查一个值是“真值”还是“假值”，你可以使用内置的 bool() 函数。它显式地将一个值转换为其布尔等价物，并为“真值”返回 True，为“假值”返回 False。以下是几个例子：\n示例代码\nprint(bool(False)) # False\nprint(bool(0))  # False\nprint(bool('')) # False\n\nprint(bool(True)) # True\nprint(bool(1)) # True\nprint(bool('Hello')) # True\n现在你理解了“真值”和“假值”，我们可以来看看布尔运算符，它们也被称为逻辑运算符。这些是特殊的运算符，允许你组合多个表达式，从而在代码中创建更复杂的决策逻辑。\nPython 中有三个布尔运算符：and、or 和 not。\n让我们先看看 and 运算符。\nand 运算符接受两个操作数，如果第一个操作数是“假值”，则返回第一个操作数，否则返回第二个操作数。为了让一个表达式的结果为“真值”，两个操作数都必须是“真值”。\n这是一个例子：\n示例代码\nis_citizen = True\nage = 25\n\nprint(is_citizen and age) # 25\n在上面的例子中，数字 25 被打印到终端，因为如果第一个操作数为 True，and 运算符将求值第二个操作数。and 运算符被称为“短路运算符”。短路意味着 Python 从左到右检查值，并在确定最终结果后立即停止。\n你经常会在 if 语句中使用 and 来检查是否满足多个条件。以下是将前面的例子重构为使用 and 运算符而不是嵌套 if 语句的方法：\n示例代码\nis_citizen = True\nage = 25\n\nif is_citizen and age &gt;= 18:\n    print('You are eligible to vote') # You are eligible to vote\nelse:\n    print('You are not eligible to vote')\n在上面的例子中，is_citizen 为 True，且 age &gt;= 18 求值为 True。由于 and 运算符的两个操作数都是“真值”，因此条件 is_citizen and age &gt;= 18 求值为 True，并执行 if 块中的打印调用。\n现在让我们看看 or 运算符。这个运算符如果第一个操作数是“真值”，则返回第一个操作数，否则返回第二个操作数。如果至少有一个操作数是“真值”，那么 or 表达式的结果就是“真值”。or 运算符也是一个“短路运算符”。这是一个例子：\n示例代码\nage = 19\nis_employed = False\n\nprint(age or is_employed) # 19\n下面的代码将打印数字 19，因为第一个操作数 age 是 True。\n如果你需要检查一个或多个表达式是否为 True，那么你可以在条件语句中使用 or 运算符，像这样：\n示例代码\nage = 19\nis_student = True\n\nif age &lt; 18 or is_student:\n    print('You are eligible for a student discount') # You are eligible for a student discount\nelse:\n    print('You are not eligible for a student discount')\n在这种情况下，age &lt; 18 是 False，但 is_student 是 True。由于至少有一个条件为真，整个 or 表达式求值为 True，并打印 if 块中的折扣信息。\n我们将要学习的最后一个运算符是 not 运算符，它接受一个操作数并反转其布尔值。它将“真值”转换为 False，将“假值”转换为 True。与我们之前看过的运算符不同，not 总是返回 True 或 False。\n以下是几个例子：\n示例代码\nprint(not '') # True, 因为空字符串是假值\nprint(not 'Hello') # False, 因为非空字符串是真值\nprint(not 0) # True, 因为 0 是假值\nprint(not 1) # False, 因为 1 是真值\nprint(not False) # True, 因为 False 是假值\nprint(not True) # False, 因为 True 是真值\n在条件语句中使用 not 运算符来检查某事是否为“非 True”或“非 False”是很常见的，像这样：\n示例代码\nis_admin = False\n\nif not is_admin:\n    print('Access denied for non-administrators.') # Access denied for non-administrators.\nelse:\n    print('Welcome, Administrator!')\n由于 is_admin 为 False，那么 not is_admin 就是在说“非 False”，即 True。所以消息 “Access denied for non-administrators.” 将被打印。\n现在你理解了“真值”和“假值”、and、or 和 not 运算符以及短路的工作原理，你就可以编写更灵活、更易读的条件逻辑了。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#understanding-functions-and-scope",
    "href": "cp_1.html#understanding-functions-and-scope",
    "title": "2  1 Python基础",
    "section": "2.6 Understanding Functions and Scope",
    "text": "2.6 Understanding Functions and Scope\n\n2.6.1 How Do Functions Work in Python?\n函数是可重复使用的代码块，当你调用它们时它们就会运行。许多编程语言都带有内置函数，这让入门变得更加容易。Python 也不例外，在之前的课程中我们已经介绍过一些内置函数，比如 print()。\n另一个有用的内置函数是 input()，它让你可以提示用户输入内容：\n示例代码\nname = input('What is your name?') # 用户输入 \"Kolade\" 并按下回车\nprint('Hello', name) # 输出: Hello Kolade\n另一方面，int() 可以将数字、布尔值和数值字符串转换为整数：\n示例代码\nprint(int(3.14)) # 3\nprint(int('42')) # 42\nprint(int(True)) # 1\nprint(int(False)) # 0\n你也可以编写自己的自定义函数。要做到这一点，你使用 def 关键字，后跟你想要给函数起的名字、一对括号和一个冒号。然后在新的一行，你编写函数应该运行的代码。函数运行的代码也被称为函数的主体（body）。\n这是一个名为 hello 的自定义函数的例子，它在终端打印字符串 “Hello World”：\n示例代码\ndef hello():\n    print('Hello World')\n要运行这个函数，你需要通过其名称后跟一对括号来调用它：\n示例代码\nhello() # Hello World\n请注意 print('Hello World') 前面的缩进。正如你可能从之前的课程中回忆起来的，Python 依靠缩进来确定哪些语句组属于在一起。这些语句组被称为代码块。\n这里是另一个简单的函数，它在终端打印两个数字的和：\n示例代码\ndef calculate_sum(a, b):\n    print(a + b)\n你可以看到，我们的函数 calculate_sum 在括号中有 a 和 b，它们由逗号分隔。这些被称为参数。将参数视为充当“槽位”的占位符变量，用于存放你调用函数时传入的值。\n要使用这些参数，你必须传入“实参”。实参是你在调用函数时传递给函数的值。\n这是如何调用 calculate_sum 函数来将数字 3 和 1 相加的例子：\n示例代码\ncalculate_sum(3, 1) # 4\n如果你没有传递正确数量的实参就调用函数，你会得到一个 TypeError（类型错误）：\n示例代码\ncalculate_sum()\n\n# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'\n函数还使用一个特殊的 return（返回）关键字来退出函数并返回一个值。如果你没有显式地使用 return，Python 将默认返回 None。\n这是一个例子：\n示例代码\ndef calculate_sum(a, b):\n    print(a + b)\n\nmy_sum = calculate_sum(3, 1) # 4\nprint(my_sum) # None\n你可以看到 calculate_sum 函数打印了 a 和 b 的和，但它没有显式地返回任何东西。所以当我们将其结果赋值给 my_sum 时，该值实际上是 None。为了解决这个问题，你可以使用 return 关键字来发送回结果：\n示例代码\ndef calculate_sum(a, b):\n    return a + b\n\nmy_sum = calculate_sum(3, 1)\nprint(my_sum) # 4\n现在，calculate_sum 返回了 a 和 b 的和，该和被存储在 my_sum 中。\n\n\n2.6.2 What Is Scope in Python and How Does It Work?\n在 Python 中，作用域（Scope）决定了你可以在代码的哪个位置访问一个变量。它控制着变量的生命周期，以及 Python 在代码的不同部分如何解析该变量。\n为了正确确定作用域，Python 遵循 LEGB 规则，其含义如下：\n\nL - 局部作用域 (Local scope)：在函数或类内部定义的变量。\nE - 闭合作用域 (Enclosing scope)：在嵌套函数（封闭函数）内部定义的变量。\nG - 全局作用域 (Global scope)：在模块或文件的顶层定义的变量。\nB - 内置作用域 (Built-in scope)：Python 预定义的函数、模块、关键字和对象等保留名称。\n\nPython 使用 LEGB 规则来解析程序中变量的作用域。我们将深入探讨每一个规则，以便你更好地理解这个过程。\n局部作用域意味着在函数或类内部声明的变量只能在该函数或类内部被访问。\n这是一个例子：\n示例代码\ndef my_func():\n    my_var = 10\n    print(my_var)\n在这种情况下，my_func 函数拥有它自己的作用域，该作用域无法从函数外部访问。调用 my_func 将输出 10，但在函数外部打印 my_var 会导致 NameError（名称错误）：\n示例代码\ndef my_func():\n    my_var = 10 # 在 my_func 内部局部作用域\n    print(my_var)\n\nmy_func() # 10\n\nprint(my_var) # NameError: name 'my_var' is not defined\n闭合作用域意味着一个嵌套在另一个函数内部的函数可以访问它所嵌套的外部函数的变量。\n例如：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n\n    def inner_func():\n        print(msg)\n\n    inner_func()\n\nouter_func() # Hello there!\n在这个例子中，内部函数 inner_func 可以自由地访问在外部函数 outer_func 中定义的 msg 变量。但是，请注意外部函数无法访问在任何嵌套函数内部定义的变量：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n    print(res) # 尝试访问尚未定义的 res\n\n    def inner_func():\n        res = 'How are you?'\n        print(msg)\n\n    inner_func()\n\nouter_func() # NameError: name 'res' is not defined\n这是因为 res 是在 inner_func 内部局部作用域的。另外，请注意 outer_func 尝试在调用 inner_func 之前打印 res。\n一个解决方案是在闭合作用域（即 outer_func 内部）将 res 初始化为空字符串。然后在 inner_func 内部，使用 nonlocal 关键字将 res 声明为非局部变量：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n    res = \"\"  # 在闭合作用域中声明 res\n\n    def inner_func():\n        nonlocal res  # 允许修改闭合作用域中的变量\n        res = 'How are you?'\n        print(msg)  # 访问 outer_func() 中的 msg\n\n    inner_func()\n    print(res)  # 现在 res 可以被访问且已被修改\n\nouter_func()\n\n# 输出:\n# Hello there!\n# How are you?\n全局作用域指的是在任何函数或类外部声明的变量，这些变量可以从程序的任何地方被访问。在这里，my_var 可以在任何地方被访问，即使是在它没有被定义的函数内部：\n示例代码\nmy_var = 100\n\ndef show_var():\n    print(my_var)\n\nshow_var() # 100\nprint(my_var) # 100\n如果你想让你在函数内部定义的局部变量在全局范围内可访问，你可以使用 global 关键字：\n示例代码\nmy_var_1 = 7\n\ndef show_vars():\n    global my_var_2\n    my_var_2 = 10\n    print(my_var_1)\n    print(my_var_2)\n\nshow_vars() # 7 10\n\n# my_var_2 现在是一个全局变量，可以在程序的任何地方被访问\nprint(my_var_2) # 10\n你也可以使用 global 关键字来修改一个全局变量：\n示例代码\nmy_var = 10  # 一个全局变量\n\ndef change_var():\n    global my_var  # 允许修改全局变量\n    my_var = 20\n\nchange_var()\n\nprint(my_var)  # my_var 现在被全局修改为 20\n最后，内置作用域指的是 Python 所有的内置函数、模块和关键字，它们在程序的任何地方都可用：\n示例代码\nprint(str(45)) # '45'\nprint(type(3.14)) # &lt;class 'float'&gt;\nprint(isinstance(3, str)) # False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_2.html",
    "href": "cp_2.html",
    "title": "3  循环和序列",
    "section": "",
    "text": "3.1 处理循环（Loops）和序列（Sequences）",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>循环和序列</span>"
    ]
  },
  {
    "objectID": "cp_2.html#working-with-loops-and-sequences",
    "href": "cp_2.html#working-with-loops-and-sequences",
    "title": "3  循环和序列",
    "section": "",
    "text": "3.1.1 What Are Lists and How Do They Work?\n在接下来的几节课中，我们将学习列表（lists）、元组（tuples）和范围（ranges），这是 Python 中使用的三种基本序列类型。\n列表（list）数据类型是由元素组成的有序序列，它可以包含字符串、数字，甚至其他列表。列表是可变的（mutable），并使用从零开始的索引（zero-based indexing），这意味着列表的第一个元素位于索引 0 处。\n以下是列表的基本语法：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\n要访问 cities 列表中的元素，你可以引用它在序列中的索引号。以下是访问 cities 列表第一个元素的例子：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\ncities[0] # 'Los Angeles'\n负索引（Negative indexing）用于从列表的末尾开始访问元素，而不是从索引 0 开始。要访问任何列表的最后一个元素，你可以像这样使用 -1：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\ncities[-1] # 'Tokyo'\n创建列表的另一种方法是使用 list() 构造函数。list() 构造函数用于将一个可迭代对象转换为列表，像这样：\n示例代码\ndeveloper = 'Jessica'\nlist(developer) # ['J', 'e', 's', 's', 'i', 'c', 'a']\n可迭代对象（iterable）是一种特殊的对象类型，它可以一次循环遍历一个项目。你将在以后学习 Python 循环时了解更多相关内容。\n要获取列表中元素的总数，你可以使用 len() 函数，像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nlen(numbers) # 5\n如果你想更新特定索引处的值，你可以这样做：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\nprogramming_languages[0] = 'JavaScript'\nprint(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']\n由于列表是可变的，只要你传入一个有效的索引号，你就可以更新列表中的任何元素。如果你传入一个超出列表范围的索引（无论是正数还是负数），你将会收到一个 IndexError（索引错误）：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\nprogramming_languages[10] = 'JavaScript'\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nIndexError: list assignment index out of range\n\"\"\"\n如果你想从列表中删除一个元素，你可以使用 del 关键字，像这样：\n示例代码\ndeveloper = ['Jane Doe', 23, 'Python Developer']\ndel developer[1]\nprint(developer) # ['Jane Doe', 'Python Developer']\n有时检查一个元素是否在列表中会很有帮助。要做到这一点，你可以使用 in 关键字，像这样：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\n\n'Rust' in programming_languages # True\n'JavaScript' in programming_languages # False\n有时在一个列表中包含其他列表是很常见的，像这样：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\n在这个例子中，我们有一个嵌套列表，包含三种流行的编程语言。要访问这个嵌套列表，你需要使用索引 2 来访问它，因为列表是零索引的：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\ndeveloper[2] # ['Python', 'Rust', 'C++']\n然后要访问该嵌套列表中的第二种语言，你需要像这样使用索引 1：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\ndeveloper[2][1] # 'Rust'\n列表的另一个常用技术是解包值（unpacking values）。\n从列表中解包值是一种将列表中的值分配给新变量的技术。以下是将一个 developer 列表解包为名为 name、age 和 job 的新变量的例子。\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, age, job = developer\n\nprint(name) # 'Alice'\nprint(age) # 34\nprint(job) # 'Rust Developer'\n在这里，name 的值是 ‘Alice’，age 的值是 34，job 的值是 ‘Rust Developer’。\n如果你需要收集列表中的任何剩余元素，你可以使用星号（*）操作符，像这样：\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, *rest = developer\n\nprint(name) # 'Alice'\nprint(rest) # [34, 'Rust Developer']\n在这个例子中，name 仍然有值 ‘Alice’，而 rest 是一个包含两个项目的列表：数字 34 和字符串 ‘Rust Developer’。\n如果赋值运算符左侧的变量数量与列表中的项目总数不匹配，你将会收到一个 ValueError（值错误）：\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, age, job, city = developer\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError: not enough values to unpack (expected 4, got 3)\n\"\"\"\n我们将要学习的最后一个概念是切片操作符（slice operator）（:）。与字符串类似，你可以使用切片操作符来访问列表的一部分，像这样：\n示例代码\ndesserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie', 'Brownies']\ndesserts[1:4] # ['Cookies', 'Ice Cream', 'Pie']\n在这个例子中，起始索引是 1，因为它指向列表中的第二项。然后我们使用切片操作符，后跟一个结束索引 4，它包括从起始索引到（但不包括）该索引处的项目的所有内容。\n你可以用切片操作符（:）做的另一件事是指定一个步长间隔（step interval），它确定索引之间的增量。假设你有一个像这样的数字列表：\n示例代码\nnumbers = [1, 2, 3, 4, 5, 6]\n如果你想提取一个只包含偶数的列表，你可以像这样使用切片操作符：\n示例代码\nnumbers = [1, 2, 3, 4, 5, 6]\nnumbers[1::2] # [2, 4, 6]\n第一个偶数位于索引 1，所以那将是起始索引。由于我们想要遍历到列表的末尾，所以我们省略了结束索引。最后，我们为可选的步长间隔指定了 2，因此它只会以 2 为增量递增，而不是默认的 1。\n列表是一种非常有用且灵活的数据结构，你将在 Python 程序中大量使用它。在下一课中，你将学习可以与列表一起使用的常见方法。\n\n\n3.1.2 What Are Some Common Methods Used for Lists?\n在上一课中，你接触了列表（list）数据类型，并学习了如何访问列表中的元素以及列表切片。在本课中，你将继续学习关于列表的知识，以及与其相关的一些常见方法，如 append()、pop() 和 sort()。\n我们将要学习的第一个方法是 append() 方法。它用于将一个项目添加到列表的末尾。以下是使用 append() 方法将数字 6 添加到数字列表中的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.append(6)\nprint(numbers) # [1, 2, 3, 4, 5, 6]\n如果你想将一个列表添加到另一个列表的末尾，也可以像这样使用 append() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [6, 8, 10]\n\nnumbers.append(even_numbers)\nprint(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]\n请注意，整个 even_numbers 列表是如何作为嵌套列表被放入 numbers 列表中的。\n但是，如果你想将 even_numbers 列表中的所有单个数字添加到 numbers 列表的末尾，那么你可以使用 extend() 方法。\nextend() 方法与 append() 方法类似，但使用 extend() 你可以将一个列表中的多个元素添加到另一个列表中。以下是将数字 6、8 和 10 从一个列表添加到 numbers 列表末尾的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [6, 8, 10]\n\nnumbers.extend(even_numbers)\nprint(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]\n正如你所见，嵌套列表消失了，现在它只是一个单纯的数字列表。\n要在列表的特定索引处插入一个元素，你可以使用 insert() 方法。该方法接受两个参数：你希望插入新项目的索引位置，以及你想要插入的项目。\n以下是使用 insert() 方法的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.insert(2, 2.5)\n\nprint(numbers) # [1, 2, 2.5, 3, 4, 5]\n以下代码将把数字 2.5 插入到 numbers 列表的索引 2 处。\n如果你想从列表中移除一个元素，你可以使用 remove() 方法。remove() 方法将要移除的元素值作为参数：\n示例代码\nnumbers = [10, 20, 30, 40, 50, 50]\nnumbers.remove(50)\n\nprint(numbers) # [10, 20, 30, 40, 50]\n需要注意的是，此方法只会移除该项目的第一次出现，而不是全部：\n示例代码\nnumbers = [10, 20, 30, 40, 50, 50, 50]\nnumbers.remove(50)\n\nprint(numbers) # [10, 20, 30, 40, 50, 50]\n要移除列表中特定索引处的元素，你可以像这样使用 pop() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.pop(1) # 返回数字 2\n如果你没有为 pop 方法指定索引，那么它将移除最后一个元素。\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.pop() # 返回数字 5\n如果你需要清空列表，那么你可以像这样使用 clear() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.clear()\n\nprint(numbers) # []\n我们将要学习的下一个方法是 sort() 方法。此方法用于对列表进行原地排序（in place）。以下是原地排序一个随机数字列表的例子：\n示例代码\nnumbers = [19, 2, 35, 1, 67, 41]\nnumbers.sort()\n\nprint(numbers) # [1, 2, 19, 35, 41, 67]\n与 sort() 方法相反，有一个 sorted() 函数，它可以用于任何可迭代对象，并返回一个新的已排序列表，而不是修改原始列表。例如：\n示例代码\nnumbers = [19, 2, 35, 1, 67, 41]\nsorted_numbers = sorted(numbers)\n\nprint(numbers) # [19, 2, 35, 1, 67, 41]\nprint(sorted_numbers) # [1, 2, 19, 35, 41, 67]\n提醒一下，可迭代对象（iterable）是一种特殊类型的对象，你可以循环遍历它，从而一次访问一个项目。你将在以后的课程中学习更多关于 Python 循环的知识。\nsort() 方法和 sorted() 函数都接受可选的 key 和 reverse 参数。当你学习元组时，将在以后的课程中了解更多关于这些可选参数的知识。你也将学习更多关于 sorted() 等其他内置函数的知识。\n我们将要学习的下一个方法是 reverse() 方法。此方法将原地反转列表中的元素，像这样：\n示例代码\nnumbers = [6, 5, 4, 3, 2, 1]\nnumbers.reverse()\n\nprint(numbers) # [1, 2, 3, 4, 5, 6]\n我们将要学习的最后一个方法是 index 方法。它用于查找列表中某个元素第一次出现的索引。以下是使用 index 方法在 programming_languages 列表中查找语言 ‘Java’ 的例子：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\nprogramming_languages.index('Java') # 1\n如果找不到该元素，Python 将抛出 ValueError：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\nprogramming_languages.index('JavaScript')\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: 'JavaScript' is not in list\n\"\"\"\nPython 列表还有一些其他方法，但这个初始方法列表是一个很好的开始。\n\n\n3.1.3 What Are Tuples and How Do They Work?\n元组（tuple）是一种 Python 数据类型，用于创建一个有序的值序列。元组可以包含一组混合的数据类型，像这样：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\n元组与列表类似，但列表是可变数据类型，而元组是不可变的。这意味着一旦元组被创建，其中的元素就不能被更改。\n如果你试图更新元组中的某一项，你会得到一个 TypeError（类型错误）：\n示例代码\nprogramming_languages = ('Python', 'Java', 'C++', 'Rust')\nprogramming_languages[0] = 'JavaScript'\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n\"\"\"\n要访问元组中的元素，你可以使用方括号表示法和索引号：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\ndeveloper[1] # 34\n如果你需要从元组的末尾开始访问元素，你可以使用负索引。以下是使用负索引访问元组中倒数第二个元素的例子：\n示例代码\nnumbers = (1, 2, 3, 4, 5)\nnumbers[-2] # 4\n如果你传入的索引号超出了元组的长度（即索引越界），你会收到一个 IndexError（索引错误），像这样：\n示例代码\nnumbers = (1, 2, 3, 4, 5)\nnumbers[7]\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nIndexError: tuple index out of range\n\"\"\"\n创建元组的另一种方法是使用 tuple() 构造函数，像这样：\n示例代码\ndeveloper = 'Jessica'\ntuple(developer) # ('J', 'e', 's', 's', 'i', 'c', 'a')\n对于 tuple() 构造函数，你可以传入不同的可迭代对象，如字符串、列表甚至其他元组。\n要检查某项是否在元组中，你可以使用 in 关键字，像这样：\n示例代码\nprogramming_languages = ('Python', 'Java', 'C++', 'Rust')\n\n'Rust' in programming_languages # True\n'JavaScript' in programming_languages # False\n你也可以像对列表那样，对元组进行解包（unpacking）操作：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\nname, age, job = developer\n\nprint(name) # 'Alice'\nprint(age) # 34\nprint(job) # 'Rust Developer'\n在这个例子中，name 的值是 ‘Alice’，age 的值是 34，job 的值是 ‘Rust Developer’。\n如果你需要收集元组中的任何剩余元素，你可以使用星号（*）操作符，像这样：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\nname, *rest = developer\n\nprint(name) # 'Alice'\nprint(rest) # [34, 'Rust Developer']\n在这里，name 的值是 ‘Alice’，而 rest 是一个包含数字 34 和字符串 ‘Rust Developer’ 的列表。\n就像对列表一样，你可以在元组上使用切片操作符来提取其中的一部分。以下是将 ‘pie’ 和 ‘cookies’ 提取到一个新元组中的例子：\n示例代码\ndesserts = ('cake', 'pie', 'cookies', 'ice cream')\ndesserts[1:3] # ('pie', 'cookies')\n请记住，第一个数字表示提取的起始索引，第二个数字表示结束索引。但请注意，结束索引处的项目不包含在提取的新元组中。\n如果你想从元组中删除一个项目，那是不可能的，因为元组是不可变的。所以这个例子会产生一个错误：\n示例代码\ndeveloper = ('Jane Doe', 23, 'Python Developer')\ndel developer[1]\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: \"tuple\" object doesn't support item deletion\n\"\"\"\n那么，什么时候应该使用元组而不是列表呢？\n如果你需要一个动态的元素集合，其中可以添加、删除和更新元素，那么你应该使用列表。如果你知道你正在处理一组固定且不可变的数据，那么你应该使用元组。\n在下一课中，我们将看看处理元组时会使用的一些常见方法。\n\n\n3.1.4 What Are Some Common Methods for Tuples?\n在上一课中，你学习了如何使用元组（tuple）数据类型。在本课中，你将学习处理元组时会使用的一些常见方法。\n我们将要介绍的第一个方法是 count()。此方法用于确定某项在元组中出现了多少次。以下是检查名为 programming_languages 的元组中字符串 “Rust” 出现了多少次的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count('Rust') # 2\n由于 Rust 在元组中出现了两次，count() 方法返回数字 2。如果 count() 函数中指定的项在元组中完全不存在，则返回值为 0：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count('JavaScript') # 0\n如果没有任何参数传入 count() 函数，Python 会引发 TypeError（类型错误）：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count()\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: tuple.count() takes exactly one argument (0 given)\n\"\"\"\n我们将要介绍的下一个方法是 index() 方法。此方法用于查找特定项在元组中的索引位置。以下是使用 index() 方法查找字符串 “Java” 索引的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.index('Java') # 1\n如果找不到指定的项，Python 会引发 ValueError（值错误）：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.index('JavaScript')\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError: tuple.index(x): x not in tuple\n\"\"\"\n使用 index() 方法的另一件事是可以传入可选的起始索引（start）和结束索引（stop）参数。以下是传入可选起始索引的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\nprogramming_languages.index('Python', 3) # 5\n在这个例子中，我们指定了从哪里开始搜索字符串 “Python”。通过将数字 3 作为第二个参数传入 index() 函数，我们指定了从索引 3 开始搜索。由于 “Python” 在元组中出现了两次，index() 函数将返回索引 5 而不是索引 2，这是因为使用了可选的起始索引参数。\n你也可以传入一个可选的结束索引。以下是同时指定起始索引和结束索引的修改示例：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')\nprogramming_languages.index('Python', 2, 5) # 2\n现在结果是索引 2，因为我们从索引 2 开始搜索，并搜索到（但不包括）索引 5。\n与元组一起使用的另一个常用函数是 sorted() 函数。在上一课中，你学习了列表的 sort() 方法。sorted() 函数可以用于任何可迭代对象，包括元组。\n以下是使用 sorted() 函数创建一个新数字列表的例子：\n示例代码\nnumbers = (13, 2, 78, 3, 45, 67, 18, 7)\nsorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]\nsorted() 函数总是会创建一个由排序后值组成的新列表。这与 sort() 方法不同，sort() 方法是在原地对列表元素进行排序，并且不会返回一个新列表。\n如果你需要自定义可迭代对象的排序行为，你可以使用可选的 reverse（反转）和 key（键）参数。以下是使用 key 参数按长度对元组中的项进行排序的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\nsorted(programming_languages, key=len)\n\n# 结果\n# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']\n如果你想创建一个逆序的新值列表，你可以像这样使用 reverse 参数：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\n\nprint(sorted(programming_languages, reverse=True))\n\n# 结果\n# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']\n元组是 Python 中一种常见的数据类型。理解如何使用它们，以及一些有用的方法和函数，将帮助你编写更高效的代码。\n\n\n3.1.5 How Do Loops Work?\n正如你在之前的模块中学到的，循环用于将一块代码重复执行指定的次数。在本课中，你将学习如何在 Python 中使用不同类型的循环。\n我们将要介绍的第一种循环是 for 循环。以下是使用 for 循环遍历列表并打印每一项到控制台的例子：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\n\nfor language in programming_languages:\n    print(language)\n结果将是：\n示例代码\nRust\nJava\nPython\nC++\n请注意，print(language) 在循环内部是缩进的。如果没有缩进，你会收到一个 IndentationError（缩进错误）：\n示例代码\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 4, in &lt;module&gt;\nIndentationError: expected an indented block after 'for' statement on line 3\n\"\"\"\n你也可以使用 for 循环来遍历其他可迭代对象，比如字符串。以下是使用 for 循环遍历字符串 “code” 并打印每个字符的例子：\n示例代码\nfor char in 'code':\n    print(char)\n结果将是：\n示例代码\nc\no\nd\ne\n就像在 JavaScript 中一样，你也可以在 Python 中嵌套 for 循环。以下是使用嵌套 for 循环的例子：\n示例代码\ncategories = ['Fruit', 'Vegetable']\nfoods = ['Apple', 'Carrot', 'Banana']\n\nfor category in categories:\n    for food in foods:\n        print(category, food)\n外层循环将遍历 categories 列表中的每个类别。对于每个类别，内层循环将遍历 foods 列表中的每种食物。以下是将被打印到控制台的结果：\n示例代码\nFruit Apple\nFruit Carrot\nFruit Banana\nVegetable Apple\nVegetable Carrot\nVegetable Banana\n你可以在 Python 中使用的另一种循环是 while 循环。这种循环将重复执行一块代码，直到条件为 False。以下是使用 while 循环制作猜数字游戏的例子：\n示例代码\nsecret_number = 3\nguess = 0\n\nwhile guess != secret_number:\n    guess = int(input('Guess the number (1-5): '))\n    if guess != secret_number:\n        print('Wrong! Try again.')\n\nprint('You got it!')\n在这个例子中，我们有一个值为 3 的 secret_number 变量和一个初始值为 0 的 guess。然后我们使用 input 函数获取用户的输入，然后使用 int() 函数将输入的字符串转换为整数，并将其赋值给 guess 变量。如果用户通过输入 3 猜对了，while 循环将被跳出，消息 “You got it!” 将被打印到控制台。否则，消息 “Wrong! Try again.” 将被打印到控制台，循环重复，提示用户再次猜测。\n以下是结果的一个例子：\n示例代码\nGuess the number (1-5): 2\nWrong! Try again.\nGuess the number (1-5): 1\nWrong! Try again.\nGuess the number (1-5): 3\nYou got it!\n就像在 JavaScript 中一样，Python 支持 break 和 continue 语句。\nbreak 语句用于停止循环的执行。以下是针对 developer_names 列表使用 break 语句的例子：\n示例代码\ndeveloper_names = ['Jess', 'Naomi', 'Tom']\n\nfor developer in developer_names:\n    if developer == 'Naomi':\n        break\n    print(developer)\n在这个例子中，我们遍历 developer_names 列表并打印每个名字到控制台。如果名字等于 ‘Naomi’，我们就跳出循环。这导致只有名字 ‘Jess’ 被打印到控制台。\ncontinue 语句用于跳过循环的当前迭代，并继续下一个迭代。让我们修改前面的例子，使用 continue 语句代替 break：\n示例代码\ndeveloper_names = ['Jess', 'Naomi', 'Tom']\n\nfor developer in developer_names:\n    if developer == 'Naomi':\n        continue\n    print(developer)\n现在控制台中的结果将不同。名字 ‘Jess’ 和 ‘Tom’ 被打印，因为当 developer 等于 ‘Naomi’ 时，continue 语句跳过了循环的第二次迭代，因此该名字没有被打印到控制台。\nfor 和 while 循环都可以与 else 子句结合使用，该子句仅在循环没有被 break 语句终止时执行。以下是使用多重 for 循环的例子：\n示例代码\nwords = ['sky', 'apple', 'rhythm', 'fly', 'orange']\n\nfor word in words:\n    for letter in word:\n        if letter.lower() in 'aeiou':\n            print(f\"'{word}' contains the vowel '{letter}'\")\n            break\n    else:\n        print(f\"'{word}' has no vowels\")\n在这个例子中，我们有一个随机单词列表，并使用 for 循环遍历每个单词。在外层 for 循环内部，我们有另一个 for 循环来遍历每个单词的每个字母。如果字母的小写版本是元音字母，我们打印单词以及它包含的元音字母，然后跳出内层循环。如果单词不包含元音字母，我们打印一条消息来指示这一点。\n以下是结果在控制台中的样子：\n示例代码\n'sky' has no vowels\n'apple' contains the vowel 'a'\n'rhythm' has no vowels\n'fly' has no vowels\n'orange' contains the vowel 'o'\n循环在 Python 中非常常见，因此熟悉它们非常重要。在接下来的几节课中，你将学习如何在循环中使用 enumerate() 和 range() 函数。\n\n\n3.1.6 What Are Ranges and How Can You Use Them in a Loop?\nrange() 函数用于生成一个整数序列。以下是 range() 函数的基本语法：\n示例代码\nrange(start, stop, step)\n其中必选参数 stop 是一个整数，它代表生成数字序列的终点。以下是使用 range() 函数的例子：\n示例代码\nfor num in range(3):\n    print(num)\n以下代码生成了一个介于 0 和 2 之间的数字序列。整数 3 不包含在内，因为 stop 参数是不包含终点值的（非 inclusive）。\n如果未指定 start 参数，则默认值为 0。否则，你可以使用可选的 start 参数，让整数序列从非 0 的整数开始。以下是生成介于 1 和 4 之间整数序列的例子：\n示例代码\nfor num in range(1, 5):\n    print(num)\n默认情况下，整数序列将以 1 为步长递增。但如果你想更改这个默认值，可以使用可选的 step 参数。以下是生成介于 2 和 10 之间偶数序列的例子：\n示例代码\nfor num in range(2, 11, 2):\n    print(num)\n正如前面提到的，range() 函数只有一个必选参数。如果你不给 range() 传递任何参数，你会得到一个 TypeError：\n示例代码\nERROR!\nTraceback (most recent call last):\n  File \"&lt;main.py&gt;\", line 1, in &lt;module&gt;\nTypeError: range expected at least 1 argument, got 0\n需要注意的是，range() 函数只接受整数作为参数，不接受浮点数。请记住，浮点数是带有小数点的数字，比如 3.4。如果你尝试传递浮点数作为参数，你会得到一个 TypeError：\n示例代码\nERROR!\nTraceback (most recent call last):\n  File \"&lt;main.py&gt;\", line 1, in &lt;module&gt;\nTypeError: 'float' object cannot be interpreted as an integer\n如果你想生成一个按递减顺序排列的整数序列，可以为 step 参数使用负整数，像这样：\n示例代码\nfor num in range(40, 0, -10):\n    print(num)\n以下代码将按顺序在控制台打印数字 40、30、20 和 10。\n使用 range() 函数的另一件事是，你可以将其与列表构造函数（list constructor）结合使用，以创建一个整数列表。列表构造函数用于将一个可迭代对象转换为列表。以下是生成一个介于 2 和 10 之间偶数列表的例子：\n示例代码\nnumbers = list(range(2, 11, 2))\nprint(numbers) # [2, 4, 6, 8, 10]\nrange() 函数是在 Python 中生成整数序列的一种非常方便的方法。一旦你掌握了它，你可能会发现自己在 Python 程序中会频繁使用它。\n\n\n3.1.7 What Are the Enumerate and Zip Functions and How Do They Work?\n在之前的课程中，你学习了如何使用 for 循环，它用于将一块代码重复执行指定的次数。以下是使用 for 循环将 languages 列表中的每种语言打印到控制台的例子：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor language in languages:\n    print(language)\n但是，如果你想要跟踪每个元素的索引怎么办？一种方法是创建一个索引变量，并在循环的每次迭代中将其加 1，像这样：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nindex = 0\n\nfor language in languages:\n    print(f'Index {index} and language {language}')\n    index += 1\n虽然这样做可行，但更简单的方法是使用 enumerate() 函数。enumerate() 函数会跟踪可迭代对象的索引，并返回一个枚举对象（enumerate object）。\n如果我们把 languages 列表传递给 enumerate() 函数，并使用 list() 函数将其返回值转换为列表，它看起来像这样：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nlist(enumerate(languages))\n#\n枚举对象（现在是一个列表）中的每个条目都是一个元组，其中包含一个计数器（count），后面跟着从传递给 enumerate() 函数的可迭代对象中获取的值。\n现在，让我们重构前面的例子，使用 enumerate() 函数：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor index, language in enumerate(languages):\n    print(f'Index {index} and language {language}')\n我们把枚举对象中每个元组的计数器和值解包（unpack）到分别名为 index 和 language 的变量中。最后，在循环的每次迭代中，这两个变量都被用于一个打印到控制台的 f-string（格式化字符串）中。\n示例代码\nIndex 0 and language Spanish\nIndex 1 and language English\nIndex 2 and language Russian\nIndex 3 and language Chinese\n这样就无需手动创建和更新索引变量了。\nenumerate() 函数还接受一个可选的 start 参数，用于指定计数的起始值。如果省略此参数，则计数将从 0 开始。以下是使用可选 start 参数的例子：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor index, language in enumerate(languages, 1):\n    print(f'Index {index} and language {language}')\n以下是结果在控制台中的样子：\n示例代码\nIndex 1 and language Spanish\nIndex 2 and language English\nIndex 3 and language Russian\nIndex 4 and language Chinese\n到目前为止，我们只遍历了一个列表。但是，如果你需要并行地遍历多个可迭代对象怎么办？你可以使用 zip() 函数，它将列表组合成元素对，并返回一个元组迭代器。\n如果我们把一个开发者列表和一个 ID 列表传递给 zip() 函数，并使用 list() 函数将其返回值转换为列表，它看起来像这样：\n示例代码\ndevelopers = ['Naomi', 'Dario', 'Jessica', 'Tom']\nids = [1, 2, 3, 4]\n\nlist(zip(developers, ids))\n#\n以下是一个在 for 循环中使用 zip() 函数遍历开发者和 ID 的例子：\n示例代码\ndevelopers = ['Naomi', 'Dario', 'Jessica', 'Tom']\nids = [1, 2, 3, 4]\n\nfor name, id in zip(developers, ids):\n    print(f'Name: {name}')\n    print(f'ID: {id}')\n在这个例子中，zip() 将两个列表组合成元素对，并返回一个元组迭代器。for 循环然后将每个元组解包为 name 和 id。最后，对于每个打印语句，我们分别从 ids 和 developers 列表中打印每个名字和 ID。以下是结果在控制台中的样子：\n示例代码\nName: Naomi\nID: 1\nName: Dario\nID: 2\nName: Jessica\nID: 3\nName: Tom\nID: 4\nenumerate() 和 zip() 函数功能非常强大，当与循环结合使用时，可以使你的代码更加简洁。\n\n\n3.1.8 What Are List Comprehensions and What Are Some Useful Functionsto Work With Lists?\n在过去的几节课中，你已经习惯了像这样使用循环：\n示例代码\neven_numbers = []\n\nfor num in range(21):\n    if num % 2 == 0:\n        even_numbers.append(num)\n\nprint(even_numbers)\n这个例子创建了一个名为 even_numbers 的新空列表，并遍历 0 到 20 之间的一系列数字。在循环内部，有一个条件判断，检查当前数字除以 2 的余数是否为 0。这用于确定该数字是否为偶数。如果条件为 True，则将当前的 num 添加到 even_numbers 列表的末尾。最后，我们将 even_numbers 列表打印到控制台。\n虽然这段代码可以工作，但有一种更简洁的写法，那就是使用列表推导式（list comprehension）。列表推导式允许你通过将循环和条件直接组合在方括号内，在一行代码中创建一个新列表。这使得代码更短，通常也更易读。\n以下是使用方括号重构后的例子：\n示例代码\neven_numbers = [num for num in range(21) if num % 2 == 0]\nprint(even_numbers)\n在这个重构的例子中，even_numbers 列表是使用单行代码创建的。列表推导式遍历 0 到 20 的数字，并且只包含那些能被 2 整除的数字。这种方法更紧凑，消除了对单独的循环和条件块的需求。\n让我们再看一个例子，以便更好地理解列表推导式是如何工作的：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nresult = [(num, 'Even') if num % 2 == 0 else (num, 'Odd') for num in numbers]\nprint(result)\n在这个例子中，我们有一个数字列表，并想要创建一个新列表，其中包含指示哪些数字是偶数或奇数的元组。在列表推导式的第一部分，我们使用一个 if 语句来检查数字是否能被 2 整除。如果是，那么结果就是一个包含该数字后跟单词 ‘Even’ 的元组。否则，结果就是一个包含该数字后跟单词 ‘Odd’ 的元组。\n以下是结果打印在控制台中的样子：\n示例代码\n\n从现有可迭代对象创建列表的另一种方法是 filter() 函数。以下是创建一个仅包含超过四个字符的单词的新列表的例子：\n示例代码\nwords = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']\n\ndef is_long_word(word):\n    return len(word) &gt; 4\n\nlong_words = list(filter(is_long_word, words))\nprint(long_words) # ['mountain', 'river', 'cloud']\nfilter() 函数用于从可迭代对象中选择满足特定条件的元素。filter() 函数接受一个函数和一个可迭代对象作为其参数。在这个例子中，我们将一个 is_long_word 函数传递给 filter() 函数，以检查当前单词的长度是否大于 4。所有字符数大于 4 的单词都会被添加到一个新列表中，并赋值给 long_words 变量。\n除了 filter() 函数外，还有一些在处理列表时很有用的函数。另一个需要注意的函数是 map() 函数，它接受一个可迭代对象并将其每个元素都应用一个函数。以下是使用 map() 函数将摄氏度温度列表转换为华氏度的例子：\n示例代码\ncelsius = [0, 10, 20, 30, 40]\n\ndef to_fahrenheit(temp):\n    return (temp * 9/5) + 32\n\nfahrenheit = list(map(to_fahrenheit, celsius))\nprint(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]\n就像 filter() 函数一样，map() 接受一个函数和一个可迭代对象作为其参数。to_fahrenheit 函数接受一个温度值并将其从摄氏度转换为华氏度。\n我们将要介绍的最后一个函数是 sum() 函数。此函数用于获取像列表或元组这样的可迭代对象的总和。以下是使用 sum() 函数的例子：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers)\nprint(total) # 结果: 50\n你也可以传入一个可选的 start 参数，它设置求和的初始值。以下是使用 start 参数作为位置参数的更新示例：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers, 10) # 位置参数\nprint(total) # 60\n你也可以选择将 start 参数用作关键字参数，像这样：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers, start=10) # 关键字参数\nprint(total) # 60\n这两个版本将产生相同的结果，但关键字参数的写法更明确一些。\n列表推导式以及像 map()、filter() 和 sum() 这样的其他函数一开始可能看起来有点令人困惑。但通过足够的练习和时间，你会开始在 Python 程序中使用它们时感到更加得心应手。\n\n\n3.1.9 What Are Lambda Functions and How DoThey Work?\n在之前的课程中，你已经习惯了使用 def 关键字来定义函数，就像这样：\n示例代码\ndef square(num):\n    return num ** 2\n\nprint(square(4)) # 16\n但是，当涉及到像 map() 和 filter() 这样的高阶函数时，你可以使用匿名的内联函数。这就用到了 lambda 函数。\n以下是将 square() 函数重构为 lambda 函数后的样子：\n示例代码\nlambda num: num ** 2\n正如前面提到的，lambda 函数是匿名的，所以这个函数不再有 square 这个名字与之关联。当你需要在高阶函数中使用它们时，lambda 函数非常有用，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # [2, 4]\n在这个例子中，我们有一个数字列表，并想要创建一个只包含偶数的新列表。所以我们把一个 lambda 函数作为参数之一传递给 filter() 函数，以获取包含数字 2 和 4 的新列表。\n在使用 lambda 函数时，需要注意最佳实践。例如，将 lambda 函数赋值给一个变量并不是一个好的做法，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\nsquare = lambda x: x ** 2\nsquared_numbers = list(map(square, numbers))\nprint(squared_numbers) # [1, 4, 9, 16, 25]\n这样做违背了使用匿名函数的初衷。在这种情况下，你应该使用一个普通的函数，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\ndef square(num):\n    return num ** 2\n\nsquared_numbers = list(map(square, numbers))\nprint(squared_numbers) # [1, 4, 9, 16, 25]\n此外，你应该避免创建难以阅读或不必要地复杂的 lambda 函数，就像这样：\n示例代码\nresult = (lambda x: (x**2 + 2*x - 1) if x &gt; 0 else (x**3 - x + 4))(3)\nprint(result)  # 14\n虽然这个函数运行良好并产生了正确的结果 14，但它并不容易阅读或查看。在这种情况下，最好创建一个带有 if/else 语句的单独函数，然后调用该函数：\n示例代码\ndef calculate_expression(x):\n    if x &gt; 0:\n        return x**2 + 2*x - 1\n    else:\n        return x**3 - x + 4\n\nprint(calculate_expression(3))  # 14\n在 Python 程序中，普通函数和 lambda 函数都有它们的用武之地。如果你处理的是单行内联表达式，那么你可能会考虑使用 lambda 函数。否则，使用普通函数将是更好的选择。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>循环和序列</span>"
    ]
  },
  {
    "objectID": "cp_3.html",
    "href": "cp_3.html",
    "title": "4  字典和集合",
    "section": "",
    "text": "4.1 处理字典（Dictionaries）和集合（Sets）",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>字典和集合</span>"
    ]
  },
  {
    "objectID": "cp_3.html#working-with-dictionaries-and-sets",
    "href": "cp_3.html#working-with-dictionaries-and-sets",
    "title": "4  3 字典和集合",
    "section": "",
    "text": "4.1.1 What Are Dictionaries, and How Do They Work?\n在 Python 中，字典（dictionaries）是内置的数据结构，用于存储键值对（key-value pairs）的集合。它们的工作方式与真实世界的字典非常相似，你通过查找一个单词来找到它对应的含义。\n在 Python 字典中，你使用一个键来找到它对应的值。当你需要将值关联到唯一的键时，就应该使用字典。当你需要根据键快速查找值，或者需要表示结构化数据时，字典非常有用。\n这是 Python 字典的一般语法：\n示例代码\ndictionary = {\n    key1: value1,\n    key2: value2\n}\n首先，我们看到一个变量用来存储字典。你不一定非要把字典赋值给一个变量，但这样做非常普遍，目的是将其保存在内存中，以便稍后在代码中使用。\n然后是花括号（有时也称为大括号）。在花括号内，包含着键值对。\n每个键都关联着一个值，因此你可以使用键来访问该值。除了最后一个键值对外，每个值后面都有一个逗号，用来分隔不同的键值对。字典中的键必须是唯一的，并且必须是不可变的数据类型。但是，值可以重复，并且可以是任何数据类型。\n这里有一个字典的例子，它存储了关于玛格丽塔披萨食谱的信息：\n示例代码\npizza = {\n    'name': 'Margherita Pizza',\n    'price': 8.9,\n    'calories_per_slice': 250,\n    'toppings': ['mozzarella', 'basil']\n}\n该字典被赋值给 pizza 变量。它包含四个键值对：name、price、calories_per_slice 和 toppings。\n另一种替代方法是使用 dict() 构造函数，它可以从一系列键值对中构建字典。\n这是我们披萨例子的等效语法。我们将一个元组列表作为参数传递给 dict() 构造函数。这些元组包含键作为第一个元素，值作为第二个元素。\n示例代码\npizza = dict()\n要访问键值对的值，你可以使用这种语法，称为方括号表示法（bracket notation）。它是持有字典的变量名，后跟方括号，以及你想要访问的键：\n示例代码\ndictionary[key]\n在我们的披萨例子中，如果你想访问 name 的值，你会写下变量名 pizza，后跟方括号，以及在引号内的键 name：\n示例代码\npizza['name']\n这将计算为：\n示例代码\n'Margherita Pizza'\n要更新一个值，你只需要添加赋值运算符，后跟新值。\n如果字典中不存在该键，将创建一个新的键值对。在 Python 的较新版本中，字典会保留插入顺序。当你需要遍历字典时，这非常有用：\n示例代码\npizza['name'] = 'Margherita'\n现在键 name 的值是 ‘Margherita’：\n示例代码\nprint(pizza['name']) # 'Margherita'\n字典还有一些有用的方法来执行常见操作。\n.get() 方法检索与键关联的值。它与我们刚才使用的方括号表示法类似，但它的优势是你可设置一个默认值，因此如果键不存在，你不会收到错误：\n示例代码\ndictionary.get(key, default)\n在这个例子中，如果 toppings 键不存在，它将返回一个空列表，这是我们作为第二个参数传递的默认值。但如果 toppings 存在，它将返回该值：\n示例代码\npizza.get('toppings', []) # ['mozzarella', 'basil']\n.keys() 和 .values() 方法分别返回一个视图对象（view object），其中包含字典中的所有键和所有值：\n示例代码\npizza.keys()\n# dict_keys(['name', 'price', 'calories_per_slice'])\n\npizza.values()\n# dict_values(['Margherita Pizza', 8.9, 250])\n视图对象只是查看字典内容的一种方式，而不会创建数据的单独副本。\n.items() 方法返回一个视图对象，其中包含字典中的所有键值对，包括键和值：\n示例代码\npizza.items()\n# dict_items()\n.clear() 方法从字典中移除所有键值对：\n示例代码\npizza.clear()\n.pop() 方法移除具有你指定为第一个参数的键的键值对，并返回其值。如果键不存在，它返回你指定为第二个参数的默认值。如果键不存在且你没有传递默认值，将引发 KeyError：\n示例代码\npizza.pop('price', 10)\npizza.pop('total_price') # KeyError\n在 Python 3.7 及更高版本中，.popitem() 方法移除最后插入的键值对：\n示例代码\npizza.popitem()\n最后，.update() 方法用另一个字典的键值对更新当前的键值对。如果它们有共同的键，它们的值将被覆盖。\n在这个例子中，我们正在更新 pizza 字典。price 键在两个字典中都存在，所以它的值将被替换为 15。\n但 total_time 是新的，所以它将作为新的键值对添加到 pizza 字典中：\n示例代码\npizza.update({ 'price': 15, 'total_time': 25 })\n这是具有更新后的价格和新的 total_time 的新字典。请注意，price 现在是 15，而 total_time 是一个新的键值对：\n示例代码\n{\n    'name': 'Margherita Pizza', \n    'price': 15, \n    'calories_per_slice': 250, \n    'toppings': ['mozzarella', 'basil'], \n    'total_time': 25\n}\n这些是一些最常用的字典方法，但还有很多其他方法。选择合适的方法对于高效地执行复杂操作非常有帮助。\n\n\n4.1.2 What Are Some Common Techniques to Loop Over a Dictionary?\n如果你需要访问和处理字典的键值对，你可以对字典进行循环。这对于更新它们的值或应用某些逻辑非常有用。\n让我们看看你可以使用的一些技术。\n假设我们有一个 products 字典，它将每个产品与其价格关联起来：\n示例代码\nproducts = {\n    'Laptop': 990,\n    'Smartphone': 600,\n    'Tablet': 250,\n    'Headphones': 70,\n}\n如果我们想为所有产品提供 20% 的折扣，我们可以循环遍历所有键值对并修改价格。\n.values()、.keys() 和 .items() 方法对于这些技术至关重要。我们在上一课中简要地介绍过它们。\n它们返回一个视图对象，包含字典的值、键和键值对。你可以在 for 循环中使用这些视图对象来迭代元素。\n例如，你可以像这样迭代字典的所有值。\n你写 for，循环变量（在本例中为 price），products.values() 以获取 products 字典的所有值，一个冒号，然后是循环体，在那里你可以对值应用任何逻辑。在本例中，我们正在打印它们。\n循环变量将获取每一个值，每次迭代一个：\n示例代码\nfor price in products.values():\n    print(price)\n这是输出。如你所见，每个值都被打印到控制台，一次一个：\n示例代码\n990\n600\n250\n70\n如果你需要迭代字典的键，这与 .keys() 的工作方式完全相同。你只需要迭代 products.keys() 或直接迭代 products，并为循环变量分配一个描述性的名称：\n示例代码\nfor product in products.keys():\n    print(product)\n\n# 或者\n\nfor product in products:\n    print(product)\n这是输出。每个键都被打印到控制台，一次一个：\n示例代码\nLaptop\nSmartphone\nTablet\nHeadphones\n如果你需要同时迭代键及其对应的值，这与键值对的工作方式完全相同。你只需要迭代 products.items()：\n示例代码\nfor product in products.items():\n    print(product)\n这是输出。现在你得到单独的元组，包含键及其对应的值：\n示例代码\n('Laptop', 990)\n('Smartphone', 600)\n('Tablet', 250)\n('Headphones', 70)\n如果你想将键和值存储在单独的循环变量中，你只需要定义它们并用逗号分隔。然后，你可以在循环体中使用它们。\n在这里，我们定义了一个 product 循环变量和一个 price 循环变量。每一个都将持有其对应的值。按顺序定义它们很重要——首先是键，然后是值：\n示例代码\nfor product, price in products.items():\n    print(product, price)\n这是输出。我们将它们并排打印，但你可以在代码中根据需要使用这些值。\n示例代码\nLaptop 990\nSmartphone 600\nTablet 250\nHeadphones 70\n既然你对这个了解得更多了，我们可以回到我们最初的例子。如果我们想提供 20% 的折扣，我们将每个价格乘以 0.8 并将其重新赋值为该产品键的值。\n如果我们想使用整数，也可以将结果向下取整：\n示例代码\nproducts = {\n    'Laptop': 990,\n    'Smartphone': 600,\n    'Tablet': 250,\n    'Headphones': 70,\n}\n\nfor product, price in products.items():\n    products[product] = round(price * 0.8)\n\nprint(products)\n然后，如果我们打印字典，我们将得到这些具有折扣价格的键值对：\n示例代码\n{\n    'Laptop': 792, \n    'Smartphone': 480, \n    'Tablet': 200, \n    'Headphones': 56\n}\n最后，如果你需要在迭代键值对的同时跟踪一个计数器，你可以调用 enumerate() 函数。这个计数器本质上充当该元素在循环中的“索引”或“计数”。\n该函数返回一个枚举对象，它为每个键值对分配一个整数，就像一个计数器。你可以从任何数字开始计数，但默认情况下，它从 0 开始。\n在这里，我们正在迭代 products 字典的键：\n示例代码\nfor product in enumerate(products):\n    print(product)\n但 enumerate() 函数也为每个键分配一个整数，所以我们得到包含整数和键的元组。\n这是输出：\n示例代码\n(0, 'Laptop')\n(1, 'Smartphone')\n(2, 'Tablet')\n(3, 'Headphones')\n如果需要，你可以将这些值赋值给单独的循环变量。在这里，我们有两个循环变量（index 和 product）。这是你在处理 enumerate() 时经常会看到和使用的：\n示例代码\nfor index, product in enumerate(products):\n    print(index, product)\n如果你需要迭代值，你可以将 products 替换为 products.values()：\n示例代码\nfor price in enumerate(products.values()):\n    print(price)\n输出将有索引和价格在每个元组中：\n示例代码\n(0, 990)\n(1, 600)\n(2, 250)\n(3, 70)\n你也可以将它们赋值给单独的循环变量：\n示例代码\nfor index, price in enumerate(products.values()):\n    print(index, price)\n这将是输出。你可以在代码中根据需要使用它们：\n示例代码\n0 990\n1 600\n2 250\n3 70\n对于 products.items()，你还可以在“索引”或“计数器”的基础上获取整个键值对：\n示例代码\nfor index, product in enumerate(products.items()):\n    print(index, product)\n在这个例子中，我们得到索引，后面跟着一个包含对应键值对的键和值的元组：\n示例代码\n0 ('Laptop', 990)\n1 ('Smartphone', 600)\n2 ('Tablet', 250)\n3 ('Headphones', 70)\n要自定义计数的初始值，你可以向 enumerate() 传递第二个参数。例如，这里我们从 1 开始计数：\n示例代码\nfor index, product in enumerate(products.items(), 1):\n    print(index, product)\n你可以在输出中看到这个变化。现在第一个整数是 1 而不是 0：\n示例代码\n1 ('Laptop', 990)\n2 ('Smartphone', 600)\n3 ('Tablet', 250)\n4 ('Headphones', 70)\n这适用于我们到目前为止看到的任何变体。你只需要将初始数字作为第二个参数传递。\n循环字典有很多技术。这些是一些常见的方法，你需要为你的项目选择最好的一个。\n\n\n4.1.3 What Are Sets, and How Do They Work?\n集合（Sets）是 Python 内置的数据结构之一。集合的核心特性之一是它不存储重复的值。如果你试图向集合中添加一个重复的值，只有其中一个会被存储。\n集合是可变的且无序的，这意味着它们的元素不以任何特定的顺序存储，因此你不能使用索引或键来访问它们。它们只能包含不可变数据类型的值，比如数字、字符串和元组。并且它们支持数学上的集合运算，包括并集、交集、差集和对称差集。\n要定义一个集合，你只需要将其元素写在花括号内并用逗号分隔。这是一个数字集合的例子：\n示例代码\nmy_set = {1, 2, 3, 4, 5}\n使用集合的一个小陷阱是，如果你需要定义一个空集合，必须使用 set() 函数。如果你只写空的花括号 {}，Python 会自动创建一个字典。\n示例代码\nset() # 集合\n{}    # 字典\n你可以使用 .add() 方法向集合中添加一个元素，并将新元素作为参数传递：\n示例代码\nmy_set.add(6)\n在我们的例子中，新的集合将是：\n示例代码\n{1, 2, 3, 4, 5, 6}\n如果你试图添加一个已经存在于集合中的元素，只有其中一个会被保留。在本例中，集合中已经包含数字 5：\n示例代码\nmy_set.add(5)\n因此集合不会改变：\n示例代码\n{1, 2, 3, 4, 5, 6}\n要从集合中移除一个元素，你有两个选项。你可以使用 .remove() 方法或 .discard() 方法，并将你想要移除的元素作为参数传递。\n如果元素未找到，.remove() 方法会引发 KeyError，而 .discard() 方法则不会：\n示例代码\nmy_set.remove(4)\nmy_set.discard(4)\n.clear() 方法会移除集合中的所有元素：\n示例代码\nmy_set.clear()\nPython 集合还有一些强大的方法，用于执行常见的数学集合运算。\n.issubset() 和 .issuperset() 方法分别检查一个集合是否是另一个集合的子集或超集。\n在这里，我们检查 your_set 是否是 my_set 的子集，结果是 False，因为 your_set 的所有元素并非都在 my_set 中。\n我们还检查了 my_set 是否是 your_set 的超集。这也是 False，因为 my_set 没有 your_set 的所有元素：\n示例代码\nmy_set = {1, 2, 3, 4, 5}\nyour_set = {2, 3, 4, 6}\n\nprint(your_set.issubset(my_set)) # False\nprint(my_set.issuperset(your_set)) # False\n.isdisjoint() 方法检查两个集合是否不相交，这意味着它们没有任何共同的元素。在本例中，结果是 False，因为 my_set 和 your_set 确实有共同的元素——2、3 和 4：\n示例代码\nprint(my_set.isdisjoint(your_set)) # False\n并集运算符 | 返回一个包含两个集合所有元素的新集合：\n示例代码\nmy_set | your_set # {1, 2, 3, 4, 5, 6}\n交集运算符 & 返回一个只包含集合共有元素的新集合：\n示例代码\nmy_set & your_set # {2, 3, 4}\n差集运算符 - 返回一个包含第一个集合中有但其他集合中没有的元素的新集合。在本例中，数字 1 和 5 在 my_set 中但不在 your_set 中：\n示例代码\nmy_set - your_set # {1, 5}\n对称差集运算符 ^ 返回一个包含仅在第一个或第二个集合中的元素（但不同时在两个集合中）的新集合。在本例中，1 和 5 在 my_set 中但不在 your_set 中，所以它们被包含在内。而数字 6 在 your_set 中但不在 my_set 中，所以它也被包含在内：\n示例代码\nmy_set ^ your_set # {1, 5, 6}\n这些运算符中的每一个都有其对应的复合赋值运算符，即在其后添加等号。这些运算符会自动将结果集合赋值给表达式中的第一个集合：\n示例代码\n|= &= -= ^=\n例如，-= 运算符找到集合的差集，并用该结果更新第一个集合：\n示例代码\nmy_set -= your_set\n在此之后，my_set 将被更新为 {1, 5}：\n示例代码\nprint(my_set) # {1, 5}\n你可以使用 in 运算符检查一个元素是否在集合中。在这里，我们检查 5 是否在 my_set 中。结果将是一个布尔值 True 或 False：\n示例代码\nprint(5 in my_set)\n这就是集合的基础知识。当你不需要以任何特定顺序存储值，并且只需要存储唯一值时，集合非常有用。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>字典和集合</span>"
    ]
  },
  {
    "objectID": "cp_3.html#working-with-modules",
    "href": "cp_3.html#working-with-modules",
    "title": "4  3 字典和集合",
    "section": "4.2 Working with Modules",
    "text": "4.2 Working with Modules\n\n4.2.1 What Isthe Python Standard Library, and How Do You Import a Module?\n在软件开发中，库（Library）就像是开发者的工具箱。\n你不必从头开始实现代码的每一个部分，库为你提供了预先编写好且可重用的代码，比如函数、类和数据结构，你可以在项目中直接使用它们。\nPython 拥有一个功能丰富的标准库，其中包含了许多不同的内置模块。它们都是标准化的、经过充分验证的解决方案，旨在解决程序员日常面临的许多问题和任务，例如：\n\n与操作系统交互。\n处理文件。\n网络编程。\n处理日期和时间。\n执行数学运算。\n使用正则表达式。\n测试和调试代码。\n以及更多功能！\n\n一些流行的内置模块示例包括 math、random、re（代表“正则表达式”）和 datetime。\n\nmath 模块包含有助于执行更复杂数学运算的函数。\nrandom 模块有助于生成随机数。\nre 模块用于处理正则表达式。\ndatetime 模块有助于在 Python 中处理日期和时间。\n\n但是，你如何访问这些内置模块中定义的变量、常量、函数和类呢？\n你需要使用导入语句（import statement）。这些语句允许你将模块导入到你的 Python 脚本中。导入语句通常写在文件的顶部。此外，你可以根据需要对其进行自定义。首先，你使用 import 语句，后跟模块的名称：\n示例代码\nimport module_name\n假设你想导入 math 模块。在这种情况下，你会在文件顶部写入：\n示例代码\nimport math\n然后，如果你需要在 Python 脚本中调用该模块的方法，你会使用点号表示法（dot notation），即模块的名称后跟方法的名称：\n示例代码\nmodule_name.method_name()\n例如，为了获取 36 的平方根，你会写 math 后跟一个点，然后是 sqrt（平方根的缩写），并在括号内传递任何必要的参数。在本例中，我们只需要传递我们想要开平方根的数字：\n示例代码\nmath.sqrt(36)\n这是导入语句最基本的形式，但还有其他替代方案。\n如果你需要以不同的名称（也称为“别名”）导入模块，可以使用这种语法，在 import 语句末尾使用 as 后跟别名：\n示例代码\nimport module_name as module_alias\n这通常用于缩短长模块名称，或避免命名冲突。\n例如，为了让 math 模块在你的代码中被称为 m，你可以为其分配一个别名，像这样：\n示例代码\nimport math as m\n然后，你可以使用别名访问模块的元素：\n示例代码\nm.sqrt(36)\n但有时你不需要从模块中导入所有内容。也许你只需要一两个特定的函数或类。在这种情况下，Python 提供了你正好需要的功能。\n现在导入语句以 from 开头，后跟模块的名称，然后是 import 关键字，后跟你想要导入的元素的名称：\n示例代码\nfrom module_name import name1, name2\n然后，你可以在 Python 脚本中直接使用这些名称，而无需模块前缀。\n如果你想为这些名称分配别名，可以通过在每个名称后使用 as 关键字，后跟你想要使用的别名来实现：\n示例代码\nfrom module_name import name1 as alias1, name2 as alias2\n假设你只想从 math 模块中导入 radians、sin 和 cos 函数。你会写：\n示例代码\nfrom math import radians, sin, cos\n现在你可以在代码中直接调用这些函数，而无需 math 模块作为前缀。\n这里有一个更详细的例子：\n为了找到最初以度数表示的特定角度的正弦和余弦值，我们可以调用 radians 函数将其转换为弧度，然后调用正弦和余弦函数，传递以弧度表示的角度：\n示例代码\nfrom math import radians, sin, cos\n\nangle_degrees = 40\nangle_radians = radians(angle_degrees)\n\nsine_value = sin(angle_radians)\ncos_value = cos(angle_radians)\n\nprint(sine_value) # 0.6427876096865393\nprint(cos_value)  # 0.766044443118978\n请注意，我们是如何直接调用函数的，而无需模块名称作为前缀。这是因为我们使用了这种替代语法导入了函数。\n这很有用，但如果在 Python 脚本本身中已经定义了同名的函数或变量，它可能会导致命名冲突。因此，这是在选择想要使用的导入语句类型时需要记住的一点。\n最后，我们看到这种以星号（*）结尾的导入语句。星号告诉 Python 你想要导入该模块中的所有内容，但你希望导入它们，以便你不需要使用模块名称作为前缀：\n示例代码\nfrom module_name import *\n例如，如果你在导入 math 模块时这样做，你将能够调用该模块中定义的任何函数，而无需指定模块名称作为前缀。以下是一些例子：\n示例代码\nfrom math import *\nprint(sqrt(36))  # 6.0\nprint(pow(5, 2)) # 25.0\nprint(exp(1))    # 2.718281828459045\n然而，这通常不被鼓励，因为它可能导致命名空间冲突，并使你更难知道某些名称来自哪里。\n导入语句对于模块中定义的函数、类、常量、变量以及任何其他元素的工作方式完全相同。\n这是一个来自 math 模块的常量示例，圆周率 π：\n示例代码\nimport math\nprint(math.pi)\n这是一个来自 datetime 模块的类的示例。我们创建一个代表 1959 年 7 月 15 日的日期对象。然后，我们将该日期对象赋值给一个变量，并使用点号表示法单独访问日、月和年：\n示例代码\nimport datetime\nbirthday = datetime.date(1959, 7, 15)\nprint(birthday.day)    # 15\nprint(birthday.month)  # 7\nprint(birthday.year)   # 1959\n你可以在该模块的官方 Python 文档中找到有关模块内容的更多信息。\n很好。既然你对模块有了更多了解，你也应该知道 Python 脚本中这个非常重要的习语（idiom），因为它们关系非常密切：\n示例代码\nif __name__ == '__main__': \n    # 代码\n__name__ 是 Python 中一个特殊的内置变量。\n当一个 Python 文件被直接执行时，Python 会将此变量的值设置为字符串 \"__main__\"。\n但是，如果该 Python 文件作为模块被导入到另一个 Python 脚本中，__name__ 变量的值会被设置为该模块的名称（通常是不带 .py 扩展名的文件名）。\n这就是为什么你经常会在 Python 脚本中找到这个条件语句的原因。它包含你只想在 Python 脚本作为主程序运行时执行的代码：\n示例代码\nif __name__ == '__main__': \n    # 代码\n但如果脚本作为模块被导入，该代码块内的代码不会运行。\n这很有用，因为它允许 Python 脚本具有双重用途。它们可以直接运行以执行其主要逻辑，或者它们可以被导入到另一个模块中而不执行其主要逻辑。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>字典和集合</span>"
    ]
  },
  {
    "objectID": "cp_4.html",
    "href": "cp_4.html",
    "title": "5  异常处理",
    "section": "",
    "text": "5.1 理解错误处理（Error Handling）",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>异常处理</span>"
    ]
  },
  {
    "objectID": "cp_4.html#understanding-error-handling",
    "href": "cp_4.html#understanding-error-handling",
    "title": "5  异常处理",
    "section": "",
    "text": "5.1.1 What Are Some Common Error Messages in Python?\n在编写 Python 代码时，经常会遇到错误。理解这些错误是快速高效调试代码的关键。只要你懂得如何阅读这些信息，它们会准确地告诉你哪里出了问题以及问题的原因。\n常见的 Python 错误包括 SyntaxError（语法错误）、NameError（名称错误）、TypeError（类型错误）、IndexError（索引错误）和 AttributeError（属性错误）。当 Python 无法理解你的代码，或者你的逻辑与正在处理的数据不匹配时，就会发生这些错误。\n以下是 SyntaxError 的示例：\n示例代码\nprint(\"Hello, world!\"\n# SyntaxError: unexpected EOF while parsing\n这一行代码缺少一个右括号。由于代码不符合正确的语法规则，Python 抛出了一个 SyntaxError。\n以下是 NameError 的示例：\n示例代码\nprint(name)\n# NameError: name 'name' is not defined\n你试图打印一个尚未定义的变量。当 Python 找不到该名称的变量时，会抛出 NameError。\n以下是 TypeError 的示例：\n示例代码\n5 + \"5\"\n# TypeError: unsupported operand type(s) for +: 'int' and 'str'\n你不能将一个整数和一个字符串相加。当你尝试对不兼容的数据类型执行操作时，Python 会抛出 TypeError。\n以下是 IndexError 的示例：\n示例代码\nmy_list = [1, 2, 3]\nprint(my_list[5])\n# IndexError: list index out of range\n你试图访问列表中不存在的索引。当你超出列表范围时，Python 会抛出 IndexError。\n以下是 AttributeError 的示例：\n示例代码\nnum = 42\nnum.append(5)\n# AttributeError: 'int' object has no attribute 'append'\n整数（int）对象没有 append() 方法。当你尝试使用该数据类型不存在的方法或属性时，Python 会抛出 AttributeError。\n识别常见的 Python 错误信息有助于你更快地解决问题。不要盲目猜测，仔细阅读错误信息，它通常会准确地告诉你哪里出了问题以及该去哪里查找。\n\n\n5.1.2 What Are Some Good DebuggingTechniques in Python?\n调试是每个 Python 开发者必备的核心技能。掌握基础的调试技术可以帮助你高效地识别并解决问题。\n调试是指识别并解决代码中的错误或缺陷（bugs）的过程。它涉及检查代码、理解程序执行流程，并使用工具来精确定位问题的根源。\n在本节课中，我们将介绍在下一个 Python 项目中可以使用的常见调试技术。\n\n5.1.2.1 使用 print 函数和 f-string\n首先，可以在代码的各个位置使用 print() 函数和 f-string 来帮助你理解变量的流程和状态。例如：\n示例代码\ndef add(a, b):\n    result = a + b\n    print(f'Adding {a} and {b} gives {result}')\n    return result\n通过打印 a、b 和 result 的值，你可以验证函数的行为是否符合预期。\n\n\n5.1.2.2 使用 pdb 模块进行交互式调试\n其次，你可以利用 Python 内置的 pdb 模块进行交互式调试：\n示例代码\nimport pdb\n\ndef divide(a, b):\n    pdb.set_trace()\n    return a / b\n\nprint(divide(10, 2))\n通过使用 .set_trace() 方法设置断点，你可以逐行执行代码、检查变量并理解程序的行为。\n如果你运行上面的代码，你会看到一些输出，显示你正在运行的文件位置、调用 .set_trace() 方法的行以及紧随其后的代码，还有一个交互式的 pdb 提示符：\n示例代码\n&gt; /Users/fcc/Desktop/debugging.py(5)divide()\n-&gt; return a / b\n(Pdb)\n如果你在提示符中输入 help，你会看到可以使用的一系列命令列表：\n示例代码\n(Pdb) help\n\nDocumented commands (type help &lt;topic&gt;):\n========================================\nEOF    c          d        h         list      q        rv       undisplay\na      cl         debug    help      ll        quit     s        unt      \nalias  clear      disable  ignore    longlist  r        source   until    \nargs   commands   display  interact  n         restart  step     up       \nb      condition  down     j         next      return   tbreak   w        \nbreak  cont       enable   jump      p         retval   unalias  whatis   \nbt     continue   exit     l         pp        run      u        where    \n\nMiscellaneous help topics:\n==========================\nexec  pdb\n然后你可以使用这些命令来调试你的代码。\n例如，如果你想查看当时代码中各个元素的类型，可以使用 whatis 命令：\n示例代码\n(Pdb) whatis a\n&lt;class 'int'&gt;\n(Pdb) whatis divide\nFunction divide\n正如你所见，当你运行 .set_trace() 时，参数 a 的类型是整数，而 divide 是一个函数。\n然后，要继续执行你的代码，可以使用 continue 命令，或者它的别名之一 cont 或 c：\n示例代码\n(Pdb) continue\n5.0\n\n\n5.1.2.3 使用 IDE 调试工具\n许多集成开发环境（IDE）都提供了高级的调试工具，例如断点、单步执行和变量检查。\n\n\n5.1.2.4 使用 VS Code 调试器\n如果你使用 VS Code，你可以在代码中设置断点，并运行调试器在这些点暂停执行。以下是调试同一个 divide 函数的步骤：\n步骤 1：设置你的代码\n创建一个名为 main.py 的文件，内容如下：\n示例代码\ndef divide(a, b):\n    result = a / b\n    return result\n\nprint(divide(10, 2))\nprint(divide(15, 3))\n步骤 2：设置断点\n点击行号左侧的空白区域（装订线）在第 2 行 (result = a / b) 旁边设置断点。\n会出现一个红点，表示断点已设置。\n步骤 3：开始调试\n按 F5 键，或者点击菜单栏的 运行 (Run) &gt; 开始调试 (Start Debugging)。\n出现提示时，选择 “Python File”。\n调试器将在你的断点处暂停执行。\n步骤 4：检查变量\n将鼠标悬停在变量上以查看其当前值。\n使用左侧的“变量”面板查看所有局部变量。\n使用底部的“调试控制台”来评估表达式。\n步骤 5：单步执行代码\n使用调试工具栏来：\n\n继续 (F5)：继续执行，直到下一个断点。\n单步跳过 (F10)：执行当前行并移动到下一行。\n单步进入 (F11)：进入函数调用内部。\n单步跳出 (Shift+F11)：跳出当前函数。\n\nIDE 调试工具提供了一个可视化的界面来检查程序的状态，相比于仅使用 print 语句，这使得识别和解决问题变得更加容易。\n通过掌握这些基础的调试技术——使用 print() 语句、pdb 模块和 IDE 工具——你可以有效地识别并解决 Python 代码中的问题。每种技术都有其适用的场景：print() 语句用于快速检查，pdb 用于交互式探索，而 IDE 调试器则用于可视化检查。\n\n\n\n5.1.3 How Does Exception Handling Work?\n在 Python 中，异常处理是编写健壮且容错程序的核心部分。它允许你以结构化的方式预见、捕获并响应错误。\n异常处理是指捕获和管理程序执行期间发生的错误的过程，这样你的代码就不会意外崩溃。\nPython 提供了 try、except、else 和 finally 代码块来优雅地处理错误。这是一个基本的例子：\n示例代码\ntry:\n    x = 10 / 0\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\n\ntry: 你预见到可能会发生错误的代码块。\nexcept: 如果在 try 块内引发了指定类型的错误，该代码块就会执行。\n\n在这种情况下，除以零会引发 ZeroDivisionError，然后该错误被捕获并处理。\n这里还有一个例子，展示了如何使用 else 和 finally 块：\n示例代码\ntry:\n    x = 10 / 2\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\nelse:\n    print('Division successful:', x)\nfinally:\n    print('This block always runs.')\n\nelse: 如果 try 块中没有引发任何异常，则执行该代码块。\nfinally: 无论是否发生异常，该代码块都会运行。这对于清理任务（如关闭文件或释放资源）非常有用。\n\n你还可以使用单独的 except 块来捕获多种异常：\n示例代码\ntry:\n    number = int('abc')\n    result = 10 / number\nexcept ValueError:\n    print('That was not a valid number.')\nexcept ZeroDivisionError:\n    print(\"Can't divide by zero.\")\n通过使用单独的 except 子句，你可以使你的错误响应更加具体和有用。\n你还可以使用异常对象，通常使用 as 关键字为其指定一个别名。在这里，我们使用 e 作为错误对象的别名：\n示例代码\ntry:\n    x = 1 / 0\nexcept ZeroDivisionError as e:\n    print(f'Error occurred: {e}')\n使用 e 可以让你访问实际的错误消息或对象，以便进行日志记录或调试。\n你也可以在单个 except 子句中捕获多种异常，方法是将异常指定为一个元组：\n示例代码\ntry:\n    number = int(input('Enter a number: '))\n    result = 10 / number\nexcept (ValueError, ZeroDivisionError) as e:\n    print(f'Error occurred: {e}')\n异常处理允许你的程序从错误中优雅地恢复。通过使用 try、except、else 和 finally，你可以预见潜在的问题，并构建更具弹性的应用程序。\n\n\n5.1.4 What Is the Raise Statement and How Does It Work?\n在 Python 中，raise 语句是一个强大的工具，它允许你在代码中手动触发异常。它让你能够控制何时以及如何生成错误，从而创建自定义的错误条件并强制执行特定的程序行为。\nraise 语句用于在程序的任何位置显式地抛出（throw）一个异常，让你能够发出信号，表明发生了错误条件或者某些要求未得到满足。\nPython 的 raise 语句有几种用法来触发异常。最基本的是，你可以触发内置异常或创建自定义错误消息。这是一个简单的例子：\n示例代码\ndef check_age(age):\n    if age &lt; 0:\n        raise ValueError('Age cannot be negative')\n    return age\n\ntry:\n    check_age(-5)\nexcept ValueError as e:\n    print(f'Error: {e}') # Error: Age cannot be negative\n你可以看到这里的 raise 是触发异常的关键字。\n在这个例子中，当提供了无效的年龄时，我们触发了一个带有自定义消息的 ValueError。\nraise 语句也可以用来重新触发（re-raise）当前的异常，这在异常处理中特别有用：\n示例代码\ndef process_data(data):\n    try:\n        result = int(data)\n        return result * 2\n    except ValueError:\n        print('Logging: Invalid data received')\n        raise  # Re-raises the same ValueError\n\ntry:\n    process_data('abc')\nexcept ValueError:\n    print('Handled at higher level')\n这里的 raise 关键字（不带参数）会重新触发当前正在处理的异常。\n这允许你在仍然将错误向调用栈上游传播的同时，进行日志记录或执行清理操作。\n你可以通过定义自己的异常类来创建并触发自定义异常：\n示例代码\nclass InsufficientFundsError(Exception):\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        super().__init__(f'Insufficient funds: ${balance} available, ${amount} requested')\n\ndef withdraw(balance, amount):\n    if amount &gt; balance:\n        raise InsufficientFundsError(balance, amount)\n    return balance - amount\n\ntry:\n    new_balance = withdraw(100, 150)\nexcept InsufficientFundsError as e:\n    print(f'Transaction failed: {e}')\n你可以看到自定义的异常类继承自 Exception 或其子类。\n你将在未来的课程中学习更多关于类和继承的知识。目前，你只需要知道这是一种通过自定义逻辑创建自己异常的方法。\nraise 语句还可以与 from 关键字一起使用来链接异常，显示不同错误之间的关系：\n示例代码\ndef parse_config(filename):\n    try:\n        with open(filename, 'r') as file:\n            data = file.read()\n            return int(data)\n    except FileNotFoundError:\n        raise ValueError('Configuration file is missing') from None\n    except ValueError as e:\n        raise ValueError('Invalid configuration format') from e\n\nconfig = parse_config('config.txt')\n在这里你可以看到 raise ... from None 抑制了原始异常的上下文：\n示例代码\nTraceback (most recent call last):\n  File \"main.py\", line 12, in &lt;module&gt;\n    config = parse_config('config.txt')\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"main.py\", line 7, in parse_config\n    raise ValueError('Configuration file is missing') from None\nValueError: Configuration file is missing\n而 raise ... from e 将新异常链接到原始异常，保留了错误轨迹。\n示例代码\nTraceback (most recent call last):\n  File \"main.py\", line 5, in parse_config\n    return int(data)\n           ^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"main.py\", line 12, in &lt;module&gt;\n    config = parse_config('config.txt')\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"main.py\", line 9, in parse_config\n    raise ValueError('Invalid configuration format') from e\nValueError: Invalid configuration format\n你也可以使用 assert 语句有条件地触发异常，这本质上是 raise 与 AssertionError 的简写形式：\n示例代码\ndef calculate_square_root(number):\n    assert number &gt;= 0, 'Cannot calculate square root of negative number'\n    return number ** 0.5\n\ntry:\n    result = calculate_square_root(-4)\nexcept AssertionError as e:\n    print(f'Assertion failed: {e}')\nraise 语句对于创建健壮的应用程序至关重要，在这些应用程序中，你需要强制执行业务规则、验证输入并提供有意义的错误消息。通过战略性地使用 raise，你可以使你的代码更具可预测性且更易于调试，同时为用户提供关于哪里出错的清晰反馈。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>异常处理</span>"
    ]
  },
  {
    "objectID": "cp_5.html",
    "href": "cp_5.html",
    "title": "6  类和对象",
    "section": "",
    "text": "6.1 类和对象",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>类和对象</span>"
    ]
  },
  {
    "objectID": "cp_5.html#classes-and-objects",
    "href": "cp_5.html#classes-and-objects",
    "title": "6  类和对象",
    "section": "",
    "text": "6.1.1 How Do Classes Work and How Do They Differ From Objects?\n在 Python 中，类（Class）和对象（Object）协同工作来组织和管理数据。你构建一个类来定义共享的行为，然后创建使用这些行为的对象。\n换句话说，一个类就像是你用来创建对象的蓝图或模板。\n让我们看看什么是类，以及如何使用它们来创建对象。\n要创建一个类，你使用 class 关键字，后跟类的名称和一个冒号。然后在类内部，你可以添加一个初始化器（initializer），以及任何属性（attribute）和方法（method）。\n属性就像是类内部的变量，用于存储数据。方法是在类内部定义的函数，是使用该类创建的对象可以执行的操作。\n这里是类的基本语法：\n示例代码\nclass ClassName:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sample_method(self):               \n        print(self.name.upper())\n\nclass ClassName 由用于创建类的 class 关键字组成，后跟类的名称，在这里称为 ClassName。在 Python 中，命名类时通常使用大驼峰命名法（PascalCase）。\ndef __init__(self, name, age) 是一个特殊的方法，在创建新对象时自动调用。它初始化将使用该类创建的对象的属性。\n除此之外，__init__ 的第一个参数始终是对正在创建或使用的特定对象的引用。按照惯例，这个参数被命名为 self，但技术上，你可以使用任何名称。self 让你能够访问对象自己的属性和方法。\nself.name = name 和 self.age = age 是对象将拥有的属性。\ndef sample_method(self): 是每个创建的对象都可以调用的方法。\nprint(self.name.upper()) 是 sample_method 方法将要做的事情，在本例中，它打印大写的名称。\n\n如果这一切听起来很多，请不要担心。让我们看一个类似的 Dog 类的例子，以及如何从中创建对象：\n示例代码\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def bark(self):\n        print(f\"{self.name.upper()} says woof woof!\")\n使用这个 Dog 类，你可以创建一个对象。这里是使用类创建对象的基本语法：\n示例代码\nobject_1 = ClassName(attribute_1, attribute_2)\nobject_2 = ClassName(attribute_1, attribute_2)\n你也可以从每个对象调用在类中定义的任何方法：\n示例代码\nobject_1.method_name()\nobject_2.method_name()\n现在让我们使用 Dog 类作为蓝图来创建两只狗：\n示例代码\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def bark(self):\n        print(f\"{self.name.upper()} says woof woof! I'm {self.age} years old!\")\n\ndog_1 = Dog(\"Jack\", 3)\ndog_2 = Dog(\"Thatcher\", 5)\n\n# Call the bark method\ndog_1.bark()  # JACK says woof woof! I'm 3 years old!\ndog_2.bark()  # THATCHER says woof woof! I'm 5 years old!\n正如你所见，我们使用 Dog 类创建了两个狗对象。当初始化 dog_1 时，字符串 Jack 和数字 3 被传递，这设置了该实例的名称和年龄属性。而 dog_2 使用字符串 Thatcher 和数字 5 作为其名称和年龄进行初始化。\n然后当你对 dog_1 和 dog_2 调用 .bark() 方法时，你可以看到两个输出是如何不同的，并使用了你在创建每个对象时传递的唯一名称和年龄属性。\n总而言之，类和对象之间的区别在于，类是模板或蓝图，而对象是使用该模板创建的实体。\n此外，类定义了对象应该拥有什么数据和行为，而对象持有实际的数据并使用该行为。你只编写一次类，但你可以从中创建许多对象，每个对象拥有不同的数据。\n\n\n6.1.2 What Are Methods and Attributes, and How Do They Work?\n在上一节课中，你学习了类以及它们如何作为创建对象的蓝图。\n在这里，我们将更深入地探讨属性和方法。\n让我们先仔细看看属性，然后再看方法。\n属性是属于对象的变量，因此它们用于存储数据。属性有两种：实例属性和类属性。\n实例属性对于从类创建的每个对象来说都是唯一的，你通常使用 __init__ 方法来设置它们。而类属性则属于类本身，并且由该类的所有实例共享。\n要访问属性，你使用点号表示法。\n这里是实例属性和类属性的示例，以及如何从对象访问它们：\n示例代码\nclass Dog:\n    species = \"French Bulldog\" # 类属性\n\n    def __init__(self, name):\n        self.name = name # 实例属性\n\nprint(Dog.species) # French Bulldog\n\ndog1 = Dog(\"Jack\")\nprint(dog1.name)    # Jack\nprint(dog1.species) # French Bulldog\n\ndog2 = Dog(\"Tom\")\nprint(dog2.name)    # Tom\nprint(dog2.species) # French Bulldog\n请注意，你可以直接从类本身访问类属性，但在访问实例属性之前，你需要先创建一个对象并为其传递数据。\n汽车是另一个很好的例子，因为所有汽车都有型号和颜色：\n示例代码\nclass Car:\n    def __init__(self, color, model):\n        self.color = color\n        self.model = model\n\ncar_1 = Car(\"red\", \"Toyota Corolla\")\ncar_2 = Car(\"green\", \"Lamborghini Revuelto\")\n\nprint(car_1.model) # Toyota Corolla\nprint(car_2.model) # Lamborghini Revuelto\n\nprint(car_1.color) # red\nprint(car_2.color) # green\n方法是在类内部定义的函数。通过它们，从类定义的任何对象都可以执行操作或修改其自身数据的操作。你也使用点号表示法来访问方法。\n例如，狗可以叫。所以我们可以在 Dog 类中有一个 bark 方法，就像你在上一课中看到的那样：\n示例代码\nclass Dog:\n   species = \"French Bulldog\"\n\n   def __init__(self, name):\n     self.name = name\n\n   def bark(self):\n       return f\"{self.name} says woof woof!\"\n\njack = Dog(\"Jack\")\njill = Dog(\"Jill\")\n\nprint(jack.bark()) # Jack says woof woof!\nprint(jill.bark()) # Jill says woof woof!\nCar 类也可以有一个 describe 方法：\n示例代码\nclass Car:\n    def __init__(self, color, model):\n        self.color = color  # 实例属性\n        self.model = model  # 实例属性\n\n    def describe(self):\n        return f\"This car is a {self.color} {self.model}\"\n\ncar_1 = Car(\"red\", \"Toyota Corolla\")\ncar_2 = Car(\"green\", \"Lamborghini Revuelto\")\n\nprint(car_1.describe()) # This car is a red Toyota Corolla\nprint(car_2.describe()) # This car is a green Lamborghini Revuelto\n\n\n6.1.3 What Are Special Methods and What Are They Used For?\nPython 中的特殊方法，也被称为“魔术方法”或“双下划线方法”（dunder methods），是一些以双下划线（__）开头和结尾的特殊 Python 方法。单词“dunder”本身来源于 double underscores（d 代表 double，under 代表 underscores）。\n你可能已经不知不觉地使用过特殊方法了。每次你编写类似 3 + 4 的代码时，Python 在后台都会悄悄地运行 3.__add__(4)。这就是一个特殊方法在起作用。因此，虽然你可以直接调用特殊方法，但你很少会这样做。相比于直接调用 3.__add__(4)，像 3 + 4 这样的写法显然更清晰、更易读。\n除了 __add__，__init__() 是另一个你最常看到和使用的特殊方法，因为它是类的初始化器。还有其他一些方法，如 __len__() 和 __str__()。\n可以把特殊方法看作是编程人员与 Python 语言解释器本身之间活动的导演。\n请记住，你不需要直接调用特殊方法。相反，当某些操作发生时，Python 会自动调用它们。这些操作包括：\n\n算术运算：如加法、减法、乘法、除法等。进行加法时调用 __add__()，减法调用 __sub__()，乘法调用 __mul__()，除法调用 __truediv__()。\n字符串运算：如拼接、重复、格式化以及转换为文本。拼接调用 __add__()，重复调用 __mul__()，格式化调用 __format__()，文本转换调用 __str__() 和 __repr__() 等。\n比较运算：如相等、小于、大于等。进行相等性检查时调用 __eq__()，小于调用 __lt__()，大于调用 __gt__() 等。\n迭代运算：如使对象可迭代以及遍历项目。调用 __iter__() 返回一个迭代器，调用 __next__() 获取下一项。\n\n通常，Python 的数据类型（如字符串和数字）已经知道如何进行加法、拼接、比较相等性、在循环中使用等操作。\n但是，当你创建自己的类时，Python 将不知道如何自动处理这些操作。\n这就是特殊方法的用武之地——它们让你可以自定义 Python 的内置行为。\n假设你想获取使用下面的类创建的书籍对象的页数，或者比较它们，并获取对象的可读字符串。如果没有特殊方法，会发生什么：\n示例代码\nclass Book:\n   def __init__(self, title, pages):\n       self.title = title\n       self.pages = pages\n\nbook1 = Book(\"Built Wealth Like a Boss\", 420)\nbook2 = Book(\"Be Your Own Start\", 420)\n\nprint(len(book1)) # TypeError: object of type 'Book' has no len()\nprint(str(book1)) # &lt;__main__.Book object at 0x102ed2900&gt;\nprint(book1 == book2) # False even though they have the same number of pages\n在示例中：\n\nlen(book1) 失败了，因为如果没有 __len__()，Python 不知道如何获取你的书籍对象的长度。\nstr(book1) 打印了类似 &lt;__main__.Book object at 0x102ed2900&gt; 的内容，因为这是在没有使用 __str__() 时的默认表示形式。\nbook1 == book2 结果为 False，因为 Python 只是检查两个对象在内存中是否是同一个对象，而不是按内容比较。\n\n以下是你如何定义自己的 __len__()、__str__() 和 __eq__() 特殊方法，以使处理 Book 类创建的对象变得更简单：\n示例代码\nclass Book:\n   def __init__(self, title, pages):\n       self.title = title\n       self.pages = pages\n\n   def __len__(self):\n       return self.pages\n\n   def __str__(self):\n       return f\"'{self.title}' has {self.pages} pages\"\n\n   def __eq__(self, other):\n       return self.pages == other.pages\n  \nbook1 = Book(\"Built Wealth Like a Boss\", 420)\nbook2 = Book(\"Be Your Own Start\", 420)\n\nprint(len(book1)) # 420\nprint(len(book2)) # 420\nprint(str(book1)) # 'Built Wealth Like a Boss' has 420 pages\nprint(str(book2)) # 'Be Your Own Start' has 420 pages\nprint(book1 == book2) # True\n另一个例子是一个购物车，你需要执行以下操作：\n\n将商品添加到购物车\n从购物车中移除商品\n获取购物车中商品的数量\n检查购物车中有哪些商品\n检查特定商品是否在购物车中\n返回或显示购物车中特定索引位置的商品\n\n虽然你可能有一个方法用于将商品添加到购物车，另一个方法用于从购物车中移除特定商品，但你可以为所有其他功能创建特殊方法：\n\n__len__()：获取购物车中商品的数量\n__iter__()：遍历购物车中的商品，以便你可以看到它们\n__contains__()：检查特定商品是否在购物车中\n__getitem__()：返回或显示购物车中特定索引位置的商品\n\n这是一个包含这些用户定义方法和特殊方法的 Cart 类示例：\n示例代码\nclass Cart:\n   def __init__(self):\n       self.items = []\n\n   def add(self, item):\n       self.items.append(item)\n\n   def remove(self, item):\n       if item in self.items:\n           self.items.remove(item)\n       else:\n           print(f'{item} is not in cart')\n\n   def list_items(self):\n       return self.items\n\n   def __len__(self):\n       return len(self.items)\n\n   def __getitem__(self, index):\n       return self.items[index]\n\n   def __contains__(self, item):\n       return item in self.items\n\n   def __iter__(self):\n       return iter(self.items)\n以下是你如何使用它们：\n示例代码\ncart = Cart()\ncart.add('Laptop')\ncart.add('Wireless mouse')\ncart.add('Ergo keyboard')\ncart.add('Monitor')\n\nfor item in cart:\n   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor\n\nprint(len(cart)) # 4\nprint(cart[3]) # Monitor\n\nprint('Monitor' in cart) # True\nprint('banana' in cart) # False\n\ncart.remove('Ergo keyboard')\n\nprint(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']\n\ncart.remove('banana') # banana is not in cart\n这就是在现实世界中使用 Python 特殊方法的几种方式。\n\n\n6.1.4 How to Handle Object Attributes Dynamically?\n在上一节课中，你学习了属性是属于对象的变量。这意味着它们持有描述对象状态或行为的数据。\n例如，一辆汽车通常会有品牌和型号。品牌和型号可以作为 Car 类的属性：\n示例代码\nclass Car: \n    def __init__(self, brand, model): \n        self.brand = brand \n        self.model = model \n\nmy_car = Car('Lamborghini', 'Gallardo') \nprint(my_car.brand) # Lamborghini \nprint(my_car.model) # Gallardo\n但有时，你可能要等到程序运行时才知道需要哪些属性。想象一下，你正在编写一个脚本，从用户或配置文件中接收属性名称。这些属性不是你可以提前硬编码的。\n这就是动态处理属性的用武之地。通过这种方式，你可以使用变量名而不是代码中的固定名称来访问、修改、检查甚至删除属性。这赋予了你的程序灵活性，使其能够即时响应不同的数据或用户输入。\nPython 提供了四个方便的内置函数来动态处理对象属性。它们是 getattr()、setattr()、hasattr() 和 delattr()。\n它们让你可以使用变量名来访问、创建、检查和移除属性。让我们看看它们各自的实际应用。\ngetattr() 使得在你不知道属性名称直到运行时的情况下，仍能从对象中读取属性成为可能。如果属性不存在，它会引发 AttributeError，除非你提供一个默认值。\n要使用它，你需要传入对象、属性名称和一个可选的默认值：\n示例代码\ngetattr(object, attribute_name, default_value)\n这是一个示例：\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30) \n \nprint(getattr(person, 'name')) # John Doe \nprint(getattr(person, 'age')) # 30 \nprint(getattr(person, 'city', 'Milano')) # Milano\n在上面的示例中，Milano 是一个默认值，因为 Person 类中不存在 city。\n正如我们之前所说，getattr() 的真正威力在于属性名称来自变量时，例如来自用户输入或某个文件。\n在这种情况下，你不能使用常规的 object.attribute_name 语法，因为属性名称不是固定的。\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30)\n\nattr_name = input('Enter the attribute you want to see: ')\nprint(getattr(person, attr_name, 'Attribute not found'))\n在这种情况下，如果用户输入 name，他们会看到 John Doe；如果他们输入 age，他们会看到 30。如果他们输入类中不存在的内容（如 email），他们会看到 Attribute not found。\n这正是动态属性处理大放异彩的地方。它让你的代码能够响应它以前从未见过的输入和数据。\n此外，你可能想要查看对象拥有的所有属性，而不仅仅是那些你已经知道的属性。内置的 dir() 函数可以让你做到这一点。它返回对象上所有属性名称的列表。以下是使用方法：\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30)\n\n# 使用 dir() 函数循环遍历 person 对象的所有属性\nfor attr in dir(person):\n    # 忽略像 __init__ 或 __str__ 这样的双下划线方法和普通方法\n    if not attr.startswith('__') and not callable(getattr(person, attr)): \n        value = getattr(person, attr)\n        print(f'{attr}: {value}')\n\n# 输出\n# age: 30\n# name: John Doe\nsetattr() 函数允许你动态地创建新属性或更新现有属性。语法如下：\n示例代码\nsetattr(object, attribute_name, value)\n这是一个根据某些配置或环境变量文件中的数据设置配置属性的示例：\n示例代码\nclass Configuration:\n    pass\n\n# 在运行时加载的数据（如从配置或环境文件）\nsettings_data = {\n    'server_url': 'https://api.example.com',\n    'timeout_sec': 30,\n    'max_retries': 5\n}\n\nconfig_obj = Configuration()\n\n# 使用字典的键和值动态设置属性\nfor attr_name, attr_value in settings_data.items():\n    setattr(config_obj, attr_name, attr_value)\n\nprint(config_obj.server_url) # https://api.example.com\nprint(config_obj.timeout_sec) # 30\n还有一个 hasattr()。在你对属性进行操作或删除它之前，最好先检查它是否存在。这就是 hasattr() 让你做的事情。它检查属性是否存在，并根据结果返回 True 或 False。\n以下是基本语法：\n示例代码\nhasattr(object, attribute_name)\n这是一个动态检查 Product 类实例中属性存在的示例：\n示例代码\nclass Product:\n    def __init__(self, name, price):\n        self.name = name\n        self.price = price\n\nproduct_a = Product('T-Shirt', 25)\n\nrequired_attributes = ['name', 'price', 'inventory_id']\n\nfor attr in required_attributes:\n    if not hasattr(product_a, attr):\n        print(f\"ERROR: Product is missing the required attribute: '{attr}'\")\n    else:\n        # 确认存在后，动态访问属性\n        print(f'{attr}: {getattr(product_a, attr)}')\n\n# 输出:\n# name: T-Shirt\n# price: 25\n# ERROR: Product is missing the required attribute: 'inventory_id'\n出现 ERROR 输出是因为 Product 类及其实例中缺少 inventory_id。\n最后，delattr() 让你可以动态地移除一个属性：\n示例代码\ndelattr(object, attribute_name)\n例如，想象一个对象已经被完全处理，然后你决定在保存最终版本之前清理可能存在的任何敏感或临时属性。之后，你可以使用 dir() 循环遍历剩余的属性：\n示例代码\nclass UserSession:\n    def __init__(self, user_id, token):\n        self.user_id = user_id\n        self.auth_token = token # sensitive\n        self.temp_counter = 0 # temporary\n\nsession = UserSession(101, 'a1b2c3d4e5')\n\n# 在“保存”会话之前要动态移除的属性列表\nattributes_to_clean = ['auth_token', 'temp_counter']\n\n# 动态移除指定的属性\nfor attr in attributes_to_clean:\n    if hasattr(session, attr):\n        delattr(session, attr)\n        print(f'Removed attribute: {attr}')\n\nprint('\\nFinal attributes remaining:')\n\n# 使用 dir() 循环遍历剩余的属性\nfor attr in dir(session):\n    # 忽略像 __init__ 或 __str__ 这样的双下划线方法和普通方法\n    if not attr.startswith('__') and not callable(getattr(session, attr)):\n        print(f' - {attr}: {getattr(session, attr)}')\n\n# 输出:\n# Removed attribute: auth_token\n# Removed attribute: temp_counter\n\n# Final attributes remaining:\n#  - user_id: 101\n这就是如何动态处理属性的方法！",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>类和对象</span>"
    ]
  },
  {
    "objectID": "cp_6.html",
    "href": "cp_6.html",
    "title": "7  面向对象编程（OOP）",
    "section": "",
    "text": "7.1 理解面向对象编程与封装（Encapsulation）",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_6.html#understanding-object-oriented-programming-and-encapsulation",
    "href": "cp_6.html#understanding-object-oriented-programming-and-encapsulation",
    "title": "7  面向对象编程（OOP）",
    "section": "",
    "text": "7.1.1 What is Object-Oriented Programming, and How Does Encapsulation Work?\n面向对象编程（Object-oriented programming），也被称为 OOP，是一种编程风格，在这种风格中，开发者将其代码中的所有事物都视为现实世界中的对象。\n类就像是创建对象的蓝图。从类创建的每个对象都有定义数据的属性和定义对象行为的方法。\n在上一节课中，你学习了如何创建类。以下是语法的复习：\n示例代码\nclass ClassName:\n   def __init__(self, parameters):\n       attribute = value\n\n   def method_name(self):\n       # method logic\n这是一个类的示例，它使用 __init__ 特殊方法在使用该类创建对象时初始化 brand 和 color 属性：\n示例代码\nclass Car:\n   def __init__(self, brand, color):\n       self.brand = brand\n       self.color = color\n\n# 从 Car 类创建两个对象\ncar1 = Car('Toyota', 'red')\ncar2 = Car('Lambo', 'green')\n\nprint('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota\nprint('Car 1 Color:', car1.color) # Car 1 Color: red\n\nprint('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo\nprint('Car 2 Color:', car2.color) # Car 2 Color: green\n面向对象编程有四个关键原则，它们能帮助你有效地组织和管理代码。它们是封装（encapsulation）、继承（inheritance）、多态（polymorphism）和抽象（abstraction）。\n本节课的其余部分将重点关注封装是如何工作的。\n封装是将对象的属性和方法捆绑到一个单一单元（即类）中的过程。\n通过封装，你可以将对象的内部状态隐藏在一组简单的公共方法和属性后面，这些公共方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制着数据如何变化以及谁可以看到它。\n假设你想追踪钱包余额。你想允许人们向钱包中存款或取款，但不应该有人能够直接篡改余额。\n在这种情况下，你可以使 deposit() 和 withdraw() 成为公共方法，并将余额隐藏在 _balance 属性下：\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self._balance = balance # 按照约定，仅供内部使用\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self._balance += amount # 安全地增加余额\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self._balance:\n           self._balance -= amount # 安全地减少余额\n按照约定，以单个下划线为前缀的属性和方法意味着它们仅供内部使用。任何人都不应该直接从类的外部访问它们，因为这违背了封装的原则，可能会导致错误。\n虽然单下划线前缀只是一个约定，但以双下划线为前缀的属性和方法实际上阻止了它们从类的外部被访问，从而使这些属性和方法成为私有的。\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self.__balance = balance # 私有属性\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self.__balance += amount # 安全地增加余额\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self.__balance:\n           self.__balance -= amount # 安全地减少余额\n\naccount = Wallet(500)\nprint(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'\n要获取 __balance 的当前值，你可以定义一个 get_balance 方法。例如：\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self.__balance = balance\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self.__balance += amount\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self.__balance:\n           self.__balance -= amount\n  \n   def get_balance(self):\n       return self.__balance\n\n\nacct_one = Wallet(100)\nacct_one.deposit(50)\nprint(acct_one.get_balance()) # 150\n\nacct_two = Wallet(450)\nacct_two.withdraw(28)\nprint(acct_two.get_balance()) # 422\n\nacct_two.deposit(150)\nprint(acct_two.get_balance()) # 572\n你还可以定义一个私有的 __validate 方法来检查每次存款或取款金额是否为正数：\n示例代码\nclass Wallet:\n   def __init__(self):\n       self.__balance = 0\n\n   def __validate(self, amount):\n       if amount &lt; 0:\n           raise ValueError('Amount must be positive')\n\n   def deposit(self, amount):\n       self.__validate(amount)\n       self.__balance += amount\n\n   def withdraw(self, amount):\n       self.__validate(amount)\n       if amount &gt; self.__balance:\n           raise ValueError('Insufficient funds')\n       self.__balance -= amount\n\n   def get_balance(self):\n       return self.__balance\n\nacct_one = Wallet()\nacct_one.deposit(3)\nprint(acct_one.get_balance()) # 3\n\nacct_one.deposit(50)\nprint(acct_one.get_balance()) # 53\n\nacct_one.deposit(-4)  # ValueError: Amount must be positive\nacct_one.withdraw(-8) # ValueError: Amount must be positive\nacct_one.withdraw(58) # ValueError: Insufficient funds\n正如你所见，__validate 方法是私有的，并在 deposit() 和 withdraw() 公共方法的后台运行，以确保金额始终有效。\n在接下来的课程中，你将学习更多关于以双下划线为前缀的属性是如何工作的。\n总而言之，封装通过清晰的公共方法锁定内部数据。这就是你如何保护你的类免受篡改并将验证集中在一个地方的方法。你可以自由地更新或扩展你的代码，因为你知道外部代码只能接触到你暴露的接口。\n\n\n7.1.2 What are Getters and Setters\nGetter 和 Setter 是让你控制如何访问和修改类属性的方法。通过 Getter 你获取值，通过 Setter 你设置值。\n这些操作是通过所谓的 属性（Properties） 来完成的。属性是连接 Getter 和 Setter 的桥梁，允许对数据进行访问。\n属性看起来像属性，但在后台表现得像方法。可以把它们看作是像方法一样定义的数据，但像属性一样工作。这意味着你可以使用点号表示法（而不是括号或圆括号）来访问属性。\n属性的主要作用是，当你使用它们获取、设置或删除值时，会在后台运行额外的逻辑。这使得它们成为当你想要在对象内访问或操作数据时的绝佳选择。\n那么，为什么要为此使用属性而不是方法呢？这主要是关于可读性和约定的问题。它们使你的代码更简洁、更易读。\n当你使用方法时，你总是必须用括号来调用它。但使用属性时，你可以像访问普通属性一样使用点号表示法来访问它。这使得你的代码看起来很简单，即使它在后台正在做额外的工作。\n例如，你可能想要计算一个值，或者在保存新值之前检查它是否有效。你可以使用属性的方式来做这件事，而不是调用一个方法。\n要创建一个属性，你定义一个方法，并在它上面放置 @property 装饰器。这告诉 Python 将该方法视为一个属性。\n这就引出了 Getter。以下是使用 @property 装饰器创建一个 Getter 的方法：\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self): # 用于获取半径的 Getter\n        return self._radius\n  \n    @property\n    def area(self):  # 用于计算面积的 Getter\n        return 3.14 * (self._radius ** 2)\n\nmy_circle = Circle(3)\n\nprint(my_circle.radius) # 3\nprint(my_circle.area) # 28.26\n这个示例获取了圆的半径和面积。\n请注意我们在类内部如何使用 _radius 而不是 radius。下划线是 Python 中的一个常见约定，表示该属性是私有的。换句话说，它表示该属性仅供内部使用，不应直接从类的外部访问。\n要创建一个 Setter 来设置半径，例如，你必须定义另一个同名的方法，并在它上面使用 @&lt;property_name&gt;.setter：\n在 __init__ 中使用 self.radius 确保在对象创建期间调用 Setter，因此无效的半径值会立即被捕获。\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius # 调用 Setter\n\n    @property\n    def radius(self):  # 用于获取半径的 Getter\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):  # 用于设置半径的 Setter\n        if value &lt;= 0:\n            raise ValueError('Radius must be positive')\n        self._radius = value\n\nmy_circle = Circle(3)\nprint('Initial radius:', my_circle.radius) # Initial radius: 3\n\nmy_circle.radius = 8\nprint('After modifying the radius:', my_circle.radius) # After modifying the radius: 8\n在这个示例中，radius Setter 不仅仅是为圆设置半径，它还在运行一个验证，确保半径不是负数。\n一旦你定义了 Getter 和 Setter，Python 会在你使用普通属性语法时在后台自动调用它们：\n示例代码\nmy_circle.radius # 这将调用 Getter\nmy_circle.radius = 4 # 这将调用 Setter\n请注意，在 Setter 内部，你不能在赋值新值时使用属性的相同名称。这是因为 self.radius = value 会在 Setter 方法本身内调用 Setter，导致无限递归和 RecursionError。所以你必须始终使用带下划线的前缀形式 self._radius = value。\n就像你可以通过 Getter 控制如何访问属性，通过 Setter 控制如何修改属性一样，你也可以通过 Deleter 控制如何删除属性。\n当你对属性使用 del 语句时，Deleter 会运行自定义逻辑。要创建一个 Deleter，你使用 @&lt;property_name&gt;.deleter 装饰器：\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    # Getter\n    @property\n    def radius(self):\n        return self._radius\n\n    # Setter\n    @radius.setter\n    def radius(self, value):\n        if value &lt;= 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n\n    # Deleter\n    @radius.deleter\n    def radius(self):\n        print(\"Deleting radius...\")\n        del self._radius\n以下是 Deleter 的使用方法：\n示例代码\n# 创建带有半径的圆对象\nmy_circle = Circle(33)\nprint(\"Initial radius:\", my_circle.radius)  # 33\n\n# 删除半径\n# 这将调用 Deleter\ndel my_circle.radius # Deleting radius...\nprint(\"Radius deleted!\") # Radius deleted!\n\n# 尝试在删除后访问半径\ntry:\n    print(my_circle.radius)\nexcept AttributeError as e:\n    print(\"Error:\", e) # Error: 'Circle' object has no attribute '_radius'\n本节课的要点是：\n\nGetter 让你检索一个值，甚至动态计算一个值。\nSetter 让你在赋值前运行检查，从而安全地修改值。\n属性 是将这些 Getter 和 Setter 绑定在一起的东西，让你可以编写逻辑，同时仍然使用点号表示法。\nDeleter 让你定义删除属性时发生的事情。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_6.html#understanding-inheritance-and-polymorphism",
    "href": "cp_6.html#understanding-inheritance-and-polymorphism",
    "title": "7  面向对象编程（OOP）",
    "section": "7.2 Understanding Inheritance and Polymorphism",
    "text": "7.2 Understanding Inheritance and Polymorphism\n\n7.2.1 What Is Inheritance and How Does It Promote Code Reuse?\n继承是我们将要探讨的面向对象编程（OOP）的下一个关键概念。\n让我们深入了解一下这个概念，以及它如何让你编写可重用的代码。\n通过继承，子类（或称派生类）可以使用基类（或称父类）的属性和方法。这允许你重用代码、创建清晰的类层次结构，并在不重写所有内容的情况下自定义行为。你可以通过扩展现有方法或在子类中重写它们来实现自定义。\n以下是继承的基本语法：\n示例代码\nclass Parent:\n    # 父类的属性和方法\n\nclass Child(Parent):\n    # 子类继承、扩展和/或在必要时重写\n为了让 Child 类继承自 Parent 类，你必须将 Parent 作为参数传递给 Child。\n这种风格被称为单继承，因为子类恰好从一个父类继承。\n这是一个示例：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack makes a sound\nprint(jack.bark)  # woof! woof!! woof!!!\n你可以看到，我们能够在子类 Dog 中重用父类 Animal 的 self.name 属性和 sound() 方法。\n让我们重写子类 Dog 中父类 Animal 的 sound() 方法，以便我们可以让 sound() 使用 bark 类变量：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound.'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\n    # 重写 sound() 以使用 bark 类变量\n    def sound(self):\n        return f'{self.name} barks {self.bark}'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack barks woof! woof!! woof!!!\n如果你想保留 sound() 的返回值，然后稍后添加 bark 类变量，你可以使用 super() 函数来扩展 sound()：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\n    # 调用 Animal.sound()，然后追加 bark\n    def sound(self):\n        base = super().sound()\n        return f'{base}, then {self.name} barks {self.bark}'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack makes a sound, then Jack barks woof! woof!! woof!!!\n在这个示例中，base 是调用 Animal 类的 sound() 方法的结果，然后我们将其追加到 Dog 类特有的声音中。这样，你可以在保留父类 Animal 原始行为的同时，扩展其功能。\n还有一种多重继承，即子类可以从多个父类继承。\n以下是多重继承的基本语法：\n示例代码\nclass Parent:\n    # 父类的属性和方法\n\nclass Child:\n    # 子类的属性和方法\n\nclass GrandChild(Parent, Child):\n    # GrandChild 从 Parent 和 Child 继承\n    # GrandChild 可以组合或重写来自每个父类的行为\n演示多重继承的一个简单方法是使用青蛙，它既可以在陆地上行走，也可以在水中游泳：\n示例代码\nclass Walker:\n    def walk(self):\n        return 'I can walk on land'\n\nclass Swimmer:\n    def swim(self):\n        return 'I can swim in water'\n\n# Amphibian 从 Walker 和 Swimmer 继承\nclass Amphibian(Walker, Swimmer):\n    def __init__(self, name):\n        self.name = name\n\n    def introduce(self):\n        return f\"I'm {self.name} the frog. {self.walk()} and {self.swim()}.\"\n\nfrog = Amphibian('Freddy')\nprint(frog.introduce())\n# Output: I'm Freddy the frog. I can walk on land and I can swim in water.\n\n\n7.2.2 What Is Polymorphism and How Does It Promote Code Reuse?\n多态性（Polymorphism）是我们将要讨论的面向对象编程（OOP）的下一个关键概念。\n通过多态性，你可以访问一个接口，通过它与许多同类型的对象进行交互。\n让我们深入了解一下多态性以及它如何让你重用代码。\n多态性允许不同类中的方法共享相同的名字，但执行不同的任务。你对不同的对象调用相同的方法名，每个对象会以自己的方式响应。\n以下是多态性的基本示例：\n示例代码\nclass A:\n   def action(self): ...\n\nclass B:\n   def action(self): ...\n\nclass C:\n   def action(self): ...\n\nClass().method()  # 对 A、B 或 C 都适用\n这是一个使用不同动物声音来描述多态性的示例：\n示例代码\nclass Cat:\n   def speak(self):\n       return \"A cat meow\"\n\nclass Bird:\n   def speak(self):\n       return \"A bird tweet\"\n  \nclass Monkey:\n   def speak(self):\n       return \"A monkey ooh ooh aah aah ooh ooh aah aah\"\n\ndef animal_sound(animal):\n   print(animal.speak())\n\nanimal_sound(Cat())\nanimal_sound(Bird())\nanimal_sound(Monkey())\n在这个示例中，animal_sound() 是一个接受任何具有 speak() 方法的对象的函数。\n当你传入 Cat、Bird 或 Monkey 时，它会调用该对象的 speak() 方法并打印结果。因为每个类都以不同的方式定义了 speak()，所以同一个函数会得到不同的输出。这就是多态性的实际应用。\n这是另一个示例，这次涉及实例和属性：\n示例代码\nclass Twitter:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"🐦 Tweet: '{self.content}' (280 chars max)\"\n\nclass Instagram:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"📸 Instagram Post: '{self.content}' + ✨ filters\"\n\nclass LinkedIn:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"💼 LinkedIn Article: '{self.content}' (Professional Mode)\"\n\ndef start(social_media):\n   print(social_media.post())  # 对任何对象调用 .post()\n\n# 实例\ntweet = Twitter('Just learned Python polymorphism!')\nphoto = Instagram('Sunset vibes 🌅')\narticle = LinkedIn('Why OOP matters in 2024')\n\n# 多态性调用 - 相同的函数，不同的输出\nstart(tweet) # 🐦 Tweet: 'Just learned Python polymorphism!' (280 chars max)\nstart(photo) # 📸 Instagram Post: 'Sunset vibes 🌅' + ✨ filters\nstart(article) # 💼 LinkedIn Article: 'Why OOP matters in 2024' (Professional Mode)\n还有一种多态性被称为基于继承的多态性（inheritance-based polymorphism）。\n在基于继承的多态性中，父类定义一个方法，多个子类以自己的方式重写该方法。然后，你可以对任何子对象调用相同的方法，它会根据它是哪个子类而表现不同。\n这是一个示例：\n示例代码\nclass Animal:\n   def speak(self):\n       return 'Some generic sound'\n\nclass Cat(Animal):\n   def speak(self):\n       return 'A cat meow'\n\nclass Dog(Animal):\n   def speak(self):\n       return 'A dog barks woof woof'\n\nclass Monkey(Animal):\n   def speak(self):\n       return 'A monkey ooh ooh aah aah ooh ooh aah aah'\n  \nprint(Cat().speak()) # A cat meow\nprint(Dog().speak()) # A dog barks woof woof\nprint(Monkey().speak()) # A monkey ooh ooh aah aah ooh ooh aah aah\nprint(Animal().speak()) # Some generic sound\n你可以看到，父类 Animal 的每个子类都重写了 speak() 方法以提供自己的实现。因此，当你对每个子类的实例调用 speak() 方法时，它会返回与该动物相关的特定声音。\n你还可以更进一步，在列表中进行调用，然后遍历列表以显示 speak() 方法为每个子类返回的内容：\n示例代码\nanimals = [Cat(), Dog(), Monkey()]\n\nfor animal in animals:\n   print(animal.speak())\n\n# Output:\n# A cat meow\n# A dog barks woof woof\n# A monkey ooh ooh aah aah ooh ooh aah aah\n\n\n7.2.3 What is Name Mangling and How Doesit Work?\n在上一节课中，你学习了如何使用单下划线和双下划线为属性命名。\n为了让你回顾一下它们之间的区别：单下划线是一种约定，意味着该属性仅供类内部使用，不应从类的外部直接访问。而双下划线则阻止该属性从类的外部被直接访问。\n这是一个演示两者如何工作的示例：\n示例代码\nclass Example:\n    def __init__(self):\n        self._internal = 'I can be accessed from outside the class, but should not'\n        self.__private = 'You cannot access me directly from outside the class'\n\nobj = Example()\n\nprint(obj._internal) # I can be accessed from outside the class, but should not\nprint(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'\n为属性加上双下划线前缀会触发 Python 的名称改写（name mangling）过程，在这个过程中，Python 会在内部通过添加一个下划线和类名作为前缀来重命名该属性，将 __attribute 变成 _ClassName__attribute。\n要看到这一点，你可以创建一个类的实例，并使用该实例的 __dict__ 特殊属性，它是一个包含对象属性的字典：\n示例代码\nclass Example:\n    def __init__(self, internal, private):\n        self._internal = internal\n        self.__private = private\n\nexample1 = Example(\n    'I can be accessed from outside the class, but should not',\n    'I cannot be accessed directly from outside the class'\n)\n\nprint(example1.__dict__)\n结果将是：\n示例代码\n{\n  '_internal': 'I can be accessed from outside the class, but should not',\n  '_Example__private': 'I cannot be accessed directly from outside the class'\n}\n正如你所见，__private 属性被存储为 _Example__private。这意味着你仍然可以通过这种方式从类的外部访问该属性：\n示例代码\nclass Example:\n    def __init__(self, internal, private):\n        self._internal = internal\n        self.__private = private\n\nexample1 = Example(\n    'I can be accessed from outside the class, but should not',\n    'I cannot be accessed directly from outside the class'\n)\nexample2 = Example(\n    'I should not be accessed from outside the class',\n    'But I can be accessed from outside the class with name mangling'\n)\n\nprint(example1._Example__private) # I cannot be accessed directly from outside the class\nprint(example2._Example__private) # But I can be accessed from outside the class with name mangling\n那么，为什么 Python 要进行名称改写呢？\n名称改写的主要目的是在使用继承时防止意外覆盖属性和方法。这是一个明确说明这一点的示例：\n示例代码\nclass Parent:\n    def __init__(self):\n        self.__data = 'Parent data'\n\nclass Child(Parent):\n    def __init__(self):\n        super().__init__()\n        self.__data = 'Child data'\n\nc = Child()\nprint(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}\n你可以看到，父类 Parent 和继承它的子类 Child 都有它们各自的 _class__data 属性。这是通过名称改写实现的。否则，子类就会意外地覆盖父类的数据。\n以下是如果不允许 Python 进行名称改写会发生的情况，即如果你不在两个类的属性前加上双下划线：\n示例代码\nclass Parent:\n   def __init__(self):\n       self.data = 'Parent data'\n\nclass Child(Parent):\n   def __init__(self):\n       super().__init__()\n       self.data = 'Child data'\n\nc = Child()\nprint(c.__dict__)  # {'data': 'Child data'}\n那么，在单下划线（_）和双下划线（__）之间，你应该使用哪一个来为属性命名呢？这取决于具体情况。如果一个属性仅供类内部使用，请坚持使用单下划线。\n但如果你正在处理一个将被继承的类，你应该使用双下划线，这样父类的属性就不会被覆盖。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_6.html#understanding-abstraction",
    "href": "cp_6.html#understanding-abstraction",
    "title": "7  面向对象编程（OOP）",
    "section": "7.3 Understanding Abstraction",
    "text": "7.3 Understanding Abstraction\n\n7.3.1 What Is Abstraction and How Does It Help Keep Complex Systems Organized?\n现在我们已经讨论了封装、继承和多态，接下来让我们探讨面向对象编程的下一个关键概念——抽象（Abstraction）。\n抽象是隐藏复杂的实现细节，只展示对象或系统的基本特征的过程。可以把它理解为专注于“某物做什么”，而不是“它是如何做的”。\n抽象并不仅限于 Python。它是一种编程概念，可以在许多支持面向对象编程的语言中实现。\n为了说明抽象，想象一下你正在驾驶一辆汽车。当你坐在驾驶座上时，你与方向盘、换挡杆、油门和刹车踏板等必要部件进行交互。你不需要知道发动机是如何工作的、变速箱是如何换挡的，或者刹车系统背后的物理原理，因为所有这些都属于复杂的实现细节。\n这就是抽象在起作用！它为你提供了一个简化的接口来与复杂的系统进行交互。\n再次以汽车为例，简化的接口是方向盘、刹车和油门，而复杂的系统是汽车本身。\n至于 Python 如何实现抽象，它通过 abc 模块来实现。\n该模块提供了 ABC 类（代表“抽象基类”）和 @abstractmethod 装饰器。\nABC 是打算被继承的类，但你不能直接从中创建对象。它定义了其子类必须实现的公共方法和属性接口。\n另一方面，抽象方法是在抽象基类（ABC）中使用 @abstractmethod 装饰器声明的方法。它可能没有实现，或者有一个基本的默认实现。但是，任何子类都必须重写它才能被视为具体类并可实例化，即使提供了默认实现也是如此。\n以下是 Python 中抽象类的基本语法：\n示例代码\nfrom abc import ABC, abstractmethod\n\n# 定义一个抽象基类\nclass AbstractClass(ABC):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\n# 实现抽象方法的具体子类\nclass ConcreteClassOne(AbstractClass):\n    def abstract_method(self):\n        print('Implementation in ConcreteClassOne')\n\n# 另一个具体子类\nclass ConcreteClassTwo(AbstractClass):\n    def abstract_method(self):\n        print('Implementation in ConcreteClassTwo')\n这是一个基本示例：\n示例代码\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC): # 继承自抽象基类\n   @abstractmethod # 抽象方法装饰器\n   def make_sound(self):  # 子类必须重写的方法\n       pass\n\n# 具体类，将重写抽象方法\nclass Dog(Animal):\n   def make_sound(self):\n       print('Woof!')\n\n# 另一个具体类，将重写抽象方法\nclass Cat(Animal):\n   def make_sound(self):\n       print('Meow!')\n\n# 另一个具体类，将重写抽象方法\nclass Monkey(Animal):\n   def make_sound(self):\n       print('Ooh ooh aah aah!')\n\n# 创建每个具体类的实例\nanimals = [Dog(), Cat(), Monkey()]\n\n# 遍历实例以调用 make_sound 方法\nfor animal in animals:\n   animal.make_sound()\n\n# 输出:\n# Woof!\n# Meow!\n# Ooh ooh aah aah!\n在这个示例中：\n\n我们从 abc 模块导入了 ABC 类和 abstractmethod。\n然后我们创建了一个继承自 ABC 的 Animal 类，并在其中创建了一个抽象方法 make_sound，每个 Animal 的子类都必须重写它。\n我们创建了具体类 Dog、Cat 和 Monkey，它们必须重写 make_sound 抽象方法。\n我们实例化了具体类并调用了它们的 make_sound 方法，以展示它们各自如何以自己的方式实现 make_sound 抽象方法。\n\n请记住，你不能创建 Animal 类的实例。如果你尝试这样做，会发生以下情况：\n示例代码\ndog = Animal() \n# TypeError: Can't instantiate abstract class Animal \n# without an implementation for abstract method 'make_sound'\n同样的规则适用于未为抽象方法提供实现的子类。即使你定义了 Animal 的子类，除非它重写了 make_sound，否则你无法实例化它。以下是一个示例：\n示例代码\nclass Bird(Animal):\n    pass\n\nbird = Bird()\n# TypeError: Can't instantiate abstract class Bird \n# without an implementation for abstract method 'make_sound'\n这是另一个示例，这次带有一个实例属性，你可以将其传递给具体方法的实例：\n示例代码\nfrom abc import ABC, abstractmethod\n\n# 任何可以说话的玩具的蓝图\nclass TalkingToy(ABC):\n   def __init__(self, name):\n       self.name = name\n   @abstractmethod\n   def speak(self):\n       pass\n\nclass RobotToy(TalkingToy):\n   def speak(self):\n       print(f'{self.name} says beep boop! I am a robot!')\n\nclass TeddyBearToy(TalkingToy):\n   def speak(self):\n       print(f\"{self.name} says hug me! I'm cuddly!\")\n\nclass DinosaurToy(TalkingToy):\n   def speak(self):\n       print(f'{self.name} says ROOOOAR!')\n\n# 创建玩具\nrusty = RobotToy('Rusty')\nfluffy = TeddyBearToy('Fluffy')\nrex = DinosaurToy('Rex')\n\ntoys = [rusty, fluffy, rex]\nfor toy in toys:\n   toy.speak()\n\n# 输出:\n# Rusty says beep boop! I am a robot!\n# Fluffy says hug me! I'm cuddly!\n# Rex says ROOOOAR!\n在这个示例中：\n\n我们有一个抽象基类 TalkingToy，它为任何可以说话的玩具定义了一个蓝图。\n子类 RobotToy、TeddyBearToy 和 DinosaurToy 以自己的方式实现了 speak 方法。\n当我们创建这些子类的实例并调用 speak 方法时，每个玩具都以自己独特的方式说话。\n\n总之，Python 中的抽象通过增加可重用来简化复杂的系统。\n你已经看到了如何从抽象类中重用单个方法到多个子类中，同时强制每个子类提供其特定的行为。\n这种方法使你的代码保持井井有条、灵活且易于维护，尤其是当你的应用程序不断增长时。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_7.html",
    "href": "cp_7.html",
    "title": "8  线性数据结构",
    "section": "",
    "text": "8.1 处理常见数据结构",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>线性数据结构</span>"
    ]
  },
  {
    "objectID": "cp_7.html#working-with-common-data-structures",
    "href": "cp_7.html#working-with-common-data-structures",
    "title": "8  线性数据结构",
    "section": "",
    "text": "8.1.1 What Is an Algorithm and How Does Big O Notation Work?\n在你的设备上运行的每个计算机程序都有一组特定的指令，这些指令按特定顺序执行以完成任务。\n该任务可能是对一组数字进行排序、修改图像、跟踪库存，甚至是运行你最喜欢的视频游戏。\n这就是算法发挥作用的地方。算法是用于解决问题或执行任务的一组明确的指令。\n你可以把算法看作是“食谱”。当你做饭时，食谱会列出你所需的所有食材，并提供准备菜肴的分步说明。\n同样，你可以把算法看作是“食谱”，它精确地告诉计算机应该做什么以及如何做。\n算法有两个关键特征：\n\n它们不能无限期地继续。它们必须在有限的步骤内完成。\n每个步骤都必须精确且明确。\n\n它们可能有零个、一个或多个输入，并生成一个或多个输出。\n算法的步骤独立于任何编程语言。\n但要让它们真正在计算机上运行，你需要用编程语言（如 Python 或 JavaScript）来实现它们。\n如果一个算法是正确的，那么对于任何有效输入，其输出都应该与预期输出匹配。\n除了正确性，算法还应该高效。\n算法的效率可以通过它们运行所需的时间以及完成任务所需的内存空间来衡量。\n了解算法的效率非常重要，因为它让你了解随着输入规模的增长，算法的性能会如何变化。\n例如，对 15 个整数进行排序与对 100 万个整数进行排序是不一样的。\n随着过程规模和复杂性的增长，如果算法效率不够高，你最终可能会得到一个非常慢的计算机程序，甚至可能导致整个系统崩溃。\n这就是为什么开发和选择尽可能高效的算法非常重要。\n这就是大 O 表示法（Big O notation）变得非常重要的地方。\n大 O 表示法描述了随着输入规模的增加，算法的最坏情况性能或增长速率。\n算法的增长速率是指随着输入规模的增长，它所需的资源如何增加。\n大 O 表示法关注最坏情况性能，因为了解即使在最坏情况下算法的效率如何非常重要，无论输入如何。\n回到我们的排序示例，直观上对 100 万个整数进行排序比对 15 个整数进行排序需要更多的时间和资源。\n但要多多少呢？\n这实际上取决于你选择用来排序的算法。\n大 O 表示法不会给出一个精确的数字来描述算法的效率，但它会根据算法执行的操作数，让你了解随着输入规模的增长，算法的扩展性如何。\n在大 O 表示法中，我们通常用字母 n 表示输入规模。例如，如果输入是一个列表，n 将表示该列表中的元素数量。\n在根据操作数确定算法的时间复杂度时，不考虑常数因子和低阶项。因为随着 n 的规模增长，这些较小项在执行的总操作数中的影响会变得越来越小。\n将主导算法整体行为的将是 n 的最高阶项，即输入规模。\n例如，如果一个算法执行 7n + 20 个操作才能完成，随着 n 的增长，常数 20 对最终结果的影响会变得越来越小。项 7n 将倾向于主导，这将定义算法的整体行为和效率。\n另一个例子是一个执行 20n² + 15n + 7 个操作才能完成的算法。随着 n 的增长，项 20n² 将倾向于主导，因此该算法将具有二次时间复杂度，因为主导项是 n²。\n二次时间复杂度是算法世界中你可能遇到的许多不同类型的时间复杂度之一。\n让我们了解一些最常见的类型。\nO(1) 被称为“常数时间复杂度”。当算法具有常数时间复杂度时，无论输入规模如何，它运行所需的时间都相同。\n例如，检查一个数字是偶数还是奇数总是需要相同的时间，无论数字本身是多少。\n示例代码\ndef check_even_or_odd(number):\n    if number % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'\nO(log n) 被称为“对数时间复杂度”。这意味着算法所需的时间随着输入规模的增长而缓慢增加。这在问题规模反复以恒定分数减少的问题中很常见。\n例如，一种名为二分查找（Binary Search）的流行搜索算法具有 O(log n) 的最坏情况时间复杂度。这是因为它在每次比较中都会消除一半的剩余元素，这使得它整体上更高效。\nO(n) 被称为“线性时间复杂度”。具有这种时间复杂度的算法的运行时间与输入规模成正比地增加。\n例如，一个遍历列表所有元素的 for 循环，随着列表元素数量的增加，它将执行更多的迭代。如果列表大小翻倍，操作数量也将大致翻倍。\n示例代码\nfor grade in grades:  # grades 是一个列表。\n    print(grade)\nO(n log n) 被称为“对数线性时间复杂度”。这是高效排序算法（如归并排序（Merge Sort）和快速排序（Quick Sort））的常见时间复杂度。\nO(n²) 被称为“二次时间复杂度”。这些算法的运行时间相对于输入规模呈二次方增加，这对于现实世界的问题通常效率不高。\n嵌套循环是二次时间复杂度的一个常见例子。内层循环将对外层循环的每个 n 次迭代执行 n 次迭代，从而导致 n 的平方次迭代。\n示例代码\nfor i in range(n):\n    for j in range(n):\n        print(\"Hello, World!\")\n其他时间复杂度包括“指数时间复杂度”，表示为 O(2^n)，以及“阶乘时间复杂度”，表示为 O(n!)。两者在现实场景中效率都不高。\n在这张图中，你可以比较代表最常见时间复杂度的数学函数的增长。将 x 轴（水平）视为输入规模，将 y 轴（垂直）视为算法的运行时间。\n你可以看到二次时间复杂度（O(n²)）（黄色）比其他增长快得多，而常数时间复杂度（O(1)）（红色）保持不变，即使输入变大也是如此。\n比较时间复杂度的图表\n太好了。到目前为止，你已经从时间要求的角度了解了大 O 表示法，但这个表示法也可以应用于空间要求的上下文。\n在这种情况下，它描述了随着输入规模的增长，算法所需的内存空间如何增长。\n具有“常数空间复杂度” O(1) 的算法总是需要恒定量的内存空间，即使输入变大也是如此。\n一个例子是只在内存中创建和存储几个变量的算法。\n相比之下，具有“线性空间复杂度” O(n) 的算法所需的空间随着输入规模的增长而成比例地增加。\n一个例子是创建和存储长度为 n 的列表副本的算法。\n最后，具有“二次空间复杂度” O(n²) 的算法的空间需求随着输入规模的增长而呈二次方增加。\n一个例子是创建一个二维矩阵，其中维度由输入规模确定，存储所有可能的对。\n算法是计算机程序的构建块，而大 O 表示法是一个强大的框架，用于分析它们的效率，基于它们在最坏情况下的时间和空间要求如何随着输入规模的增长而扩展。了解它们的效率对于开发在现实场景中高效运行的软件非常重要。\n\n\n8.1.2 What Are Good Problem-Solving Techniques and Ways to Approach Algorithmic Challenges?\n在学习的过程中，你应该致力于培养强大的解决问题的能力。这些核心技能对于解决日常工作中的实际问题至关重要。\n解决算法挑战是练习的绝佳方式。它需要一种分析性的思维方式，能够将问题分解为其核心组件，并找到一种能高效生成正确输出的解决方案。\n但你该从哪里开始呢？\n你可以使用几种问题解决技术来开始应对这些挑战。\n作为一个例子，我们将在 Python 中反转一个字符串。\n这是挑战内容：\n“给定一个字符串，编写一个算法，返回一个字符顺序相反的新字符串。”\n当你遇到这种类型的问题时，你应该做的第一件事是多次阅读描述，以确保你理解了它的意思。如果你跳过这一步或读得太快，你可能会错过关键信息。\n然后，一旦你熟悉了问题，开始将其分解为其核心组件。\n问问自己：\n“输入是什么？”\n“期望的输出是什么？”\n“我如何将输入转换为期望的输出？”\n在这个问题中，你可以确定输入是一个字符串，因为挑战以“给定一个字符串…”开头。\n输出是“一个字符顺序相反的新字符串。”\n所以你需要取原始字符串并将其反转。\n这种初步分析一开始可能看起来有点重复，但它对于确保你完全理解需求非常有帮助。\n然后，你应该开始思考你将开发的算法将如何将输入转换为输出。\n在这个规划和分析阶段，使用伪代码（Pseudocode）来规划必要的步骤是很常见的。\n伪代码是算法逻辑的高级描述，本质上是通用的，不基于任何特定的编程语言。\n伪代码不像实际代码那么正式，因为它仅用于人类阅读。它应该是一目了然的。它的主要目的是给出将执行的步骤序列的清晰思路。\n伪代码通常是通用的书面语言（如英语）与编程结构（如 IF、ELSE、FOR 和 WHILE）的混合。\n这是你为解决“反转字符串”挑战可能编写的伪代码示例。\n示例代码\n获取 original_string\n\n设置 reversed_string = \"\"\n\n对于 original_string 中的每个字符：\n  将字符添加到 reversed_string 的开头\n\n显示 reversed_string\n请注意步骤是如何以易于理解的方式概述的。单词和结构本身可能因你遵循的标准而异。\n如果你愿意，你可以使用多种编程语言实现这些步骤，遵循相同的逻辑，因为伪代码独立于编程语言。\n到这一点，你可能已经意识到这个问题可以用许多不同的方式解决。这不是反转字符串的唯一方法。\n但请记住，选择正确的算法很重要。\n在之前的课程中，你了解了算法复杂度以及为什么选择在时间和空间上高效的算法很重要。\n这就是作为开发人员你将发挥关键作用的地方。你需要选择最高效的算法来解决挑战。\n思考不同的可用算法是你应该练习的一项重要问题解决技能。花点时间问问自己，你在伪代码中提出的解决方案是否是最好的。\n例如，有许多不同的算法用于排序元素，但其中一些比其他的更高效。例如，冒泡排序（Bubble sort）对于排序大列表非常低效，而快速排序（Quick Sort）通常更高效。\n对于我们的“反转字符串”挑战，我们可以使用以下任一方法，假设我们计划在 Python 中实现我们的算法：\n\n使用扩展切片语法 [::-1] 来获取新的反转字符串。\n从左到右循环遍历字符，并将新字符添加到新字符串的开头。\n调用 reversed() 函数来获取一个包含所有字符按相反顺序的迭代器，然后调用 ““.join() 方法将它们连接回一个字符串。\n\n你应该使用哪一个？这是你的选择。\n基于你的知识和经验做出这些决定会对你的应用程序的最终性能产生巨大影响。考虑不同的方法、它们的效率、影响和实现。\n问问自己：\n“我将如何处理这个问题？”\n“我将使用什么数据结构？”\n“我选择的数据结构是针对当前问题最高效的数据结构吗？”\n“我是否涵盖了所有可能的边缘情况？”\n边缘情况（Edge cases）是特定的有效输入或条件，发生在算法应处理的边界上。\n例如，在“反转字符串”挑战中，边缘情况将是采用空字符串作为输入。你是否正确处理了它？如果没有，请考虑处理此边缘情况的最佳方式，并将其添加到你的伪代码中。\n然后，一旦你对你的计划感到满意，你就可以进入实施阶段。在这个阶段，你将在编程语言中实现你的算法。\n在构建你的程序时，你应该编写模块化代码，使其易于阅读和理解。\n基于你当前的知识使用编程语言的工具。一些编程语言包括针对常见问题和任务的内置解决方案。如果可能，请使用它们。\n为了保持一致，请遵循你选择的编程语言的最佳实践。\n在编写代码时对其进行测试，并确保你适当地处理了边缘情况。\n一旦你的解决方案实现，检查它是否对所有示例都正确工作，并可能重构你的代码以使其更清晰或更简单。\n回到你的解决方案非常重要。开发不一定是一个线性的、循序渐进的过程。你总是可以回到你的代码，并使用你的批判性思维技能来改进它。\n这些是你在应对算法挑战时可以遵循的一些常见问题解决技术。如果你持续练习，你会逐渐发展你的问题解决技能。\n\n\n8.1.3 How Do Dynamic Arrays Differ From Static Arrays?\n数组是计算机科学中一种基础的数据结构。所有的数组都存储有序的数据集合，但根据其类型的不同，它们在底层的工作方式可能不同。\n它们底层的行为会对程序的效率产生重要影响，因此让我们来了解一下动态数组和静态数组以及它们的区别，这样你就可以为你的程序选择最高效的一种。\n我们将从静态数组开始。\n静态数组具有固定的大小。它们将元素存储在相邻的内存位置中。\n静态数组的大小是在数组初始化时确定的。一旦分配了那个特定的内存块，它就是固定的，在程序运行时无法更改。这是静态数组的一个关键特征。\n将元素存储在相邻的内存位置中使数据检索过程更高效，因为程序可以存储第一个元素的位置，然后使用索引来执行简单的计算并找到内存中的其他元素。\n因此，访问静态数组的值需要恒定的时间 O(1)，这是非常高效的。\n当你预先知道将要存储的元素数量时，可以使用静态数组。当值将被非常频繁地访问时，它也很有用，因为访问操作非常高效。\n然而，这种数据结构不能增长或缩小，所以如果要存储的元素数量可能变化，你应该使用动态数组。\n尝试增加静态数组的大小将涉及创建一个新数组并将所有元素从旧数组复制到新数组，这是低效的。在这种情况下，动态数组会好得多，因为它会自动处理这个过程。\nPython 不包含作为内置数据结构的传统静态数组。\n但其他编程语言，如 Java，确实支持它们。这是一个在 Java 中可以存储三个整数的静态数组的示例：\n示例代码\nint[] numbers = new int[3];\nPython 中的数组是动态的，所以让我们来看看它们。\n动态数组更灵活，因为它们可以在程序运行时自动增长或缩小。\n它们通过一种自动调整大小的机制工作，当原始数组满时，将元素复制到一个新数组中。这个过程是高效的，因为新数组的大小是以一种高效的方式选择的，使这些计算成本高昂的操作不那么频繁。\n访问动态数组的元素需要恒定的时间 O(1)，所以这个操作非常高效。\n在数组中间插入一个元素需要线性时间 O(n)，因为它后面的元素需要重新定位。\n在数组末尾插入一个元素，如果动态数组中仍有可用空间，则需要恒定的时间 O(1)，但如果数组已满且需要调整大小，这个操作具有 O(n) 的复杂度。\n当你不知道预先需要存储的值的数量时，应该使用动态数组。当你将频繁插入和删除元素时，它们也很有用。\nPython 的内置列表数据结构作为动态数组工作。你可以通过在方括号内编写元素来创建一个列表，元素之间用逗号分隔。\n示例代码\nnumbers = [3, 4, 5, 6]\n你可以通过编写保存列表的变量的名称，后跟方括号，并在方括号内编写相应的索引来访问一个元素。\n索引从第一个元素的 0 开始，并为每个后续元素递增 1：\n示例代码\nnumbers[0]  # 3\nnumbers[1]  # 4\nnumbers[2]  # 5\nnumbers[3]  # 6\n要更新一个值，你只需要重新分配它：\n示例代码\nnumbers[2] = 16\n你可以使用 .append() 方法将元素追加到列表中：\n示例代码\nnumbers.append(7)\n你可以使用 .insert() 方法在特定索引处插入元素，将索引作为第一个参数，将元素本身作为第二个参数。\n示例代码\nnumbers.insert(3, 15)\n你可以使用 .pop() 方法在特定索引处删除一个元素：\n示例代码\nnumbers.pop(2)\n如果你不指定索引，.pop() 将删除最后一个元素。\n在文档中还有其他内置的列表方法，你可以查看，以便非常轻松地添加和删除元素。\n这就是动态数组，或在这种情况下列表的强大之处。\n总的来说，当你预先知道元素数量并且需要频繁访问它们时，应该使用静态数组，当元素数量未知或随时间变化时，应该使用动态数组。\n你应该始终考虑静态数组的简单性与动态数组的灵活性之间的权衡。它们对于特定的用例和场景都有帮助。能够为给定的问题选择最佳的一个，是你将通过练习逐渐发展的解决问题的技能的一部分。\n\n\n8.1.4 How Do Stacks and Queues Work?\n栈（Stacks）和队列（Queues）是计算机科学中常用的数据结构。\n它们是线性数据结构，遵循特定的规则来添加和移除元素。\n栈\n我们从栈开始。\n栈是一种后进先出（Last-in, First-out, LIFO）的数据结构。\n这意味着最后一个添加到栈中的元素将是第一个被移除的元素。\n栈有两个端，我们称之为栈顶（top）和栈底（bottom）。\n元素从栈的顶部添加和移除。\n你可以把栈想象成一堆盘子，你只能把盘子放在堆的顶部，也只能从堆的顶部拿走盘子。\n\n8.1.4.1 栈数据结构可视化\n在这种情况下，添加和移除元素的操作有特殊的名字。\n向栈中添加元素被称为“入栈（push）”操作。当我们将元素添加到栈顶时，我们说我们将元素“压入（push）”栈。\n\n\n8.1.4.2 栈入栈操作可视化\n从栈中移除元素被称为“出栈（pop）”操作。当我们将元素从栈顶移除时，我们说我们将元素“弹出（pop）”栈。\n\n\n8.1.4.3 栈出栈操作可视化\n你可以看到我们实际上不在栈底执行任何操作，但我们保留它作为参考。\n入栈和出栈操作的时间复杂度通常是 O(1)，即常数时间复杂度。\n当你将元素压入栈时，该元素被简单地添加到栈顶。\n当你从栈中弹出元素时，栈顶的元素被移除。\n因此，无论栈的大小如何，执行这些操作所需的时间都是恒定的。\n入栈和出栈操作的空间复杂度通常是常数 O(1)。这意味着无论栈的大小如何，执行这些操作所需的内存量都是恒定的。\n队列\n既然你对栈有了更多了解，让我们来学习队列。\n队列是一种先进先出（First-in, First-out, FIFO）的线性数据结构。这意味着第一个添加到队列中的元素将是第一个被移除的元素。\n队列有两个端：队头（front）和队尾（back）。\n\n\n8.1.4.4 队列数据结构可视化\n元素被添加到队列的尾部，从队列的头部移除。\n你可以把队列想象成在超市等待结账的一排人。排在最前面的人是第一个去收银台结账的人，而新来的人则在队尾加入队伍。\n在队列的上下文中，添加和移除元素的操作也有特殊的名字。\n向队列的尾部添加元素被称为“入队（enqueue）”操作。\n在入队操作中，新元素被添加到队列的末尾，成为队列的末尾。\n\n\n8.1.4.5 队列入队操作可视化\n从队列的头部移除元素被称为“出队（dequeue）”操作。\n在出队操作中，队列头部的元素被移除，下一个元素成为新的队头。\n\n\n8.1.4.6 队列出队操作可视化\n入队和出队操作的时间复杂度是 O(1)，即常数时间。无论队列的大小如何，执行这些操作所需的时间都是恒定的。\n入队和出队操作的空间复杂度通常是常数 O(1)。这意味着无论队列的大小如何，执行这些操作所需的内存量都是恒定的。\n栈和队列是计算机科学中用于组织和管理元素的数据结构。理解它们对于在各种编程应用中构建高效的算法至关重要。\n\n\n\n8.1.5 How Do Singly Linked Lists Work and How Do They Differ From Doubly Linked List?\n链表（Linked List）是一种线性数据结构，其中每个节点都连接到序列中的下一个节点。\n这些连接创建了一个看起来像节点链的数据结构，其中每个节点存储数据以及对链表中下一个节点的引用。\n我们使用这些引用从第一个节点移动到下一个节点，以此类推。\n链表通常用于实现其他数据结构，例如栈、队列和双端队列。它们也可以用于实现基本的图算法，例如深度优先搜索和广度优先搜索。\n单向链表\n单向链表是一种链表，其中每个节点都连接到序列中的下一个节点。\n每个节点通过存储对下一个节点的引用来连接到下一个节点。\n每个节点的单个引用允许你单向遍历链表，从头到尾。\n搜索只能向前移动，不能向后移动。\n在此示例中，你将从头节点（Head Node）开始，即节点 A。\n头节点是链表中的第一个节点。\n在单向链表中，头节点通常是唯一可以直接访问的节点。当你试图找到特定节点时，搜索过程将从这里开始。\n遍历过程将从节点 A 开始，然后继续到节点 B，然后是节点 C，最后是节点 D（尾节点）。如果你在代码中实现了特定逻辑，它也可能在此之前停止。\n尾节点（Tail Node）是最后一个节点。它用于确定过程何时到达链表的末尾。\n插入节点\n关于链表的一件好事是它们没有固定大小。它们可以根据需要通过简单地更新节点之间的连接来扩展或缩小。\n你可以在链表的开头、中间和末尾插入节点。\n链表不一定需要以特定顺序存储节点。顺序将由节点之间的连接决定。\n然而，如果你确实需要为你的特定用例保持节点的特定顺序，你可以通过在代码中实现该逻辑来实现，你实现的标准将确定节点是在开头、中间还是末尾插入。\n要在链表的开头插入节点，你只需要在新节点和曾经是头节点的节点之间创建一个连接，并使新节点成为头节点。\n在此示例中，我们在开头插入节点 E，并使这个新节点成为链表的头节点。\n在链表开头插入节点具有常数时间复杂度 O(1)，因为它只需要更新对头节点的引用以及新头节点和序列中下一个节点之间的连接。\n在此示例中，我们将节点 E 插入链表的开头。这将正常工作。但如果我们想保持链表按字母顺序排序，节点 E 将不得不插入链表的末尾。\n要在链表的末尾插入节点，首先你需要到达末尾，然后添加一个连接到新节点，使其成为新的尾节点。\n此操作具有线性时间复杂度 O(n)，其中 n 是链表中存储的节点数量，因为首先你需要到达链表的末尾以进行插入，这将需要从一个节点移动到下一个节点，以此类推，直到到达末尾。\n如果节点必须插入链表的中间，节点之间的连接也必须更新。序列中的前一个节点应该连接到新节点，新节点应该连接到下一个节点，如下图所示。\n插入操作具有常数空间复杂度 O(1)，因为插入新节点只需要创建它并更新节点之间的连接。此操作不依赖于链表本身的大小。\n删除节点\n正如你可以插入节点一样，你也可以从链表的开头、中间和末尾删除它们。\n要从开头删除节点，你需要更新对头节点的引用，它应该是序列中的下一个节点。\n此操作具有常数时间复杂度 O(1)，因为它只需要更新链表对头节点的引用。\n要从链表中间删除节点，你需要更新前一个节点的引用，以将其连接到序列中的下一个节点，在它们之间形成一种“桥”，如你在此图中所见。\n这将从连接序列中删除你想要删除的节点（在此情况下是节点 B），因此下次你遍历时将无法到达它。\n要从链表末尾删除节点，你需要删除前一个节点的连接，并使此节点成为新的尾节点。现在链表将在新的尾节点处结束。\n此操作具有线性时间复杂度 O(n)，因为你首先必须到达链表的末尾。\n删除操作具有常数空间复杂度 O(1)，因为删除节点不需要额外的内存。\n双向链表\n既然你对单向链表有了更多了解，让我们来谈谈双向链表。\n在双向链表中，每个节点存储两个引用：一个对下一个节点的引用和一个对序列中前一个节点的引用。\n这意味着双向链表可以在两个方向上遍历。\n在这种类型的链表中，通常也会在链表本身中保留对尾节点的引用，以便在必要时从末尾开始遍历。\n听起来很棒，对吧？它们比单向链表更灵活。\n然而，双向链表确实比单向链表需要更多的内存，因为每个节点存储两个引用而不是一个。\n这是你在为你的项目选择正确的数据结构时应该记住的事情。\n这是一个权衡。\n插入和删除操作的工作原理完全相同。唯一的区别是，现在你需要更新每个节点的两个引用，并跟踪对尾节点的引用，以便非常高效地在双向链表末尾插入元素，并在必要时从后面开始遍历过程。\n单向和双向链表是计算机科学中用于以顺序方式存储和操作元素的基本数据结构。理解它们的区别对于为你的特定应用选择正确的一个至关重要。\n\n\n8.1.6 How Do Maps,Hash Maps and Sets Work?\n在本节课中，我们将介绍映射（Maps）、哈希映射（Hash Maps）和集合（Sets）。但在开始之前，让我们先定义一下抽象数据类型（Abstract Data Types）。\n抽象数据类型（ADT）是对数据类型的概念性表示，包括可以在数据上执行哪些操作以及数据的属性。\n抽象数据类型就像蓝图，它们描述了可以执行哪些操作，而不是如何执行它们。它们将接口与操作的实际实现分离开来。\n映射是一种以非常特定且高效的方式管理键值对（key-value pairs）及其操作的抽象数据类型。\n在映射中，每个值都与一个特定的键相关联。\n映射的一个关键特征是每个键必须是唯一的。这种唯一性允许进行直接查找，从而使检索信息的过程更加高效。\n只需要键是唯一的，值可以重复。\n映射抽象数据类型还定义了重要的操作，例如插入键值对、获取与键关联的值、更新与键关联的值、移除键值对以及检查映射中是否存在某个键。\n它实际上并没有指定这些操作应该如何执行，它只是将它们作为数据类型可用的操作的一部分列出。\n哈希映射，也称为哈希表，是映射抽象数据类型的的具体实现。\n哈希映射使用一种称为“哈希（Hashing）”的技术来非常高效地执行常见操作。\n哈希本质上是通过使用哈希函数为每个元素生成一个哈希值来工作的。\n哈希值是基于键值对的键生成的，它用于计算底层数组中的索引，底层数组是存储键值对的实际数据结构。\n但你可能会问自己：如果两个键导致相同的索引会发生什么？\n哈希映射通过巧妙的策略来解决这些冲突。\n一种选择是使用“链地址法（Chaining）”策略，其中每个数组索引指向一个链表（另一种数据结构），所有具有相同索引的元素都存储在该链表中。\n另一种策略是使用“开放寻址法（Open Addressing）”，它涉及基于预定义的搜索序列在数组中搜索下一个可用的索引。\n哈希映射的平均情况时间复杂度对于插入、检索和删除键值对操作是“常数时间”O(1)。\n这些操作的最坏情况时间复杂度是“线性时间”O(n)，当发生许多哈希冲突时会发生这种情况，因此必须多次应用冲突解决策略。\n插入到哈希映射中的空间复杂度在平均情况下是常数 O(1)，即存储新对所需的恒定量的内存。然而，在最坏情况下，由于底层数组的调整大小操作，它可能具有线性空间复杂度 O(n)。通常，删除元素具有常数空间复杂度 O(1)。\n这将哈希表变成类似于线性数据结构的东西，其中必须扫描 n 个元素才能找到目标键。然而，如果正确实现哈希映射，这种情况相对较少。\nPython 的字典在底层是作为哈希映射实现的。\n要创建一个 Python 字典，你只需要在花括号内编写键值对，并用逗号分隔它们。每个键应该用冒号与其对应的值分隔。\n示例代码\nmy_dictionary = {\n  'A': 1,\n  'B': 2, \n  'C': 3\n}\n在此代码中，‘A’ 是键，1 是值：\n示例代码\n'A': 1\n或者，你可以使用 dict()：\n示例代码\nmy_dictionary = dict(A=1, B=2, C=3)\n你可以通过其对应的键获取值：\n示例代码\nmy_dictionary['A']  # 1\n你也可以更新与键关联的值：\n示例代码\nmy_dictionary['A'] = 4\n你可以移除键值对：\n示例代码\ndel my_dictionary['A']\n你还可以检查一个键是否在字典中（或不在）：\n示例代码\n'C' in my_dictionary\n你可以调用这些方法分别获取字典的键、值和项。\n示例代码\nmy_dictionary.keys()\nmy_dictionary.values()\nmy_dictionary.items()\n太好了。既然你对映射和哈希映射有了更多了解，让我们来谈谈集合。\n集合是唯一元素的无序集合。\n让我们将这个概念分解为其关键组件：\n集合是无序的。集合的元素不以任何特定顺序存储，因此你不能通过索引访问它们。\n集合只包含唯一元素。如果你尝试两次添加相同的值，将只保留一个该值的副本。\n它们类似于数学中的集合，它们实现了相同的集合操作，如交集、并集和差集。\n集合的一个主要优点是它们保证元素将是唯一的（无重复）。这就是为什么它们经常用于从列表和其他数据结构中删除重复项。\n它们也是动态的。它们可以调整以适应当前存储的元素数量。这使它们相当强大。\n添加、移除、获取集合长度以及检查元素是否在集合中的平均情况时间复杂度是“常数时间”O(1)，这是非常高效的。\n由于集合是作为哈希表实现的，添加、移除和检查成员资格的最坏情况时间复杂度是“线性时间”O(n)。当发生多个哈希冲突时可能会发生这种情况，将哈希表变成类似于线性数据结构的东西，其中需要 n 次扫描才能找到键。\n在空间复杂度方面，在平均情况下，插入一个元素将具有常数复杂度 O(1)，因为一个新唯一元素需要恒定量的内存。然而，在最坏情况下，底层数组的调整大小操作可能需要线性空间复杂度 O(n)。通常，移除一个元素将具有常数空间复杂度 O(1)。\nPython 有一个内置的集合数据结构，你可以在程序中使用它来处理集合。\n在底层，Python 集合是使用仅存储键而不存储任何关联值的哈希表实现的。\n集合只能存储不可变数据类型的对象，因为它们的哈希值始终保持不变。相比之下，可变对象的哈希值在它们被改变时可能会改变。这就是为什么它们不能成为集合的一部分。如果存储在集合中的对象的哈希值发生变化，程序将无法再找到它。\n要在 Python 中定义一个集合，你只需要用花括号将元素括起来，并用逗号分隔它们：\n示例代码\nnumbers = {1, 2, 3, 4}\n要创建一个空集合，你可以调用 set()：\n示例代码\nnumbers = set()\n请注意，如果你使用空花括号，这将自动创建一个 Python 字典，而不是集合，因此你必须调用 set() 函数来创建一个空集合。\n你可以使用 .add() 方法向集合中添加一个元素：\n示例代码\nnumbers.add(5)\n你也可以使用 .remove() 方法从集合中移除元素：\n示例代码\nnumbers.remove(5)\n如果未找到元素，这将引发 KeyError。但如果你不希望在这种情况下引发错误，你可以改用 .discard() 方法。\n.pop() 方法返回集合中的一个任意元素，而 .clear() 方法从集合中移除所有元素。\n你可以使用 in 运算符测试一个元素是否在集合中：\n示例代码\n5 in numbers\nPython 还支持集合操作，包括并集、差集、对称差集和交集，你可以使用这些方法执行：\n示例代码\nset_a = {1, 2, 3, 4}\nset_b = {2, 3, 4, 5, 6}\n\nset_a.union(set_b)\nset_a.intersection(set_b)\nset_a.symmetric_difference(set_b)\nset_a.difference(set_b)\n或使用它们的等效运算符：\n示例代码\nset_a | set_b\nset_a & set_b\nset_a ^ set_b\nset_a - set_b\n添加、移除和测试成员资格的平均情况时间复杂度是“常数时间”O(1)。\n由于哈希映射的最坏情况冲突场景，这些操作的最坏情况时间复杂度是“线性时间”O(n)。\n你还可以检查一个集合是否是另一个集合的子集或超集：\n示例代码\nset_a.issubset(set_b)\nset_a.issuperset(set_b)\n总的来说，当你需要存储唯一项的集合并频繁检查项的存在时，应该使用集合。\n映射、哈希映射和集合是为高效的数据组织和检索而设计的强大数据结构。它们每一个都有其独特的特征和用例。作为开发人员，你需要为你的项目选择最佳的一个。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>线性数据结构</span>"
    ]
  },
  {
    "objectID": "cp_8.html",
    "href": "cp_8.html",
    "title": "9  算法",
    "section": "",
    "text": "9.1 搜索（Searching）和排序（Sorting）算法",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>算法</span>"
    ]
  },
  {
    "objectID": "cp_8.html#searching-and-sorting-algorithms",
    "href": "cp_8.html#searching-and-sorting-algorithms",
    "title": "9  算法",
    "section": "",
    "text": "9.1.1 What Is Binary Search and How Does It Differ From Linear Search?\n在计算机科学中，遍历列表查找项目是一项常见任务。关于搜索，有两种关键算法是你应该了解的：线性搜索（Linear Search）和二分搜索（Binary Search）。\n线性搜索从列表的开头开始，依次遍历每个项目，直到找到它要查找的目标值。\n如果找到了目标值，则返回该值在列表中的索引。如果未找到目标值，则返回 -1。我们返回 -1 是因为它在大多数编程语言中不是一个有效的索引。\n以下是线性搜索的代码示例：\n示例代码\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n如果我们要搜索的列表是 [13, 4, 7, 9, 10]，目标值是 9，函数将返回 3，因为 9 位于索引 3 处。\n如果我们把目标值改为 5，函数将返回 -1，因为列表中没有 5。\n虽然这是一个相对简单的算法，但它并不是最高效的。如果你有一个包含大量项目的列表，线性搜索可能需要很长时间才能找到目标值。\n线性搜索的时间复杂度是 \\(O(n)\\)，因为搜索列表所需的时间随着列表大小的增加而线性增长。\n线性搜索的空间复杂度是 \\(O(1)\\)，因为搜索列表不需要任何额外的空间。\n二分搜索是一种在大量项目列表中进行搜索的更高效算法。其前提是列表必须按升序排序。\n二分搜索通过将列表一分为二，并检查目标值是否位于列表中间来工作。如果目标值在列表中间，则返回目标值的索引。否则，算法会检查目标值在列表的左半部分还是右半部分。\n它会继续将列表剩余的部分一分为二，直到找到目标值。如果列表中没有目标值，则返回 -1。\n以下是二分搜索的代码示例：\n示例代码\ndef binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n\n    while low &lt;= high:\n        mid = (low + high) // 2  \n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n我们首先确定一个最低索引 low 和一个最高索引 high。这代表了我们要搜索的列表范围。\n然后我们检查 low 小于或等于 high 的条件。如果 low 大于 high，说明我们已经搜索了整个列表但未找到目标值。在这种情况下，我们停止搜索并返回 -1。\n如果 low 小于或等于 high，我们计算列表的中间索引 mid。然后检查目标值是否在中间索引处。如果是，我们返回中间索引。\n否则，我们检查中间点的值是否小于目标值。如果是，我们将 low 索引更新为中间索引加一。这意味着我们将搜索列表的右半部分。\n最后，如果其他条件都不为真，我们将 high 索引更新为中间索引减一。这意味着我们将搜索列表的左半部分。\n我们继续重复这个过程，直到找到目标值或确定目标值不在列表中。\n二分搜索的时间复杂度是 \\(O(\\log n)\\)，因为搜索列表所需的时间随着列表大小的增加而对数增长。\n二分搜索的空间复杂度是 \\(O(1)\\)，因为搜索列表不需要任何额外的空间。\n线性搜索和二分搜索可以用于你在计算机科学中遇到的各种问题。理解这两种算法之间的区别以及何时使用哪种算法非常重要。\n\n\n9.1.2 What Is Divide and Conquer, and How Does Merge Sort Work?\n计算机科学中的分治法（Divide and Conquer）范式是一种将问题递归地分解为更小的子问题的技术。这项技术的一个关键方面是递归，即当一个函数反复调用自身，直到达到一个基础情况（base case）为止。在本节课中，我们将通过研究归并排序（Merge Sort）算法来更好地理解分治法是如何工作的。\n假设我们有以下数字列表：\n示例代码\n42 37 53 17\n我们的目标是使用归并排序算法将该列表按从小到大的顺序进行排序。第一步是将该列表一分为二：\n示例代码\n42 37 | 53 17\n然后我们需要看列表的左侧部分：\n示例代码\n42 37\n我们取这个子列表并再次将其一分为二，直到每个子列表只包含一个项目：\n示例代码\n42 | 37\n只包含一个项目的列表在默认情况下是已排序的。接下来我们需要将这些单元素子列表合并成一个已排序的列表：\n示例代码\n37 42\n然后我们对原始列表的右侧部分遵循相同的过程：\n示例代码\n# 原始列表的右侧\n53 17\n\n# 将列表一分为二\n53 | 17\n\n# 将列表合并为已排序的顺序\n17 53\n现在原始列表的两半都已排序，我们将这两半合并在一起并对元素进行排序：\n示例代码\n17 37 42 53\n以下是该算法在代码中的样子：\n示例代码\ndef merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    sorted_list = []\n    i = 0\n    j = 0\n\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt;= right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n\n    return sorted_list\n归并排序的时间复杂度是 \\(O(n \\log n)\\)，因为列表被持续地一分为二（\\(\\log n\\)），然后合并在一起（\\(O(n)\\)）。与其他排序算法（如冒泡排序）不同，归并排序不是原地排序的，其空间复杂度为 \\(O(n)\\)。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>算法</span>"
    ]
  },
  {
    "objectID": "cp_9.html",
    "href": "cp_9.html",
    "title": "10  图和树",
    "section": "",
    "text": "10.1 理解图和树",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图和树</span>"
    ]
  },
  {
    "objectID": "cp_9.html#understanding-graphs-and-trees",
    "href": "cp_9.html#understanding-graphs-and-trees",
    "title": "10  图和树",
    "section": "",
    "text": "10.1.1 What Are Graphs in Computer Science?\n图（Graphs）是一种数据结构，用于表示对象或实体之间的连接或关系。它们通常用于对网络进行建模。\n你可以用图来建模各种类型的网络，包括社交网络、交通网络、通信网络，甚至推荐系统。\n例如，图可以表示社交媒体平台上用户之间的连接，或者公路网上城市之间的连接。它们的用途非常广泛。\n图通常被表示为由线条连接的一组点或圆圈。这些圆圈和线条代表了图的两个主要组成部分：节点（Nodes）和边（Edges）。\n节点（Nodes），也称为顶点（Vertices），代表了图所建模网络中的对象或实体。它们可以是用户、产品、车站、城市或模型中的任何其他实体。在这个例子中，节点被表示为圆圈，并用字母 A、B、C、D 和 E 标记，以便视觉上区分。\n边（Edges）是节点之间的连接。如果两个节点由一条边连接，则意味着它们在网络中以某种方式相关联。\n在这个例子中，有五条边连接着不同的节点对。节点 A 连接到节点 B，节点 B 连接到节点 A、C 和 D，以此类推。\n连接的具体含义取决于上下文。它可能是物理上的，比如连接两个城市的真正道路；也可能是更抽象的，比如社交媒体平台上两个用户之间的关系。\n如果两个节点由一条边直接连接，比如例子中的节点 A 和 B，它们被称为相邻节点（Adjacent Nodes）。\n\n🌐 图的类型\n图有不同的类型，具有不同的特征和应用场景。让我们来了解一下其中一些。\n\n10.1.1.1 无向图\n无向图是指边没有特定方向的图。这种类型的边通常用节点之间的一条直线表示。\n这意味着，如果有一条边连接节点 A 和 B，连接在两个方向上都有效：从节点 A 到节点 B，以及从节点 B 到节点 A。\n根据图所建模的网络，这种连接有不同的含义。\n例如，如果你在建模社交媒体平台上的用户连接，这意味着用户 A 与用户 B 相连，用户 B 也与用户 A 相连。这种连接是双向的。\n\n\n10.1.1.2 有向图\n相比之下，有向图是指边具有特定方向的图。\n如果有一条从节点 A 到节点 B 的连接，并不一定意味着存在一条从节点 B 到节点 A 的连接。\n有向图的边通常表示为带有箭头的直线，以指示方向。\n这里有一个例子。在这个图中，你可以从节点 A 前往节点 B，但不能从节点 B 前往节点 A，因为边的方向如此。\n例如，如果你在建模道路网络，这对于建模单行道或单向道路非常有用。你可以通过这条路从城市 A 前往城市 B，但不能从城市 B 前往城市 A。你需要选择不同的路线。\n如果有向图中的节点之间存在双向连接，你可以用两条连接它们的有向边来表示。\n在这里你可以看到一个例子。你可以从节点 B 前往节点 D，也可以从节点 D 前往节点 B，因为有两条边连接它们，但每条边都有一个方向。\n\n\n10.1.1.3 顶点标记图\n顶点标记图是一种图，其中每个节点除了其数据外，还与一个标签或标识符相关联。这些标签用于识别节点、在视觉上表示它们以及存储有关它们的附加信息。\n例如，在交通网络图中，节点可以是城市，它们的标签可以是它们的名称、坐标或对模型目的有帮助的任何其他特征。\n\n\n10.1.1.4 循环图\n循环图是指至少包含一个环路的有向图。\n环路是指你可以沿着图的边走的一条路径，它会带你回到你开始时的初始节点。\n在这个例子中，我们有一个有向图。如果你仔细观察，你会注意到它有一个环路。如果我们从节点 B 开始，前往节点 C，然后前往节点 D，我们可以再次通过有向边回到节点 B。\n这是一个环路，所以这是一个循环图。\n\n\n10.1.1.5 边标记图\n在边标记图中，边与标签相关联。这些标签通常画在它们对应的边旁边。\n\n\n10.1.1.6 加权图\n加权图是边标记图的一种特定类型，其中边上的标签表示可以比较并用于执行算术运算的值。\n一些边具有较高的权重，而另一些边具有较低的权重。这些权重代表了边的“成本”。\n例如，它们可能代表两个城市之间的距离，或者从一个城市到另一个城市所需的时间。\n这是一个加权图的例子。我们在每条边旁边写下每个权重。从节点 B 到节点 D 的“成本”是 3，由于这是一个无向图，从节点 D 回到节点 B 的成本也是 3。\n\n\n10.1.1.7 有向无环图\n在计算机科学中另一种非常常见的图类型是有向无环图，即具有没有环路的有向图。\n这是一个例子。它是一个有向图，因为每条边都有一个方向。\n它是无环的，因为它没有任何环路。为什么？请注意，如果你从一个特定的节点开始，由于边的方向，你无法回到它。\n\n\n10.1.1.8 不连通图\n我们在本节课中将介绍的最后一种图类型是不连通图。\n不连通图是指有两个或更多组节点，它们之间没有任何边连接的图。\n一个现实世界中的例子是社交网络，你有两组或多组互不认识且没有任何共同朋友的人。\n这是一个例子。第一个组件有节点 A、B 和 C。第二个组件有节点 D 和 E。这些组件之间没有任何边，所以这是一个不连通图。\n你可以用各种方式实现图，包括集合、函数和数组。你将在接下来的课程中了解更多关于这方面的内容。\n理解图以及不同类型图的特征对于解决计算机科学和其他领域中的广泛问题是至关重要的。\n\n\n\n10.1.2 How Do Depth First and Breadth First Search Work?\n当你开始处理数据结构和算法时，很快就会意识到你需要执行的一项常见操作是访问每个节点。\n这个过程被称为对数据结构进行“遍历（Traversing）”。\n遍历用于对数据结构中的每个节点执行某些操作，比如打印它们的值、查找特定值，或者对节点执行特定操作。\n通过系统地访问每个节点，你确保该过程不会遗漏任何节点。\n但是，你如何确定遍历数据结构的顺序呢？该过程应该从哪里开始，以及如何选择下一个节点？\n如果没有清晰的方法来遍历数据结构，那么遍历它就像在迷宫中行走而没有特定路径可循一样。\n这就是像广度优先搜索（BFS）和深度优先搜索（DFS）这样的算法变得非常重要的地方。它们通常用于遍历图以及在两个节点之间寻找路径。\n当它们用于遍历数据结构时，它们定义了应该访问节点的顺序，以确保不会遗漏任何一个节点。\n让我们从广度优先搜索（BFS）开始。\n广度优先搜索 (BFS)\n广度优先搜索（BFS）是一种在移动到图的下一级之前，先访问所有相邻节点的算法。\n它可用于在无权图中找到两个节点之间的最短路径，因为它会分析每一级的所有节点，所以它首先找到边数最少的路径。\n该算法通常使用队列（Queue）数据结构来跟踪已访问的节点。队列遵循 FIFO（先进先出）方法，其中第一个添加到队列的节点是第一个被移除的节点。\n该算法的工作原理如下：\n\n从特定节点开始。\n将该节点标记为已访问并添加到队列中。\n当队列不为空时，从队列中移除（出队）当前节点。然后，对于它的每个邻居，如果邻居尚未被访问，则将其标记为已访问并添加到队列中。\n\n一个重要的考虑是，由于广度优先搜索（BFS）需要在内存中存储一个队列，并且这个队列可能包含大量节点，因此该算法的空间需求可能相当大。对于在同一级别上有大量节点的图来说尤其如此。\n让我们看一个将 BFS 应用于一种称为树（Tree）的特定类型图的示例。\n你将在接下来的课程中了解更多关于树的知识，但它们本质上是没有环路的图，其中节点以层次结构组织。环路是开始和结束于同一节点的路径。\n让我们将广度优先搜索（BFS）算法应用于这棵树：\n步骤 1：\n我们从树的根节点 A 开始。我们将 A 添加到队列中并立即将其标记为已访问。\n队列：[A]\n已访问：{A}\n步骤 2：\n我们从队列中移除节点 A。我们将它的未访问子节点（节点 B，然后是节点 C）添加到队列中，并将它们标记为已访问。\n队列：[B, C]\n已访问：{A, B, C}\n在同一级别上将节点添加到队列的顺序由数据结构的实现和图表示中存储边（连接）的顺序定义。\n如果实现是一致的，那么在同一级别上遍历节点的具体顺序不会影响算法的正确性。它仍然会逐级访问每个节点。\n步骤 3：\n我们从队列中移除节点 B。我们将它的未访问子节点（节点 D，然后是节点 E）添加到队列中，并将它们标记为已访问。\n队列：[C, D, E]\n已访问：{A, B, C, D, E}\n步骤 4：\n我们从队列中移除节点 C。我们将它的未访问子节点（节点 F，然后是节点 G）添加到队列中，并将它们标记为已访问。\n队列：[D, E, F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 5：\n我们从队列中移除节点 D。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[E, F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 6：\n我们从队列中移除节点 E。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 7：\n我们从队列中移除节点 F。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[G]\n已访问：{A, B, C, D, E, F, G}\n步骤 8：\n我们从队列中移除节点 G。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[]\n已访问：{A, B, C, D, E, F, G}\n当队列为空时，遍历完成。\n节点的遍历顺序如下：\nA → B → C → D → E → F → G\n请注意算法是如何按级别访问节点的。\n我们从节点 A 开始，然后移动到下一级以访问节点 B 和 C，然后移动到下一级以访问节点 D、E、F 和 G。这就是广度优先搜索（BFS）的核心原理。\n深度优先搜索 (DFS)\n虽然广度优先搜索（BFS）首先访问同一级别的所有相邻节点，但深度优先搜索（DFS）会将每个分支尽可能深入地跟随，然后才回溯。\n你可以将该算法想象为通过选择特定路径并沿着它走，直到你到达死胡同或出口来探索迷宫。如果你到达死胡同，你会往回走并选择不同的路径。\n深度优先搜索（DFS）通常用于解决具有单一解决方案的谜题、检测图中的环路以及查找图的连通分量。\n该算法可以使用递归或栈（Stack）数据结构来跟踪已访问的节点。\n栈遵循 LIFO（后进先出）方法，其中最后一个添加到栈的节点是第一个从栈中被移除的节点。\n该算法的工作原理如下：\n\n从特定节点开始。\n将该节点标记为已访问并添加到栈中。\n当栈不为空时，当前节点被弹出（移除）。此时我们“访问”或处理它（例如，通过打印它的值）。然后，它所有的未访问邻居被标记为已访问并添加到栈中。\n\n该算法的一个限制是，它并不总是能保证在无权图中找到两个节点之间的最短路径。\n让我们看一个将深度优先搜索（DFS）应用于我们的树示例的示例。\n步骤 1：\n我们从根节点 A 开始。我们将其标记为已访问并添加到栈中。\n栈：[A]\n已访问：{A}\n步骤 2：\n我们从栈中弹出节点 A。\n然后，我们将它的未访问子节点，节点 B 和节点 C，添加到栈中。我们将它们按相反顺序添加，C 然后是 B，这样 B 在顶部（LIFO）并将首先被处理。我们还将它们标记为已访问。\n栈：[C, B]\n已访问：{A, B, C}\n步骤 3：\n我们从栈中弹出节点 B。\n然后，我们将它的未访问子节点，节点 D 和节点 E，按相反顺序（E 然后是 D）添加到栈中。我们还将它们标记为已访问。\n栈：[C, E, D]\n已访问：{A, B, C, D, E}\n步骤 4：\n我们从栈中弹出节点 D。该节点没有要添加到栈的子节点。\n栈：[C, E]\n已访问：{A, B, C, D, E}\n步骤 5：\n我们从栈中弹出节点 E。该节点没有要添加到栈的子节点。\n栈：[C]\n已访问：{A, B, C, D, E}\n步骤 6：\n我们从栈中弹出节点 C。\n然后，我们将它的子节点，节点 F 和节点 G，按相反顺序（节点 G 然后是节点 F）添加到栈中，我们将它们标记为已访问。\n栈：[G, F]\n已访问：{A, B, C, D, E, F, G}\n步骤 7：\n我们从栈中弹出节点 F。该节点没有要添加到栈的子节点。\n栈：[G]\n已访问：{A, B, C, D, E, F, G}\n步骤 8：\n我们从栈中弹出节点 G。该节点没有要添加到栈的子节点。\n栈：[]\n已访问：{A, B, C, D, E, F, G}\n当栈为空时，遍历完成，所有节点都已被访问。\n算法访问节点的顺序如下：\nA → B → D → E → C → F → G\n请注意我们是如何从节点 A 开始，然后沿着树一直向下到节点 B，以及节点 D 和 E，在我们再次向上移动到节点 C，然后到节点 F 和 G 之前。这是深度优先搜索（DFS）的核心原理，在回溯并寻找其他路径之前遍历完整的路径。\n在这种情况下，我们使用栈解决了这个示例。或者，深度优先搜索（DFS）可以使用递归实现，其中函数处理当前节点，然后为它的每个未访问邻居调用自身。函数调用栈隐式地管理 LIFO（后进先出）顺序。\n广度优先搜索（BFS）和深度优先搜索（DFS）都是遍历图和树的基本算法。广度优先搜索（BFS）逐级探索节点，这非常适合在无权图中找到最短路径。另一方面，深度优先搜索（DFS）将一个分支尽可能深入地跟随，然后才回溯，这非常适合解决迷宫和检测环路。了解它们的优缺点有助于为特定问题选择正确的一个。\n\n\n10.1.3 How Do Matrices and Adjacency Lists Work?\n图（Graphs）是一种非常强大的数据结构，由一组节点（也称为顶点）以及连接它们的边组成。\n在代码中，有两种常见的方法来实现图：\n\n邻接矩阵（Adjacency Matrices）\n邻接表（Adjacency Lists）\n\n让我们深入了解一下它们各自的优缺点。\n邻接矩阵\n我们从邻接矩阵开始。\n邻接矩阵是一个二维列表（数组），其中的行和列代表图的顶点。\n矩阵中的值代表节点之间的边或连接。\n例如，如果你有一个存储在变量 matrix 中的矩阵，那么存储在 matrix[i][j]（其中 i 是行，j 是列）位置的值就代表了节点 i 和节点 j 之间的边。\n这些值的含义会根据图是有权图还是无权图而有所不同：\n\n如果图是无权图，值为 1 表示这两个节点之间有一条边，值为 0 表示它们之间没有边。\n如果图是有权图，该值将代表连接节点的边的权重。\n\n使用邻接矩阵的一个巨大优势是，检查两个节点之间是否存在边的时间是恒定的 O(1)。这是因为程序只需要在二维列表中查找那个特定的值。\n然而，这种查找边的高效率是有代价的。邻接矩阵的空间需求很大，其空间复杂度为二次方级 O(V²)，其中 V 是图中节点的数量。\n这对于稀疏图（Sparse Graphs，即只有少数边的图）来说效率很低。为什么？因为如果图是稀疏的，你会在矩阵中存储大量的 0 来表示节点之间没有边，而这些 0 依然会占用内存空间。\n邻接矩阵在查找某个节点的邻居时效率也不高，因为程序必须遍历整行或整列来查找代表边的 0 和 1。在最坏的情况下，这个过程可能需要 O(V) 的时间，其中 V 是图中节点的数量。\n让我们看一个针对特定图的邻接矩阵示例：\n在这个邻接矩阵中：\n\n每一行代表一个节点。第一行代表节点 A，第二行代表节点 B，以此类推。\n每一列也代表一个节点。\n矩阵中的每个值代表每一对节点之间是否存在边。值为 0 表示这两个节点之间没有边，值为 1 表示存在一条边。\n对角线上的值代表每个节点是否有自环（Self-loop，即连接节点自身的边）。在我们的例子中，它们都是 0，因为该图没有任何自环。\n\n这是一个视觉表示，让你了解行和列如何代表相应的节点。\n例如，第一行是 [0, 1, 1, 1]，因为节点 A 有连接到节点 B、C 和 D 的边：\n示例代码\n#      A  B  C  D\n# A   [0, 1, 1, 1],\n# B   [1, 0, 0, 1],\n# C   [1, 0, 0, 0],\n# D   [1, 1, 0, 0]\n这是同一个邻接矩阵，但在 Python 代码中的实现：\n示例代码\nadjacency_matrix = [\n    [0, 1, 1, 1],  # 节点 A 的邻居是 B, C, 和 D\n    [1, 0, 0, 1],  # 节点 B 的邻居是 A 和 D\n    [1, 0, 0, 0],  # 节点 C 的唯一邻居是 A\n    [1, 1, 0, 0]   # 节点 D 的邻居是 A 和 B\n]\n邻接表\n表示图的另一种常见方法是使用邻接表。\n邻接表是一个数组或字典，用于存储每个节点的所有邻居。\n有两种方法来实现邻接表：\n\n作为数组，其中每个索引代表一个节点，该索引处存储的列表包含该节点的邻居。\n作为字典，其中每个键代表一个节点，与该键关联的值（一个列表）包含该节点的邻居。\n\n在空间需求方面，邻接表比邻接矩阵更高效。它们的空间复杂度为 O(V + E)，其中 V 是顶点（节点）的数量，E 是边的数量。\n查找所有邻居节点也很高效，因为此操作只需要访问与该节点关联的列表。\n然而，这也是一种权衡。\n与邻接矩阵相比，邻接表在确定两个节点之间是否存在边时效率较低。\n在最坏的情况下，搜索过程可能需要 O(V) 的时间，因为它可能必须遍历一个非常长的邻居列表（如果该节点连接到图中所有其他节点的话）。\n这是一个针对此图的邻接表示例：\n这个邻接表是作为字典实现的。字典中的每个键代表一个节点，与该键关联的值是一个包含对应节点所有邻居的列表：\n示例代码\nadjacency_list = {\n    'A': ['B', 'C', 'D'],\n    'B': ['A', 'D'],\n    'C': ['A'],\n    'D': ['A', 'B']\n}\n或者，我们可以将其实现为一个二维列表，其中每个索引代表一个节点。例如，索引 0 代表节点 A，索引 1 代表节点 B，以此类推：\n示例代码\nadjacency_list = [\n    ['B', 'C', 'D'],  # 节点 A (索引 0) 的邻居\n    ['A', 'D'],       # 节点 B (索引 1) 的邻居\n    ['A'],            # 节点 C (索引 2) 的邻居\n    ['A', 'B']        # 节点 D (索引 3) 的邻居\n]\n请注意，即使这个二维列表看起来可能与邻接矩阵相似，但它们有很大的不同。\n\n邻接矩阵存储 0、1 或代表图中边或边权重的其他值。\n邻接表存储每个节点所有邻居的实际列表。\n\n这是一个非常重要的区别，你应该熟悉它。\n邻接矩阵和邻接表对于实现图都非常重要。在它们之间进行选择取决于图的大小以及你需要如何使用数据。邻接矩阵对于具有许多边的稠密图（Dense Graphs）很有用，而邻接表通常是现实场景中的首选，因为在现实场景中稀疏图更为常见。\n\n\n10.1.4 What Are Trees and Tries and How DoThey Work?\n树（Trees）在计算机科学领域中非常重要。\n树是一种特定类型的图。\n要将一个图归类为树，它必须：\n\n没有环路或循环（起点和终点节点相同的路径）。\n是连通的（可以从每个其他节点到达每个节点）。\n\n树是组织节点在层次结构中的非线性数据结构，其中节点可能有子节点、兄弟节点和父节点。\n根节点（Root Node）是树的最顶端。它是树中唯一没有父节点的节点。这是你开始遍历整个数据结构的节点，通常使用像广度优先搜索（BFS）或深度优先搜索（DFS）这样的算法。\n这是一个树的图形示例：\n由于节点在层次结构中组织，它们之间有关系。\n父节点（Parent Node）是立即连接到其下方其他节点的节点。在图中，节点 A 是节点 B 和 C 的父节点。\n子节点（Child Node）是立即连接到其上方节点的节点。在图中，节点 D 和 E 是节点 C 的子节点。\n节点 D 和 E 也被归类为叶节点（Leaves）。叶节点是没有子节点的节点。你可以把它们看作是树的“分支”的末端。\n树节点也有重要属性：\n深度（Depth）：从根到该节点的路径长度。例如，在图中，节点 D 的深度是 2，因为如果你从根开始，你必须经过两条边才能到达它。\n高度（Height）：从该节点向下到叶节点的路径长度。例如，节点 C 的高度是 1，因为它比叶节点高一级。\n度（Degree）：每个节点拥有的子节点数量。在图中，节点 B 的度是 0，因为它是叶节点，所以它没有子节点。节点 C 的度是 2，因为它有两个子节点。\n树也有高度。树的高度是其根节点的高度。\n有许多不同类型的树，包括二叉树（Binary Trees）、二叉搜索树（Binary Search Trees）、AVL 树、红黑树（Red-Black Trees）和 B 树（B-Trees）。\n二叉树和二叉搜索树\n这是两种最常用的树类型。\n二叉树（Binary Tree）是一种每个节点最多可以有两个子节点的树，一个左子节点和一个右子节点。是的，这意味着你到目前为止看到的示例就是一棵二叉树！\n二叉树示例\n二叉搜索树（Binary Search Tree）是二叉树的一种更具体的形式，具有非常特殊的排序属性。\n要理解它，首先你需要理解子树（Subtrees）。子树是它本身也是一棵树的树的一部分。\n在我们的树示例中，节点 C、D 和 E 自身形成一棵树，所以它们被认为是一个子树。\n二叉搜索树（BST）的排序属性规定，对于每个节点，其左子树中的所有值都小于该节点的值，而其右子树中的所有值都大于该节点的值。\n左子树和右子树本身也必须是二叉搜索树。\n如果树是平衡的，这种排序使搜索、插入和删除操作非常高效。\n平衡树（Balanced Tree）是指任何节点的左子树和右子树的高度非常相似的树，以确保操作保持高效。\n字典树\n既然你对树和二叉搜索树有了更多了解，让我们深入了解一下字典树（Tries）。\n字典树是用于存储一组字符串的树数据结构。\n字典树也被称为前缀树（Prefix Trees），因为它们对于需要根据字符串前缀查找字符串的操作非常高效。\n字典树中的每个节点代表字符串的一个单个字符。\n根节点不代表任何特定字符，所以你可以把它看作代表一个空字符串。\n当你从根向下遍历字典树时，到一个节点的路径定义了一个特定的前缀。要查找一个单词，你沿着该前缀走，直到你到达有你正在寻找的单词的节点。\n代表完整单词的节点被分配了单词结束标记（End-of-word markers）。\n这是一个包含单词 “top”、“tea” 和 “ten” 的字典树示例。\n请注意单词 “tea” 和 “ten” 如何共享相同的前缀 “te”，所以数据结构遵循相同的路径，直到最后一个字符，该字符被标记为单词结束字符。在这个图中，这由节点周围的红色边框表示。\n搜索操作的最坏情况时间复杂度是 O(L)，其中 L 是你正在寻找的字符串的长度。\n插入也很高效。此操作只需要为字典树中尚不存在的字符创建新节点。\n这种数据结构的巨大优势是，当多个字符串共享相同的前缀时，它们的路径重叠，所以前缀本身只存储一次。\n这种效率使字典树非常适合实现自动补全和拼写检查器等功能。\n然而，字典树并非对所有字符串集都高效。如果字符串集有许多唯一字符，它们可能效率不高。这将需要将许多唯一字符存储为单独的节点。必须遍历这些节点才能找到单词，这不会是最优的。\n既然你熟悉了不同类型的树以及它们的用途，你可以在现实场景中开始使用它们。当你需要在日常工作中应对挑战时，知道如何选择正确的一个是一项宝贵的技能。\n\n\n10.1.5 How Do Priority Queues and Heaps Work?\n优先队列（Priority Queue）是一种抽象数据类型（ADT），它的工作方式与队列或栈类似，但有一个关键区别。\n众所周知，标准队列遵循 FIFO（先进先出）原则，即第一个添加到队列的元素也是第一个从队列中移除的元素。\n栈则遵循 LIFO（后进先出）原则，即最后一个添加到栈的元素是第一个被移除的元素。\n队列和栈只考虑元素的插入顺序。\n然而，优先队列会考虑元素的“优先级”。优先级用于确定下一个应该移除哪个元素。\n通常，优先级最高的元素会先被移除，但某些实现也可能选择先移除优先级最低的元素。这取决于你程序的具体需求。\n优先队列在实际应用中非常有用，例如寻找两个位置之间的最短路径、在操作系统中进行任务调度、模拟交通、数据压缩以及网络管理。\n在实践中，优先队列通常使用堆（Heap）数据结构来实现。\n堆是一种树数据结构，具有一种非常特定的属性，称为堆属性（Heap Property）。该属性基于堆的类型，决定了每个节点与其子节点之间的关系。\n主要有两种类型的堆：\n\n最大堆（Max-heap）\n最小堆（Min-heap）\n\n在最大堆中，每个节点的值都大于或等于其子节点的值。\n在此示例中，你可以看到一个具有节点 8、7、5、2 和 1 的树结构。请注意，节点 7 大于节点 2 和节点 1，符合堆属性。其他所有节点也是如此。\n相比之下，在最小堆中，每个节点的值都小于或等于其子节点的值。\n在此示例中，我们有值为 4、7、9、12 和 15 的节点。例如，节点 7 小于节点 12 和节点 15，符合堆属性。其他所有节点也是如此。\n堆属性至关重要，因为它确保了最大值（或最小值，取决于堆的类型）始终位于顶部，这使得移除它变得非常容易。\n在实践中，堆通常被实现为数组，以便高效地访问父节点和子节点。\n使用数组简化了访问这些值或“节点”的逻辑，因为在幕后，如果堆保持完全二叉树的结构，数组实现只需要基于索引的简单数学运算，即可找到元素在内存中的位置。\nPython 有一个内置的 heapq 模块，你可以用来操作最小堆的实现。\n它通过直接在 Python 列表上操作来工作，遵循特定的步骤，将元素作为堆来处理，同时保持堆属性。\n要使用此模块，你只需要导入它：\n示例代码\nimport heapq\n然后，你需要定义一个空列表。这将是堆的底层数据结构：\n示例代码\nmy_heap = []\n要向堆中添加元素，你可以调用 heappush()，传入堆的名称和要添加的元素作为参数。这会自动将元素添加到列表中应处的位置，以保持堆属性：\n示例代码\nheapq.heappush(my_heap, 9)\n要获取优先级最低（在此情况下，值最小）的元素，你可以调用 heappop()：\n示例代码\nheapq.heappop(my_heap)\nheappushpop() 将这两个操作合并为一个调用。\n这比单独依次调用它们更高效，特别是当堆很大时，因为它只执行一次“堆化”操作来重新排序列表。\n示例代码\nheapq.heappushpop(my_heap, 15)\n如果你已经有一个列表，并希望将其转换为堆，你可以调用 heapify()，传入堆作为参数：\n示例代码\nheapq.heapify(my_heap)\n但目前，我们是按元素的值进行排序，对吧？\n如果我们想按它们的“优先级”排序怎么办？\n你可以通过存储具有此结构的元组来实现：(priority, element)。\n由于元组是从左到右逐个元素进行比较的，因此会先比较优先级，并基于它们做出决定。\n请注意，在这种情况下，较低的值代表较高的优先级。这意味着优先级为 1 的元组比优先级为 3 的元组具有更高的优先级：\n示例代码\nmy_heap = []\n\nheapq.heappush(my_heap, (3, \"A\"))\nheapq.heappush(my_heap, (2, \"B\"))\nheapq.heappush(my_heap, (1, \"C\"))\n如果你需要优先级相同的元素按它们插入的顺序被移除，你可以考虑在元组中包含一个唯一的计数器作为第二个元素来打破平局，像这样 (priority, counter, element)。\n现在让我们谈谈堆的效率。\n插入元素以及从堆中提取最小值或最大值（取决于堆的类型）的平均和最坏时间复杂度是对数级的，即 \\(O(\\log n)\\)，因为所需的交换次数通常与堆的高度成正比，而堆的高度是 \\(\\log(n)\\)。\n“查看”操作（Peek）的平均和最坏时间复杂度是常数级的，即 \\(O(1)\\)。查看是指获取最小值或最大值（取决于堆的类型）而不移除它。\n“堆化”操作（Heapify），即从一个未排序的列表构建堆，在平均和最坏情况下的时间复杂度是线性的，即 \\(O(n)\\)。\n同样，搜索和删除任意元素在平均和最坏情况下的时间复杂度也是线性的，即 \\(O(n)\\)，因为它们可能需要遍历整个堆。\n那么它们需要多少空间呢？\n堆的空间复杂度是线性的，即 \\(O(n)\\)，其中 \\(n\\) 是它包含的元素数量。它只需要存储元素以及列表对象本身的一小部分额外开销。\n优先队列和堆在计算机科学中非常重要。它们让你能够快速找到并使用列表中最重要的元素。这种效率对于执行关键现实任务（例如在地图上寻找最快路线）的许多计算机程序至关重要。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图和树</span>"
    ]
  },
  {
    "objectID": "cp_1.html#python介绍",
    "href": "cp_1.html#python介绍",
    "title": "2  Python基础",
    "section": "",
    "text": "2.1.1 Python是什么？它在工业界有哪些常见的用途？\nPython 是一种通用编程语言，以其简洁性和易用性而闻名。这种易用性使 Python 成为当今最受欢迎的编程语言。2024 年，Python 正式超越 JavaScript，成为 GitHub 上最流行的语言。\nPython 被广泛应用于许多领域，如数据科学和机器学习、Web 开发、脚本和自动化、嵌入式系统、物联网（IoT）等等。\nPython 是目前大多数数据科学家和机器学习工程师使用的主要语言。Pandas 和 Numpy 等库让数据分析不再枯燥乏味，而 Tensorflow 和 Scikit 等库则让机器学习和使用 AI 模型变得更加触手可及。\n在 Web 开发领域，Django、FastAPI 和 Flask 等 Python 框架让开发者能够以最少的精力构建可扩展且安全的后端系统。许多社交媒体平台，如 Instagram 和 Pinterest，都在后端使用了 Python。\n网络安全专家和道德黑客（ethical hackers）使用 Python 来检测恶意软件和其他病毒等漏洞，构建自动化的安全扫描程序，并分析威胁。\nPython 在 Raspberry Pi（是一种单板计算机（Single-Board Computer，SBC））和支持 MicroPython 的开发板等微型计算机上运行良好，因此你可以构建各种物联网项目，如智能家居设备、气象监测站等。\n最后，Python 最大的优势之一就是自动化。你可以编写简单的脚本来帮助完成重复性任务，例如从电子表格中提取数据、发送电子邮件以及处理本地机器上的文件。\nSelenium 和 BeautifulSoup 等库也让与网站进行交互变得轻而易举，因此你可以抓取公开数据、通过 Web 界面自动化任务，甚至管理项目的云部署。\n由此可见，Python 是一种非常强大的语言，但学习起来却很容易。从简单的自动化脚本到大规模的工业级应用，几乎所有事情你都可以使用 Python 来完成。\n无论你以后选择专攻哪个领域，Python 都是任何想要学习编程的人的绝佳选择。\n\n\n\n答案：1 A 2 B 3 D\n\n\n2.1.2 如何安装、配置、使用Python\n在上一课中，你了解了什么是 Python 以及你可以用它做什么。现在，让我们来看看如何在你的本地机器上设置 Python。\n在 Windows 和 Mac 上安装 Python 最简单的方法是从官方 Python 网站下载安装程序。在本课的后面部分，我们还将介绍如何在 Linux 上运行 Python。\n访问https://www.python.org/，并将鼠标悬停在“Downloads”（下载）上。\n一个弹窗会出现，显示你当前操作系统（OS）的 Python 版本。\n\n我们首先来看看如何在运行 macOS 的电脑上安装 Python：\n点击弹窗中显示的当前 Python 版本按钮，你会自动开始下载一个 .pkg 安装文件。\n当 .pkg 安装程序下载完成后，打开它，然后在弹出的窗口中点击“Continue”（继续）。\n继续点击“Continue”（继续）按钮，直到你进入“Installation Type”（安装类型）部分。\n在那里，点击“Install”（安装）按钮。如有必要，请输入你的密码，然后开始安装。\n之后，你应该会收到一条恭喜消息，提示 Python 已成功安装。点击“Close”（关闭）按钮，大功告成！\n\n你可以通过打开终端并运行 python --version 或 python3 --version 来验证安装。\n你也可以通过在终端中运行 python 或 python3 来打开 Python 解释器。\n\n终端是一种基于文本的界面，允许你通过输入命令与电脑交互。每个操作系统都自带一个默认的终端应用程序。在 macOS 上，你可以使用终端（Terminal）应用程序。在 Windows 上，你可以使用命令提示符（Command Prompt）或 PowerShell。在 Linux 上，每个桌面环境都有其默认的终端应用程序，例如 GNOME 终端或 Konsole。\n请注意，在一些较旧的 macOS 和 Linux 系统中，python 可能保留给 Python 2 使用，而 python3 则专门用于 Python 3。如果你运行 python --version 并看到 Python 2 的版本（例如 Python 2.7.18），那么你的操作系统可能依赖于一些用旧版 Python 编写的软件。如果是这种情况，你应该在今后使用 python3 来运行你的 Python 代码。Python 2 已停止维护，不应在任何新开发中使用。\n要在 Windows 上安装 Python，请按照以下步骤操作：\n访问 https://www.python.org/，并将鼠标悬停在“Downloads”（下载）上。你应该会看到一个写着“Download for Windows”（下载 Windows 版）的弹窗和一个带有当前 Python 版本的下载按钮。\n点击版本号，你会自动开始下载一个 Windows 可执行文件（.exe）。当你下载完 Windows 版 Python 安装程序后，双击它，然后按照说明操作。当你看到“Add python.exe to Path”（将 python.exe 添加到路径）选项时，勾选该选项，然后点击“Install Now”（立即安装）。这样做会让你后续的工作更加轻松。\n你可以通过打开命令行 shell（如 PowerShell）并运行 python --version 来验证安装。你也可以通过运行 python 来打开 Python 解释器。\n关于 Linux 上的 Python，大多数主流发行版（如 Ubuntu、Debian 和 Fedora）都自带 Python。\n只需打开一个终端并运行 python --version 或 python3 --version：\n如果任一命令都没有显示 Python 版本，你可以在 https://www.python.org 上搜索适用于你 Linux 发行版的安装包，或者在网上搜索针对你的发行版推荐的 Python 安装方法。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#理解变量和数据类型",
    "href": "cp_1.html#理解变量和数据类型",
    "title": "2  Python基础",
    "section": "2.2 理解变量和数据类型",
    "text": "2.2 理解变量和数据类型\n\n2.2.1 如何声明变量？变量命名有哪些命名规范？\n在 Python 中，变量就像一个贴有标签的盒子，用于存储和引用不同类型的数据。要在 Python 中声明变量，你只需使用赋值（=）运算符将一个值分配给一个标识符即可。你不需要像在 JavaScript 中那样使用 let 或 const 这样的特殊关键字，也不需要像在 C# 中那样使用 char。\n在 Python 中，你只需在等号左边写上变量名，接着是赋值运算符，最后是在右边你想赋给该变量的值。下面是一个如何声明 name 和 age 变量的例子：\n示例代码\nname = 'John Doe'\nage = 25\n在上面的例子中，变量 name 保存的值是 'John Doe'。这个值是一个字符串（string），即用于表示文本的一系列字符。字符串用单引号或双引号括起来，例如 'Hello' 或 \"Hello\"。在后续的课程中，你将学习更多关于在 Python 中处理字符串的知识。\n在 Python 中命名变量时，有一些重要的规则需要牢记：\n\n变量名只能以字母或下划线（_）开头，不能以数字开头。\n变量名只能包含字母数字字符（a-z, A-Z, 0-9）和下划线（_）。\n变量名区分大小写 —— age、Age 和 AGE 都被视为不同的变量。\n变量名不能是 Python 的保留关键字，例如 if、class 或 def。\n\n如果你违反了其中任何一条规则，你的 Python 程序将抛出一个 SyntaxError（语法错误）：\n示例代码\n5variable_name = 5\n     ^\nSyntaxError: invalid decimal literal\n现在让我们来看看 Python 中一些常见的变量命名惯例。\n首先，变量名应该使用小写字母，单词之间用下划线分隔。这被称为蛇形命名法（snake case）：\n示例代码\nmy_variable_name = 'freeCodeCamp'\n其次，你应该为变量使用描述性的名称。例如，如果你想将用户的年龄保存为一个变量，user_age 就比 age 或 ua 这样的缩写要好：\n示例代码\nuser_age = 30\n这样一来，在一个庞大的代码库中，你就可以轻松地向其他团队成员（或者未来的自己）传达变量的用途。\n另一个惯例是避免使用单个字母的变量名。这在 Python 中很常见，但应该尽量避免，因为单个字母的变量名无法传达任何目的或含义：\n示例代码\nx = 56 # x 代表什么意思？\n不过，如果你是在循环（loop）或类似结构中，使用 i、j、k 等作为变量名是很常见且可以接受的。\n另外，上面例子中 # 符号及其后面的文字被称为注释（comment）。你可能已经熟悉注释了，让我们快速回顾一下并解释它们是如何工作的。\n在 Python 中，注释以井号（#）开头，解释器会忽略该行 # 符号之后的所有内容：\n示例代码\n# 这是一行单行注释\n多行注释可以通过连续使用单行注释来创建：\n示例代码\n# 这是一个\n# 多行\n# 注释\n你可以使用注释来解释你的代码、给自己留备忘录，或者阐明某一行代码存在的原因。注释在学习或团队协作时尤其有用。\n但是，你不应该使用注释来解释变量名的含义。相反，你为变量选择的名称应该是描述性的，并传达它们的用途，同时遵循前面提到的其他命名规则以防止语法错误。\n\n\n2.2.2 Print 函数是如何工作的？\n每种编程语言都有一些内置的方法、函数、属性或关键字，用于将数据输出到终端。在 Python 中，你可以使用 print 函数将数据打印到终端。让我们仔细看看 print 函数，这样你就可以开始自信地使用它了。\n当你学习任何编程语言时，要做的第一件事通常就是编写一个简单的“Hello world!”（你好，世界！）程序。在 Python 中，你只需使用 print 函数就能非常轻松地做到这一点。\n要做到这一点，你只需要把字符串 Hello world! 放在调用 print 函数所用的左右括号之间即可：\n示例代码\nprint('Hello world!') # Hello world!\n在后续的课程中，你将学习更多关于 Python 中的字符串和函数的知识。现在，你可以把字符串理解为被单引号（’）或双引号（“）包围的一系列字符。\n在 print('Hello world!') 这个例子中，字符串 'Hello world!' 就是传递给 print 函数的一个参数。你也可以使用 print 函数一次性显示多个值（或参数），只需用逗号将它们分隔开即可。例如：\n示例代码\nprint('My favorite colors are', 'blue', 'green', 'red')\n输出结果：My favorite colors are blue green red\n当你用逗号分隔各个元素时，Python 会自动在它们之间添加一个空格。当你想把几条信息一起打印出来时，这非常有用。\n\n\n2.2.3 Python中常见的数据类型有哪些？如何获取变量的类型？\n在使用 Python 变量之前，了解数据类型非常重要。数据类型描述了变量所持有的值的种类。例如，一个数字、一段文本或一个元素列表。编程语言使用数据类型以便知道如何存储和处理不同类型的信息。\nPython 是一种像 JavaScript 一样的动态类型语言，这意味着你不需要显式地为变量声明类型。语言会根据你分配给它的值来判断它是什么数据类型。\n这里有一些例子：\n示例代码\nname = 'John Doe' # Python 知道这是一个字符串\nage = 25 # Python 知道这是一个整数\n这与一些静态类型语言（如 C#、Java 和 C++）形成对比，在这些语言中，你必须在声明变量时指定类型，像这样：\n示例代码\nstring name = 'John Doe'\nint age = 25\nPython 的动态类型特性使得编码速度非常快且更加灵活，但它也可能导致意想不到的错误，因为类型错误只有在程序运行时才会被检测到，而不是在编译时。\n由于 Python 是在你的程序运行时确定数据类型的，所以类型相关的错误只有在那时才会被发现。当程序运行时，Python 会逐行执行你的代码。如果它到达了一行，发现某个对象被期望以一种它无法做到的方式行事，Python 就会停止并显示一个错误。\n相比之下，有些语言在运行前会先编译你的程序。编译意味着计算机会提前检查你的代码并准备运行它。在这个步骤中，那些语言可以在程序甚至开始运行之前就捕获类型错误。\n你暂时不需要了解那些语言。重要的概念很简单：\n\n在 Python 中，类型错误可能在执行期间暴露出来，也就是程序实际运行并使用你的代码时。\n编译型语言则在编译步骤（即程序被允许运行之前）捕获类型错误。\n\n正因为如此，你可能要等到程序在运行时到达那特定的一行代码，才会发现 Python 中的类型错误。\n以下是您在 Python 中将要使用的一些最常见的数据类型：\n整数 (Integer): 没有小数的整数，例如 10 或 -5。\n示例代码\nmy_integer_var = 10\nprint('Integer:', my_integer_var) # Integer: 10\n浮点数 (Float): 带有小数点的数字，比如 4.41 或 -0.4。\n示例代码\nmy_float_var = 4.50\nprint('Float:', my_float_var) # Float: 4.5\n字符串 (String): 用单引号或双引号括起来的一系列字符，比如 ‘Hello world!’。\n示例代码\nmy_string_var = 'hello'\nprint('String:', my_string_var) # String: hello\n布尔值 (Boolean): 布尔类型，即 True 或 False。\n示例代码\nmy_boolean_var = True\nprint('Boolean:', my_boolean_var) # Boolean: True\n集合 (Set): 无序的唯一元素集合，比如 {4, 2, 0}。\n示例代码\nmy_set_var = {7, 5, 8}\nprint('Set:', my_set_var) # Set: {7, 5, 8}\n字典 (Dictionary): 用花括号括起来的键值对集合，比如 {‘name’: ‘John Doe’, ‘age’: 28}。\n示例代码\nmy_dictionary_var = {'name': 'Alice', 'age': 25}\nprint('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}\n元组 (Tuple): 不可变的有序集合，用括号括起来，比如 (7, 8, 4)。\n示例代码\nmy_tuple_var = (7, 5, 8)\nprint('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)\n范围 (Range): 一个数字序列，常用于循环中，例如 range(5)。\n示例代码\nmy_range_var = range(5)\nprint('Range:', my_range_var) # Range: range(0, 5)\n列表 (List): 支持不同数据类型的有序元素集合。\n示例代码\nmy_list = [22, 'Hello world', 3.14, True]\nprint(my_list) # [22, 'Hello world', 3.14, True]\n空值 (None): 代表没有值的特殊值。\n示例代码\nmy_none_var = None\nprint('None:', my_none_var) # None: None\n要获取变量的数据类型，你可以使用 type() 函数：\n示例代码\nmy_var_1 = 'Hello world'\nmy_var_2 = 21\n\nprint(type(my_var_1)) # &lt;class 'str'&gt;\nprint(type (my_var_2)) # &lt;class 'int'&gt;\n以下是本课涵盖的所有数据类型以及它们在终端中显示的类型：\n示例代码\nmy_integer_var = 10\nprint(type(my_integer_var))  # &lt;class 'int'&gt;\n\nmy_float_var = 4.50\nprint(type(my_float_var))  # &lt;class 'float'&gt;\n\nmy_string_var = 'hello'\nprint(type(my_string_var))  # &lt;class 'str'&gt;\n\nmy_boolean_var = True\nprint(type(my_boolean_var))  # &lt;class 'bool'&gt;\n\nmy_set_var = {7, 5, 8}\nprint(type(my_set_var))  # &lt;class 'set'&gt;\n\nmy_dictionary_var = {'name': 'Alice', 'age': 25}\nprint(type(my_dictionary_var))  # &lt;class 'dict'&gt;\n\nmy_tuple_var = (7, 5, 8)\nprint(type(my_tuple_var))  # &lt;class 'tuple'&gt;\n\nmy_range_var = range(5)\nprint(type(my_range_var))  # &lt;class 'range'&gt;\n\nmy_list = [22, 'Hello world', 3.14, True]\nprint(type(my_list)) # &lt;class 'list'&gt;\n\nmy_none_var = None\nprint(type(my_none_var))  # &lt;class 'NoneType'&gt;\n内置的 isinstance() 函数允许你检查变量是否匹配特定的数据类型。它接收一个对象和你想要检查的类型，然后返回一个布尔值。这里有一些例子：\n示例代码\nisinstance('Hello world', str) # True\nisinstance(True, bool) # True\nisinstance(42, int) # True\nisinstance('John Doe', int) # False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#字符串strings简介",
    "href": "cp_1.html#字符串strings简介",
    "title": "2  Python基础",
    "section": "2.3 字符串（Strings）简介",
    "text": "2.3 字符串（Strings）简介\n\n2.3.1 什么是字符串？什么是字符串的不可变性？\n字符串是由单引号或双引号包围的一系列字符。在某些编程语言中，被单引号包围的字符与被双引号包围的字符处理方式不同，但在 Python 中，它们被视为相等的。因此，在处理字符串时，你可以任选其一。以下是一些字符串的例子：\n示例代码\nmy_str_1 = 'Hello'\nmy_str_2 = \"World\"\n如果你需要一个多行字符串，可以使用三个双引号或三个单引号：\n示例代码\nmy_str_3 = \"\"\"Multiline\nstring\"\"\"\nmy_str_4 = '''Another\nmultiline\nstring'''\n如果你的字符串包含单引号或双引号，那么你有两个选择：\n\n使用相反类型的引号。也就是说，如果你的字符串包含单引号，请使用双引号来包裹字符串，反之亦然：\n示例代码\n\nmsg = \"It's a sunny day\"\nquote = 'She said, \"Hello World!\"'\n\n使用反斜杠（\\）对字符串中的单引号或双引号进行转义。使用此方法，你可以任选单引号或双引号来包裹字符串本身：\n示例代码\n\nmsg = 'It\\'s a sunny day'\nquote = \"She said, \\\"Hello!\\\"\"\n有时，你可能需要检查一个字符串是否包含一个或多个字符。为此，Python 提供了 in 运算符，它返回一个布尔值，指明该字符或字符序列是否存在于字符串中。以下是一些例子：\n示例代码\nmy_str = 'Hello world'\n\nprint('Hello' in my_str)  # True\nprint('hey' in my_str)    # False\nprint('hi' in my_str)     # False\nprint('e' in my_str)      # True\nprint('f' in my_str)      # False\n现在，让我们看看如何获取字符串的长度以及如何处理字符串中的单个字符，这个过程称为索引（indexing）。要获取字符串的长度，可以使用内置的 len() 函数。以下是一个例子：\n示例代码\nmy_str = 'Hello world'\nprint(len(my_str))  # 11\n字符串中的每个字符都有一个位置，称为索引。索引是基于零的，这意味着字符串的第一个字符的索引是 0，第二个字符的索引是 1，以此类推。要通过索引访问字符，你使用方括号（[]），并在其中放入你想访问的字符的索引。以下是一些例子：\n示例代码\nmy_str = \"Hello world\"\n\nprint(my_str[0])  # H\nprint(my_str[6])  # w\n也支持负数索引，因此你可以使用 -1 获取任何字符串的最后一个字符，使用 -2 获取倒数第二个字符，以此类推：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[-1])  # d\nprint(my_str[-2])  # l\n许多其他编程语言将数据类型广泛地分为基本类型（primitive）或引用类型（reference）。基本类型是简单的且不可变的，意味着一旦声明就不能更改。引用类型可以包含多个值，并且要么是可变的，要么是不可变的。但 Python 并不在这两组之间划出一条严格的界限。相反，所有数据都被视为对象，其中一些对象是不可变的，而另一些是可变的。\n不可变数据类型一旦声明，就无法被修改或更改。你可以将变量重新指向新的东西，这称为重新赋值，但你不能通过添加、删除或替换其任何元素来更改原始对象本身。\n字符串是 Python 中的不可变数据类型。这意味着你可以将一个不同的字符串重新赋值给一个变量：\n示例代码\ngreeting = 'hi'\ngreeting = 'hello'\nprint(greeting) # hello\n但不允许直接修改字符串：\n示例代码\ngreeting = 'hi'\ngreeting[0] = 'H' # TypeError: 'str' object does not support item assignment\nPython 中其他不可变数据类型的例子包括整数（integer）、浮点数（float）、布尔值（boolean）、元组（tuple）和范围（range）。在接下来的课程中，你将逐一了解这些类型。\n\n\n2.3.2 什么是String Concatenation 和 String Interpolation?\n在处理字符串时，你经常会遇到需要将不同文本片段组合在一起的情况。\n在 Python 中，你可以使用加号（+）运算符将多个字符串组合在一起。这个过程被称为字符串拼接（string concatenation）。以下是使用加号运算符拼接两个字符串的方法：\n示例代码\nmy_str_1 = 'Hello'\nmy_str_2 = \"World\"\n\nstr_plus_str = my_str_1 + ' ' + my_str_2\nprint(str_plus_str) # Hello World\n但请注意，这只适用于字符串。如果你试图将字符串与数字拼接，你会得到一个 TypeError（类型错误）：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name + age\nprint(name_and_age) # TypeError: can only concatenate str (not \"int\") to str\n发生这种情况是因为当你拼接它们时，Python 不会自动将其他数据类型（如整数）转换为字符串。Python 要求所有元素在拼接之前都必须是字符串。为了解决这个问题，你可以使用内置的 str() 函数将数字转换为字符串，该函数返回给定对象的字符串表示形式，而不会修改原始对象：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name + str(age)\nprint(name_and_age) # John Doe26\n你也可以使用增强赋值运算符（augmented assignment operator）来进行拼接。它由一个加号和一个等号（+=）表示，可以在一步内同时完成拼接和赋值。以下是它的实际应用：\n示例代码\nname = 'John Doe'\nage = 26\n\nname_and_age = name  # 从名字开始\nname_and_age += str(age)  # 追加年龄（字符串形式）\n\nprint(name_and_age)  # John Doe26\n将变量和表达式插入字符串的过程被称为字符串插值（string interpolation）。Python 有一种名为 f-strings（格式化字符串字面值的缩写）的字符串，它允许你使用简洁且易读的语法来处理插值。\nf-strings 在引号前以 f（小写或大写均可）开头，并允许你将变量或表达式嵌入由大括号（{}）指示的替换字段中。以下是一个例子：\n示例代码\nname = 'John Doe'\nage = 26\nname_and_age = f'My name is {name} and I am {age} years old'\nprint(name_and_age) # My name is John Doe and I am 26 years old\n\nnum1 = 5\nnum2 = 10\nprint(f'The sum of {num1} and {num2} is {num1 + num2}') # The sum of 5 and 10 is 15\n请注意，在插值过程中，你不需要使用 str() 函数来转换非字符串类型。在上面的例子中，age、num1 和 num2 变量的值在底层被自动转换成了字符串。\n\n\n2.3.3 什么是 String Slicing，它是如何工作的?\n在上一课中，你学习了字符串中的每个字符如何通过其索引（从零开始）来识别，并使用方括号表示法进行访问：\n示例代码\nmy_str = \"Hello world\"\n\nprint(my_str[0])  # H\nprint(my_str[6])  # w\nprint(my_str[-1]) # d\n字符串切片（String slicing）让你可以提取字符串的一部分，或者只处理其中特定的部分。以下是基本语法：\n示例代码\nstring[start:stop]\n如果你想从某个特定索引提取到另一个索引，只需用冒号分隔起始和结束索引即可：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[1:4]) # ell\n请注意，结束索引是不包含的，因此 [1:4] 只提取了从索引 1 开始，一直到（但不包含）索引 4 的字符。\n你也可以省略起始或结束索引，Python 会默认分别从 0 或字符串末尾开始。例如，如果你省略起始索引：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[:7])  # Hello w\n这将提取从索引 0 开始，一直到（但不包含）索引 7 的所有内容。如果你省略结束索引，情况如下：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[8:])  # rld\n这将提取从索引 8 的字符开始，直到字符串末尾的所有内容。\n请注意，切片字符串不会修改原始字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[8:])  # rld\nprint(my_str)  # Hello world\n你也可以同时省略起始和结束索引，这将提取整个字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[:])  # Hello world\n除了起始和结束索引外，还有一个可选的步长（step）参数，用于指定切片中每个索引之间的增量。\n其语法如下：\n示例代码\nstring[start:stop:step]\n在下面的例子中，切片从索引 0 开始，到 11 之前结束，并每隔一个字符提取一次（即每第二个字符）：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[0:11:2])  # Hlowrd\n利用步长参数，一个很有用的技巧是将步长设为 -1，并留空起始和结束索引，从而反转字符串：\n示例代码\nmy_str = 'Hello world'\nprint(my_str[::-1]) # dlrow olleH\n\n\n2.3.4 常见字符串方法?\nPython 提供了许多内置方法，让处理字符串变得轻而易举。这些方法包括但不限于以下内容：\n\nupper(): 返回一个新字符串，其中所有字符都转换为大写。\n示例代码\n\nmy_str = 'hello world'\n\nuppercase_my_str = my_str.upper()\nprint(uppercase_my_str)  # HELLO WORLD\n\nlower(): 返回一个新字符串，其中所有字符都转换为小写。\n示例代码\n\nmy_str = 'Hello World'\n\nlowercase_my_str = my_str.lower()\nprint(lowercase_my_str)  # hello world\n\nstrip(): 返回一个新字符串，其中移除了指定的首尾字符。如果不传递参数，则移除首尾的空白字符（如空格、换行符等）。\n示例代码\n\nmy_str = '  hello world  '\n\ntrimmed_my_str = my_str.strip()\nprint(trimmed_my_str)  # \"hello world\"\n\nreplace(old, new): 返回一个新字符串，其中所有 old 的出现都被替换为 new。\n示例代码\n\nmy_str = 'hello world'\n\nreplaced_my_str = my_str.replace('hello', 'hi')\nprint(replaced_my_str)  # hi world\n\nsplit(separator): 根据指定的分隔符将字符串拆分为一个字符串列表。如果没有指定分隔符，则根据空白字符进行拆分。\n示例代码\n\nmy_str = 'hello world'\n\nsplit_words = my_str.split()\nprint(split_words)  # ['hello', 'world']\n\njoin(iterable): 将可迭代对象的元素用指定的字符串连接成一个新字符串。\n示例代码\n\nmy_list = ['hello', 'world']\n\njoined_my_str = ' '.join(my_list)\nprint(joined_my_str)  # hello world\n\nstartswith(prefix): 返回一个布尔值，指示字符串是否以指定的前缀开头。\n示例代码\n\nmy_str = 'hello world'\n\nstarts_with_hello = my_str.startswith('hello')\nprint(starts_with_hello)  # True\n\nendswith(suffix): 返回一个布尔值，指示字符串是否以指定的后缀结尾。\n示例代码\n\nmy_str = 'hello world'\n\nends_with_world = my_str.endswith('world')\nprint(ends_with_world)  # True\n\nfind(substring): 返回子字符串第一次出现的索引，如果未找到则返回 -1。\n示例代码\n\nmy_str = 'hello world'\n\nworld_index = my_str.find('world')\nprint(world_index)  # 6\n\ncount(substring): 返回子字符串在字符串中出现的次数。\n示例代码\n\nmy_str = 'hello world'\n\no_count = my_str.count('o')\nprint(o_count)  # 2\n\ncapitalize(): 返回一个新字符串，其中首字母大写，其余字母小写。\n示例代码\n\nmy_str = 'hello world'\n\ncapitalized_my_str = my_str.capitalize()\nprint(capitalized_my_str)  # Hello world\n\nisupper(): 如果字符串中的所有字母都是大写，则返回 True，否则返回 False。\n示例代码\n\nmy_str = 'hello world'\n\nis_all_upper = my_str.isupper()\nprint(is_all_upper)  # False\n\nislower(): 如果字符串中的所有字母都是小写，则返回 True，否则返回 False。\n示例代码\n\nmy_str = 'hello world'\n\nis_all_lower = my_str.islower()\nprint(is_all_lower)  # True\n\ntitle(): 返回一个新字符串，其中每个单词的首字母都大写。\n示例代码\n\nmy_str = 'hello world'\n\ntitle_case_my_str = my_str.title()\nprint(title_case_my_str)  # Hello World",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#数字与数学运算",
    "href": "cp_1.html#数字与数学运算",
    "title": "2  Python基础",
    "section": "2.4 数字与数学运算",
    "text": "2.4 数字与数学运算\n\n2.4.1 如何使用整数与浮点数？\n整数和浮点数是 Python 中主要的数值数据类型。使用它们，你可以存储数值数据并执行数学运算。\n让我们来看看什么是整数和浮点数，如何用它们进行算术计算，以及 Python 提供的用于处理这两种类型的一些方法。\n整数 (Integers) 是没有小数点的整数，可以是正数或负数：\n示例代码\nmy_int_1 = 56\nmy_int_2 = -4\n\nprint(type(my_int_1)) # &lt;class 'int'&gt;\nprint(type(my_int_2)) # &lt;class 'int'&gt;\n以下是使用整数执行加法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nsum_ints = my_int_1 + my_int_2\nprint('Integer Addition:', sum_ints) # Integer Addition: 68\n以下是使用整数执行减法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\n# Subtraction\ndiff_ints = my_int_1 - my_int_2\nprint('Integer Subtraction:', diff_ints) # Integer Subtraction: 44\n以下是使用整数执行乘法运算的方法：\n示例代码\nmy_int_1 = 12\nmy_int_2 = 4\n\n# Multiplication\nproduct_ints = my_int_1 * my_int_2\nprint('Integer Multiplication:', product_ints) # Integer Multiplication: 48\n以下是使用整数执行除法运算的方法：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\n# Division\ndiv_ints = my_int_1 / my_int_2\nprint('Integer Division:', div_ints) # Integer Division: 4.666666666666667\n浮点数 (Floats) 是带有小数点的正数或负数，例如 3.14、-0.5 或 0.0。\n示例代码\nmy_float_1 = -12.0\nmy_float_2 = 4.9\n\nprint(type(my_float_1)) # &lt;class 'float'&gt;\nprint(type(my_float_2)) # &lt;class 'float'&gt;\n以下是使用浮点数执行加法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_addition = my_float_1 + my_float_2\nprint('Float Addition:', float_addition) # Float Addition: 17.4\n以下是使用浮点数执行减法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_subtraction = my_float_2 - my_float_1\nprint('Float Subtraction:', float_subtraction) # Float Subtraction: 6.6\n以下是使用浮点数执行乘法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_multiplication = my_float_2 * my_float_1\nprint('Float Multiplication:', float_multiplication) # Float Multiplication: 64.80000000000001\n以下是使用浮点数执行除法运算的方法：\n示例代码\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloat_division = my_float_2 / my_float_1\nprint('Float Division:', float_division) # Float Division: 2.222222222222222\n如果你将一个整数和一个浮点数相加，结果会自动转换为浮点数：\n示例代码\nmy_int = 56\nmy_float = 5.4\n\nsum_int_and_float = my_int + my_float\n\nprint(sum_int_and_float) # 61.4\nprint(type(sum_int_and_float)) # &lt;class 'float'&gt;\n对于其他基本算术运算也是如此，比如减法、乘法和除法。如果你混合使用整数和浮点数，Python 将返回一个浮点数作为结果。\n你也可以执行更复杂的算术计算，例如使用取模运算符获取两个数的余数、向下取整除法以及使用整数和浮点数进行幂运算。\n取模运算符 (%) 返回左边的值除以右边的值时的余数：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nmod_ints = my_int_1 % my_int_2\nmod_floats = my_float_2 % my_float_1\n\nprint('Integer Modulus:', mod_ints) # Integer Modulus: 8\nprint('Float Modulus:', mod_floats) # Float Modulus: 1.1999999999999993\n向下取整除法 (Floor division) 将两个数相除并返回小于或等于结果的最大整数。这是通过双正斜杠运算符 (//) 完成的：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nfloor_div_ints = my_int_1 // my_int_2\nfloor_div_floats = my_float_2 // my_float_1\n\nprint('Integer Floor Division:', floor_div_ints) # Integer Floor Division: 4\nprint('Float Floor Division:', floor_div_floats) # Float Floor Division: 2.0\n幂运算 (Exponentiation) 将一个数提升为另一个数的幂，使用双星号运算符 (**) 完成：\n示例代码\nmy_int_1 = 56\nmy_int_2 = 12\n\nmy_float_1 = 5.4\nmy_float_2 = 12.0\n\nexp_ints = my_int_1 ** my_int_2\nexp_floats = my_float_1 ** my_float_2\n\nprint('Integer Exponentiation:', exp_ints) # Integer Exponentiation: 951166013805414055936\nprint('Float Exponentiation:',  exp_floats) # Float Exponentiation: 614787626.1765089\nPython 还提供了内置函数，用于将数值数据或字符串转换为整数或浮点数。\nfloat() 函数返回从给定数字构造的浮点数：\n示例代码\nmy_int_1 = 56\nmy_float_1 = float(my_int_1)\n\nprint(my_float_1)  # 56.0\nprint(type(my_float_1))  # &lt;class 'float'&gt;\nint() 函数返回从给定数字构造的整数：\n示例代码\nmy_float = 12.92563\nmy_int = int(my_float)\n\nprint(my_int)  # 12\nprint(type(my_int))  # &lt;class 'int'&gt;\n此外，你可以使用相同的内置函数将字符串转换为浮点数或整数：\n示例代码\nmy_str_int = '45'\nmy_str_float = '7.8'\n\nconverted_int = int(my_str_int)\nconverted_float = float(my_str_float)\n\nprint(converted_int, type(converted_int))  # 45 &lt;class 'int'&gt;\nprint(converted_float, type(converted_float))  # 7.8 &lt;class 'float'&gt;\n以下是 Python 提供的用于处理整数和浮点数的其他一些方法。\nround(): 将数字四舍五入到指定的小数位数。默认情况下，此函数四舍五入到最接近的整数，并返回一个没有小数位的整数：\n示例代码\nmy_int_1 = 4.798\nmy_int_2 = 4.253\n\nrounded_int_1 = round(my_int_1)\nrounded_int_2 = round(my_int_2, 1)\n\nprint(rounded_int_1) # 5\nprint(rounded_int_2) # 4.3\nabs(): 返回数字的绝对值，\n示例代码\nnum = -15\n\nabsolute_value = abs(num)\nprint(absolute_value) # 15\npow(): 将一个数提升为另一个数的幂，或执行模幂运算。\n示例代码\nresult_1 = pow(2, 3)  # Equivalent to 2 ** 3\nprint(result_1)  # 8\n\nresult_2 = pow(2, 3, 5)  # (2 ** 3) % 5\nprint(result_2)  # 3\n\n\n2.4.2 Augmented Assignments是如何工作的?\n增强赋值（Augmented assignment）将二元运算和赋值合并为一个步骤。它接收一个变量，将其与另一个值进行运算，并将结果存回同一个变量中。\n如果你熟悉 JavaScript 等语言，你可能听说过加法赋值运算符（+=）、减法赋值（-=）等。这些在 Python 中也存在。唯一的区别是，在 Python 中它们被称为增强赋值（augmented assignments）。\n增强赋值的基本语法如下：\n示例代码\nvariable &lt;operator&gt;= value\n这比下面这种写法更高效：\n示例代码\nvariable = variable &lt;operator&gt; value\n例如，以下是如何使用增强赋值将 5 加到现有变量中的例子：\n示例代码\nmy_var = 10\nmy_var += 5\n\nprint(my_var) # 15\n下面是不使用增强赋值的同样操作：\n示例代码\nmy_var = 10\nmy_var = my_var + 5\n\nprint(my_var) # 15\n增强赋值的优势在于，它提供了一种简洁且易读的方式来更新变量值，而无需重复变量名。这样一来，它减少了冗余，并避免了因打字错误之类的问题而可能产生的错误。\n每个运算符都可以使用增强赋值。我们已经看过了加法赋值运算符（+=），让我们来看看其他的。\n减法赋值运算符 (-=) 用左变量减去右操作数，并将差值存回左变量：\n示例代码\ncount = 14\ncount -= 3\n\nprint(count) # 11\n乘法赋值运算符 (*=) 将左变量乘以右操作数，并将乘积存回左变量：\n示例代码\nproduct = 65\nproduct *= 7\n\nprint(product) # 455\n除法赋值运算符 (/=) 用左变量除以右操作数，并将结果存回左变量：\n示例代码\nprice = 100\nprice /= 4\n\nprint(price) # 25.0\n向下取整除法运算符 (//=) 将左变量向下取整除以右操作数，并将结果存回左变量：\n示例代码\ntotal_pages = 23\ntotal_pages //= 5\n\nprint(total_pages) # 4\n取模赋值运算符 (%=) 计算左变量除以右操作数的余数，并将其存回左变量：\n示例代码\nbits = 35\nbits %= 2\n\nprint(bits) # 1\n幂赋值运算符 (**=) 将左变量提升为右操作数的幂，并将结果存回左变量：\n示例代码\npower = 2\npower **= 3\n\nprint(power) # 8\n你也可以对字符串使用一些增强赋值运算符。例如，加法赋值运算符可以轻松地拼接字符串：\n示例代码\ngreet = 'Hello'\ngreet += ' World'\n\nprint(greet) # Hello World\n乘法赋值运算符可以用来重复一个字符串：\n示例代码\ngreet = 'Hello'\ngreet *= 3\n\nprint(greet) # HelloHelloHello\n其他增强赋值运算符与字符串一起使用时会抛出 TypeError（类型错误）：\n示例代码\ngreet = 'Hello'\ngreet -= ' World'\n\nprint(greet) # TypeError: unsupported operand type(s) for -=: 'str' and 'str'\n示例代码\ngreet = 'Hello'\ngreet /= 'World'\n\nprint(greet) # TypeError: unsupported operand type(s) for /=: 'str' and 'str'\n如果你想知道自增和自减运算符（++ 和 --）在 Python 中是否有效，答案是无效的。这是因为 Python 故意避免了 C 风格的自增和自减快捷方式，以便保持语言的清晰和明确。\n你可以简单地写 x += 1 来代替 x++，这清楚地表明你将变量 x 的值增加了 1。\n在 Python 中编写 ++x 只是两次应用了一元加号，而不会对任何东西进行自增：\n示例代码\nmy_var = 5\n\nprint(+my_var)   # 5\nprint(++my_var)  # 5\nprint(+++my_var) # 5\n\nmy_var += 1\n\nprint(my_var) # 6",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#布尔值与条件语句",
    "href": "cp_1.html#布尔值与条件语句",
    "title": "2  Python基础",
    "section": "2.5 布尔值与条件语句",
    "text": "2.5 布尔值与条件语句\n\n2.5.1 条件语句和逻辑运算符是如何工作的？\n条件语句（Conditionals）让你可以根据特定条件是真还是假来控制程序的流程。\n但在深入探讨所有这些之前，让我们先回顾一下条件语句的基本构成要素，从比较运算符开始。比较运算符允许你比较两个或多个值，并返回一个布尔值。\n在上一课中，你了解到布尔值（Booleans）是 Python 中的一种数据类型，其值只能是 True 或 False。\n以下是 Python 中比较运算符的表格：\n\n\n\n运算符\n名称\n描述\n\n\n\n\n==\n等于\n检查两个值是否相等\n\n\n!=\n不等于\n检查两个值是否不相等\n\n\n&gt;\n大于\n检查左侧的值是否大于右侧的值\n\n\n&lt;\n小于\n检查左侧的值是否小于右侧的值\n\n\n&gt;=\n大于或等于\n检查左侧的值是否大于或等于右侧的值\n\n\n&lt;=\n小于或等于\n检查左侧的值是否小于或等于右侧的值\n\n\n\n以下是其中一些表达式，它们的值为 True 或 False：\n示例代码\nprint(3 &gt; 4) # False\nprint(3 &lt; 4) # True\nprint(3 == 4) # False\nprint(4 == 4) # True\nprint(3 != 4) # True\nprint(3 &gt;= 4) # False\nprint(3 &lt;= 4) # True\n这些运算符可以在条件语句中用来比较值，并根据条件语句的真假来运行特定的代码。\n在 Python 中，最基本的条件语句是 if 语句。其基本语法如下：\n示例代码\nif condition:\n    pass # 如果条件为 True，则执行这里的代码\n\nif 语句以 if 关键字开头。\ncondition 是一个表达式，其值为 True 或 False，后面跟着一个冒号 (:)。\nif 语句的主体构成一个代码块，即一组属于在一起的语句。在 Python 中，缩进级别定义了代码块。\n在上面的例子中，if 语句的主体包含一个 pass 语句。当执行 pass 语句时，什么也不会发生。这是一个特殊的关键字，可以用作未来代码的占位符，当不允许出现空代码块时，它非常有用。\n\n只有当条件为 True 时，if 语句内的代码才会运行。例如：\n示例代码\nage = 18\n\nif age &gt;= 18:\n    print('You are an adult') # You are an adult\n请注意 print('You are an adult') 前面的缩进。虽然其他编程语言使用花括号等字符来定义代码块，仅将缩进用于提高可读性，但在 Python 中，代码块是由缩进决定的。\n以下代码将引发 IndentationError（缩进错误），这是 Python 指出在代码的某处需要缩进的方式：\n示例代码\nage = 18\n\nif age &gt;= 18:\nprint('You are an adult') # IndentationError: expected an indented block after 'if' statement on line 3\n尽管你可以使用任意数量的空格（只要你保持一致）来确定每一级缩进，但 Python 风格指南建议使用四个空格。\n代码块也出现在循环和函数中，你将在以后的课程中学习到它们。\n回到我们的例子，如果 age 小于 18，终端中将不会打印任何内容：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult') # 终端中不会显示任何内容\n但是，如果你想在 age 小于 18 时也打印一些内容怎么办？这就是 else 子句的用处。当 if 条件为假时，else 子句就会运行。以下是 if...else 语句的语法：\n示例代码\nif condition:\n   pass # 如果条件为 True，则执行这里的代码\nelse:\n   pass # 如果条件为 False，则执行这里的代码\n例如：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult')\nelse:\n    print('You are not an adult yet') # You are not an adult yet\n在某些情况下，你可能需要考虑多个条件。为此，Python 允许你使用 elif（else if 的缩写）关键字来扩展你的 if 语句。\n其语法如下：\n示例代码\nif condition:\n   pass # 如果条件为 True，则执行这里的代码\nelif condition2:\n   pass # 如果条件2为 True，则执行这里的代码\nelse:\n   pass # 如果所有条件都为 False，则执行这里的代码\n例如：\n示例代码\nage = 12\n\nif age &gt;= 18:\n    print('You are an adult')\nelif age &gt;= 13:\n    print('You are a teenager')\nelse:\n    print('You are a child') # You are a child\n请注意，你可以根据需要使用任意数量的 elif 语句：\n示例代码\nage = 2\n\nif age &gt;= 65:\n    print('You are a senior citizen')\nelif age &gt;= 30:\n    print('You are an adult in your prime')\nelif age &gt;= 18:\n    print('You are a young adult')\nelif age &gt;= 13:\n    print('You are a teenager')\nelif age &gt;= 3:\n    print('You are a young child')\nelse:\n    print('You are a toddler or an infant') # You are a toddler or an infant\n现在你已经了解了 Python 中的比较运算符和条件语句是如何工作的，你可以开始编写基于逻辑和输入做出决策的程序了。无论你是比较值还是通过多个条件进行分支，这些工具都是编写灵活、响应式代码的基础。\n\n\n2.5.2 什么是 Truthy 和 Falsy 值？布尔运算符与短路求值是如何工作的？\n在上一课中，你学习了如何使用比较运算符和条件语句来控制程序的流程。\n虽然这些功能非常强大，但你经常会遇到需要同时比较多个值的情况。这可能会导致嵌套的条件语句，例如：\n示例代码\nis_citizen = True\nage = 25\n\nif is_citizen:\n    if age &gt;= 18:\n        print('You are eligible to vote') # You are eligible to vote\nelse:\n    print('You are not eligible to vote')\n上面的例子将首先检查 is_citizen 是否为 True。如果是，它将进入嵌套的 if 语句并检查 age 是否大于或等于 18。由于 age 大于或等于 18，打印到终端的消息将是 “You are eligible to vote”。如果 is_citizen 为 False，那么打印到终端的消息将是 “You are not eligible to vote”。\n如果你正在处理更复杂的条件语句，那么你可以使用 Python 的 and、or 和 not 运算符。\n但在深入研究这些运算符之前，让我们先看看什么是“真值（truthy）”和“假值（falsy）”。\n在 Python 中，每个值都有一个固有的布尔值，即在逻辑上下文中它应该被视为 True 还是 False 的内置判断。许多值被认为是“真值”，也就是说，它们在逻辑上下文中会被求值为 True。其他的则是“假值”，意味着它们会被求值为 False。\n以下是几个“假值”的例子：\n\nNone\nFalse\n整数 0\n浮点数 0.0\n空字符串 “”\n\n其他值，如非零数字和非空字符串，都是“真值”。\n如果你想检查一个值是“真值”还是“假值”，你可以使用内置的 bool() 函数。它显式地将一个值转换为其布尔等价物，并为“真值”返回 True，为“假值”返回 False。以下是几个例子：\n示例代码\nprint(bool(False)) # False\nprint(bool(0))  # False\nprint(bool('')) # False\n\nprint(bool(True)) # True\nprint(bool(1)) # True\nprint(bool('Hello')) # True\n现在你理解了“真值”和“假值”，我们可以来看看布尔运算符，它们也被称为逻辑运算符。这些是特殊的运算符，允许你组合多个表达式，从而在代码中创建更复杂的决策逻辑。\nPython 中有三个布尔运算符：and、or 和 not。\n让我们先看看 and 运算符。\nand 运算符接受两个操作数，如果第一个操作数是“假值”，则返回第一个操作数，否则返回第二个操作数。为了让一个表达式的结果为“真值”，两个操作数都必须是“真值”。\n这是一个例子：\n示例代码\nis_citizen = True\nage = 25\n\nprint(is_citizen and age) # 25\n在上面的例子中，数字 25 被打印到终端，因为如果第一个操作数为 True，and 运算符将求值第二个操作数。and 运算符被称为“短路运算符”。短路意味着 Python 从左到右检查值，并在确定最终结果后立即停止。\n\n之所以叫“短路（short circuit）”，是因为这个概念来自电子学里的“短路”隐喻。在正常情况下，电流应该按照设计好的完整路径流过所有元件，但一旦发生短路，电流就会绕过中间本该经过的部分，走一条更短的路径，后面的元件因此不会再被通电。逻辑运算里的短路也是同样的意思。一个逻辑表达式本来可以理解为要依次计算所有部分，但在实际执行时，Python 会从左到右判断，一旦发现当前结果已经足以确定整个表达式的最终结果，就会立刻返回，不再继续计算后面的部分。这样一来，后面的表达式就被“绕过”了，执行路径被提前截断，就像电流走了捷径一样。因此，“短路”这个名字强调的不是简单的“提前停止”，而是原本存在的一条完整执行路径被缩短、被切断了，这正是短路求值这个机制的核心含义。\n\n你经常会在 if 语句中使用 and 来检查是否满足多个条件。以下是将前面的例子重构为使用 and 运算符而不是嵌套 if 语句的方法：\n示例代码\nis_citizen = True\nage = 25\n\nif is_citizen and age &gt;= 18:\n    print('You are eligible to vote') # You are eligible to vote\nelse:\n    print('You are not eligible to vote')\n在上面的例子中，is_citizen 为 True，且 age &gt;= 18 求值为 True。由于 and 运算符的两个操作数都是“真值”，因此条件 is_citizen and age &gt;= 18 求值为 True，并执行 if 块中的打印调用。\n现在让我们看看 or 运算符。这个运算符如果第一个操作数是“真值”，则返回第一个操作数，否则返回第二个操作数。如果至少有一个操作数是“真值”，那么 or 表达式的结果就是“真值”。or 运算符也是一个“短路运算符”。这是一个例子：\n示例代码\nage = 19\nis_employed = False\n\nprint(age or is_employed) # 19\n下面的代码将打印数字 19，因为第一个操作数 age 是 True。\n如果你需要检查一个或多个表达式是否为 True，那么你可以在条件语句中使用 or 运算符，像这样：\n示例代码\nage = 19\nis_student = True\n\nif age &lt; 18 or is_student:\n    print('You are eligible for a student discount') # You are eligible for a student discount\nelse:\n    print('You are not eligible for a student discount')\n在这种情况下，age &lt; 18 是 False，但 is_student 是 True。由于至少有一个条件为真，整个 or 表达式求值为 True，并打印 if 块中的折扣信息。\n我们将要学习的最后一个运算符是 not 运算符，它接受一个操作数并反转其布尔值。它将“真值”转换为 False，将“假值”转换为 True。与我们之前看过的运算符不同，not 总是返回 True 或 False。\n以下是几个例子：\n示例代码\nprint(not '') # True, 因为空字符串是假值\nprint(not 'Hello') # False, 因为非空字符串是真值\nprint(not 0) # True, 因为 0 是假值\nprint(not 1) # False, 因为 1 是真值\nprint(not False) # True, 因为 False 是假值\nprint(not True) # False, 因为 True 是真值\n在条件语句中使用 not 运算符来检查某事是否为“非 True”或“非 False”是很常见的，像这样：\n示例代码\nis_admin = False\n\nif not is_admin:\n    print('Access denied for non-administrators.') # Access denied for non-administrators.\nelse:\n    print('Welcome, Administrator!')\n由于 is_admin 为 False，那么 not is_admin 就是在说“非 False”，即 True。所以消息 “Access denied for non-administrators.” 将被打印。\n现在你理解了“真值”和“假值”、and、or 和 not 运算符以及短路的工作原理，你就可以编写更灵活、更易读的条件逻辑了。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_1.html#理解函数与作用域",
    "href": "cp_1.html#理解函数与作用域",
    "title": "2  Python基础",
    "section": "2.6 理解函数与作用域",
    "text": "2.6 理解函数与作用域\n\n2.6.1 Python 中的函数是如何工作的？\n函数是可重复使用的代码块，当你调用它们时它们就会运行。许多编程语言都带有内置函数，这让入门变得更加容易。Python 也不例外，在之前的课程中我们已经介绍过一些内置函数，比如 print()。\n另一个有用的内置函数是 input()，它让你可以提示用户输入内容：\n示例代码\nname = input('What is your name?') # 用户输入 \"Kolade\" 并按下回车\nprint('Hello', name) # 输出: Hello Kolade\n另一方面，int() 可以将数字、布尔值和数值字符串转换为整数：\n示例代码\nprint(int(3.14)) # 3\nprint(int('42')) # 42\nprint(int(True)) # 1\nprint(int(False)) # 0\n你也可以编写自己的自定义函数。要做到这一点，你使用 def 关键字，后跟你想要给函数起的名字、一对括号和一个冒号。然后在新的一行，你编写函数应该运行的代码。函数运行的代码也被称为函数的主体（body）。\n这是一个名为 hello 的自定义函数的例子，它在终端打印字符串 “Hello World”：\n示例代码\ndef hello():\n    print('Hello World')\n要运行这个函数，你需要通过其名称后跟一对括号来调用它：\n示例代码\nhello() # Hello World\n请注意 print('Hello World') 前面的缩进。正如你可能从之前的课程中回忆起来的，Python 依靠缩进来确定哪些语句组属于在一起。这些语句组被称为代码块。\n这里是另一个简单的函数，它在终端打印两个数字的和：\n示例代码\ndef calculate_sum(a, b):\n    print(a + b)\n你可以看到，我们的函数 calculate_sum 在括号中有 a 和 b，它们由逗号分隔。这些被称为参数。将参数视为充当“槽位”的占位符变量，用于存放你调用函数时传入的值。\n要使用这些参数，你必须传入“实参”。实参是你在调用函数时传递给函数的值。\n这是如何调用 calculate_sum 函数来将数字 3 和 1 相加的例子：\n示例代码\ncalculate_sum(3, 1) # 4\n如果你没有传递正确数量的实参就调用函数，你会得到一个 TypeError（类型错误）：\n示例代码\ncalculate_sum()\n\n# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'\n函数还使用一个特殊的 return（返回）关键字来退出函数并返回一个值。如果你没有显式地使用 return，Python 将默认返回 None。\n这是一个例子：\n示例代码\ndef calculate_sum(a, b):\n    print(a + b)\n\nmy_sum = calculate_sum(3, 1) # 4\nprint(my_sum) # None\n你可以看到 calculate_sum 函数打印了 a 和 b 的和，但它没有显式地返回任何东西。所以当我们将其结果赋值给 my_sum 时，该值实际上是 None。为了解决这个问题，你可以使用 return 关键字来发送回结果：\n示例代码\ndef calculate_sum(a, b):\n    return a + b\n\nmy_sum = calculate_sum(3, 1)\nprint(my_sum) # 4\n现在，calculate_sum 返回了 a 和 b 的和，该和被存储在 my_sum 中。\n\n\n2.6.2 什么是 Python 中的作用域？它是如何起作用的？\n在 Python 中，作用域（Scope）决定了你可以在代码的哪个位置访问一个变量。它控制着变量的生命周期，以及 Python 在代码的不同部分如何解析该变量。\n为了正确确定作用域，Python 遵循 LEGB 规则，其含义如下：\n\nL - 局部作用域 (Local scope)：在函数或类内部定义的变量。\nE - 闭合作用域 (Enclosing scope)：在嵌套函数（封闭函数）内部定义的变量。\nG - 全局作用域 (Global scope)：在模块或文件的顶层定义的变量。\nB - 内置作用域 (Built-in scope)：Python 预定义的函数、模块、关键字和对象等保留名称。\n\nPython 使用 LEGB 规则来解析程序中变量的作用域。我们将深入探讨每一个规则，以便你更好地理解这个过程。\n局部作用域意味着在函数或类内部声明的变量只能在该函数或类内部被访问。\n这是一个例子：\n示例代码\ndef my_func():\n    my_var = 10\n    print(my_var)\n在这种情况下，my_func 函数拥有它自己的作用域，该作用域无法从函数外部访问。调用 my_func 将输出 10，但在函数外部打印 my_var 会导致 NameError（名称错误）：\n示例代码\ndef my_func():\n    my_var = 10 # 在 my_func 内部局部作用域\n    print(my_var)\n\nmy_func() # 10\n\nprint(my_var) # NameError: name 'my_var' is not defined\n闭合作用域意味着一个嵌套在另一个函数内部的函数可以访问它所嵌套的外部函数的变量。\n例如：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n\n    def inner_func():\n        print(msg)\n\n    inner_func()\n\nouter_func() # Hello there!\n在这个例子中，内部函数 inner_func 可以自由地访问在外部函数 outer_func 中定义的 msg 变量。但是，请注意外部函数无法访问在任何嵌套函数内部定义的变量：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n    print(res) # 尝试访问尚未定义的 res\n\n    def inner_func():\n        res = 'How are you?'\n        print(msg)\n\n    inner_func()\n\nouter_func() # NameError: name 'res' is not defined\n这是因为 res 是在 inner_func 内部局部作用域的。另外，请注意 outer_func 尝试在调用 inner_func 之前打印 res。\n一个解决方案是在闭合作用域（即 outer_func 内部）将 res 初始化为空字符串。然后在 inner_func 内部，使用 nonlocal 关键字将 res 声明为非局部变量：\n示例代码\ndef outer_func():\n    msg = 'Hello there!'\n    res = \"\"  # 在闭合作用域中声明 res\n\n    def inner_func():\n        nonlocal res  # 允许修改闭合作用域中的变量\n        res = 'How are you?'\n        print(msg)  # 访问 outer_func() 中的 msg\n\n    inner_func()\n    print(res)  # 现在 res 可以被访问且已被修改\n\nouter_func()\n\n# 输出:\n# Hello there!\n# How are you?\n全局作用域指的是在任何函数或类外部声明的变量，这些变量可以从程序的任何地方被访问。在这里，my_var 可以在任何地方被访问，即使是在它没有被定义的函数内部：\n示例代码\nmy_var = 100\n\ndef show_var():\n    print(my_var)\n\nshow_var() # 100\nprint(my_var) # 100\n如果你想让你在函数内部定义的局部变量在全局范围内可访问，你可以使用 global 关键字：\n示例代码\nmy_var_1 = 7\n\ndef show_vars():\n    global my_var_2\n    my_var_2 = 10\n    print(my_var_1)\n    print(my_var_2)\n\nshow_vars() # 7 10\n\n# my_var_2 现在是一个全局变量，可以在程序的任何地方被访问\nprint(my_var_2) # 10\n你也可以使用 global 关键字来修改一个全局变量：\n示例代码\nmy_var = 10  # 一个全局变量\n\ndef change_var():\n    global my_var  # 允许修改全局变量\n    my_var = 20\n\nchange_var()\n\nprint(my_var)  # my_var 现在被全局修改为 20\n最后，内置作用域指的是 Python 所有的内置函数、模块和关键字，它们在程序的任何地方都可用：\n示例代码\nprint(str(45)) # '45'\nprint(type(3.14)) # &lt;class 'float'&gt;\nprint(isinstance(3, str)) # False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python基础</span>"
    ]
  },
  {
    "objectID": "cp_10.html",
    "href": "cp_10.html",
    "title": "11  动态规划",
    "section": "",
    "text": "11.1 理解动态规划（Dynamic Programming）",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>动态规划</span>"
    ]
  },
  {
    "objectID": "cp_10.html#understanding-dynamic-programming",
    "href": "cp_10.html#understanding-dynamic-programming",
    "title": "11  动态规划",
    "section": "",
    "text": "11.1.1 What Is Dynamic Programming and What Are Some Common Algorithms?\n动态规划是一种算法技术，它通过将复杂问题分解为更简单的子问题并存储结果以避免重复计算来解决问题。这种方法将通常需要指数时间的问题转化为可以在多项式时间内解决的问题。\n动态规划的核心原则\n当一个问题中存在两个关键条件时，动态规划就有效。\n\n重叠子问题：在解决较大问题时，相同的较小问题会多次出现。与其反复重新计算这些子问题，不如存储它们的解。\n最优子结构：问题的最优解包含其子问题的最优解。这意味着我们可以通过组合较小部分的最优解来构建最佳解。\n\n让我们使用经典的“爬楼梯”问题来考察这些概念。\n朴素递归的问题\n考虑爬楼梯问题：你正在爬一个有 n 级台阶的楼梯，每次可以爬 1 级或 2 级。有多少种不同的方式可以到达顶部？\n示例代码\ndef climb_stairs_recursive(n):\n    \"\"\"递归方法\"\"\"\n    if n &lt;= 2:\n        return n  # 基本情况：1 级台阶有 1 种方式，2 级台阶有 2 种方式\n    # 要到达第 n 级台阶，我们可以从第 (n-1) 级或第 (n-2) 级上来\n    return climb_stairs_recursive(n-1) + climb_stairs_recursive(n-2)\n由于大量重复计算，这种实现具有指数级时间复杂度。在计算climb_stairs(5)时，会发生以下情况：\nclimb_stairs(5)调用 climb_stairs(4)和 climb_stairs(3)\nclimb_stairs(4) 调用 climb_stairs(3) 和climb_stairs(2)\n现在 climb_stairs(3) 被计算了两次\nclimb_stairs(3) 调用 climb_stairs(2) 和 climb_stairs(1)\nclimb_stairs(2) 总共被计算了 3 次\n仅对于 n=5，我们就进行了 9 次函数调用，而实际上只需要 5 次唯一计算。随着 n 增大，这种冗余呈指数级爆炸——climb_stairs(30) 将需要超过 10 亿次函数调用！时间复杂度变为 O(2^n)，对于较大的 n 值来说效率低下且不切实际。\n动态规划解决方案\n动态规划通过两种主要方法消除这种冗余计算：\n记忆化（Memoization，自顶向下方法）\n记忆化存储昂贵函数调用的结果，并在再次出现相同输入时返回缓存结果：\n示例代码\ndef climb_stairs_memo(n, memo={}):\n    \"\"\"带记忆化的动态规划\"\"\"\n    # 检查是否已计算过该值\n    if n in memo:\n        return memo[n]  # 返回缓存结果 - O(1) 查找！\n\n    # 基本情况\n    if n &lt;= 2:\n        return n\n\n    # 计算一次并存储在 memo 中供将来使用\n    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)\n    return memo[n]\n记忆化之所以高效得多，是因为从 1 到 n 的每个唯一值只计算一次。当我们再次需要 climb_stairs(3) 时，不再重新计算（这会触发更多递归调用），而是简单地在 memo 字典中以 O(1) 时间查找。\n让我们追踪使用自顶向下方法执行 climb_stairs(5) 的过程，看看记忆化如何消除冗余工作：\n示例代码\nCall: climb_stairs_memo(5)\n  memo = {} (空)\n\n  Call: climb_stairs_memo(4) \n    memo = {} (空)\n\n    Call: climb_stairs_memo(3)\n      memo = {} (空)\n\n      Call: climb_stairs_memo(2) → 返回 2 (基本情况)\n      Call: climb_stairs_memo(1) → 返回 1 (基本情况)\n\n      Result: 2 + 1 = 3\n      memo = {3: 3} (已存储!)\n\n    Call: climb_stairs_memo(2) → 返回 2 (基本情况)\n\n    Result: 3 + 2 = 5\n    memo = {3: 3, 4: 5} (已存储!)\n\n  Call: climb_stairs_memo(3) → 返回 3 (来自 MEMO - 无递归!)\n\n  Result: 5 + 3 = 8\n  memo = {3: 3, 4: 5, 5: 8}\n效率比较\n朴素递归：进行 9 次函数调用，包含重复计算\n记忆化：仅进行 5 次唯一计算，然后复用存储的结果\n时间复杂度：从 O(2^n) 降低到 O(n)，因为我们只进行 n 次唯一计算\n空间复杂度：O(n)，用于 memo 存储和调用栈\n实际影响：climb_stairs(30) 从 10 亿多次调用减少到仅 30 次调用！\n表格法（自底向上方法）\n表格法从底层开始构建解，用子问题的解填充一张表：\n示例代码\ndef climb_stairs_tabulation(n):\n    \"\"\"带表格法的动态规划\"\"\"\n    if n &lt;= 2:\n        return n\n\n    # 创建数组以存储从 0 到 n 所有台阶的结果\n    dp = [0] * (n + 1)\n    dp[1] = 1  # 到达第 1 级台阶有 1 种方式\n    dp[2] = 2  # 到达第 2 级台阶有 2 种方式\n\n    # 迭代构建解\n    for i in range(3, n + 1):\n        # 到达第 i 级台阶的方式数 = 到达 (i-1) 的方式数 + 到达 (i-2) 的方式数\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n表格法通过从最小的子问题开始迭代构建解，完全消除了递归。\n让我们看看自底向上方法的实际运行过程，了解我们如何系统地构建解。以下是 climb_stairs(5) 的迭代构建过程：\n示例代码\n初始状态：\ndp = [0, 1, 2, 0, 0, 0]\n     [0, 1, 2, 3, 4, 5] ← 索引（台阶编号）\n\n逐步构建：\n\ni = 3:\n  dp[3] = dp[2] + dp[1] = 2 + 1 = 3\n  dp = [0, 1, 2, 3, 0, 0]\n\ni = 4:\n  dp[4] = dp[3] + dp[2] = 3 + 2 = 5\n  dp = [0, 1, 2, 3, 5, 0]\n\ni = 5:\n  dp[5] = dp[4] + dp[3] = 5 + 3 = 8\n  dp = [0, 1, 2, 3, 5, 8]\n\n最终结果：dp[5] = 8\n表格法的主要优势\n无递归开销：与记忆化不同，没有递归调用栈。\n可预测的执行：我们按预定顺序（1, 2, 3, 4, 5…）计算值。\n缓存友好：顺序数组访问优化了内存使用。\n易于优化：由于我们只需要最后两个值，可以将空间复杂度降低到 O(1)。\n示例代码\ndef climb_stairs_optimized(n):\n    if n &lt;= 2:\n        return n\n\n    prev2, prev1 = 1, 2  # 仅存储最后两个值\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2, prev1 = prev1, current\n    return prev1\n效率比较\n朴素递归：n=5 时进行 9 次函数调用，呈指数增长。\n表格法：n=5 时进行 3 次简单加法，呈线性增长。\n时间复杂度：O(n)而不是 O(2^n)。\n空间复杂度：使用数组时为 O(n)，优化后为 O(1)。\n性能可预测：对于大输入没有栈溢出风险。\n两种方法都将时间复杂度从指数级 O(2^n) 降低到线性 O(n)，这是一个巨大的改进，使得解决问题的时间从毫秒级变为对于较大输入等待数年之间的区别。\n实际应用\n动态规划在计算机科学及更广泛领域有广泛应用：\n路线优化：GPS 系统使用动态规划算法查找地点之间的最短路径。\n文本处理：拼写检查器和自动补全功能经常依赖动态规划来计算单词之间的编辑距离。\n金融建模：投资策略和投资组合优化经常采用动态规划技术。\n资源分配：背包问题及其变体出现在调度、预算和资源管理中。\n实际示例：硬币找零问题\n硬币找零问题是一个经典编程挑战，当使用动态规划解决时，展示了动态规划的两个关键原则：最优子结构和重叠子问题。\n硬币找零问题问：“组成目标金额所需的最少硬币数量是多少？”\n以下是使用动态规划的一种解决方案：\n示例代码\ndef min_coins(amount, coins):\n    \"\"\"查找组成给定金额所需的最少硬币数量\"\"\"\n    # 用“无穷大”初始化 dp 数组 - 表示无法组成\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 基本情况：金额 0 需要 0 枚硬币\n\n    # 对于从 1 到目标金额的每个金额\n    for i in range(1, amount + 1):\n        # 尝试每种硬币面额\n        for coin in coins:\n            if coin &lt;= i:  # 只有当硬币不超过当前金额时才能使用\n                # 更新最小值：当前最小值 vs (剩余金额所需硬币数 + 1)\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    # 如果可能则返回结果，否则返回 -1\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n# 示例用法：\n# coins = [1, 3, 4], amount = 6\n# dp[6] = min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3+1, 1+1, 2+1) = 2\n# 结果：2 枚硬币 (3 + 3)\n\n不关心前面怎么选，只假设最后一枚硬币是什么；一旦最后一枚确定，问题就退化为一个已经解决过的更小金额的问题。\n\n以下是动态规划硬币找零算法对 coins = [1, 3, 4], amount = 6 的逐步工作过程：\n示例代码\n初始状态：\ndp = [0, ∞, ∞, ∞, ∞, ∞, ∞]\n     [0, 1, 2, 3, 4, 5, 6] ← 金额\n\n逐步构建解：\n\n对于金额 = 1：\n  尝试硬币 1：dp[1] = min(∞, dp[0] + 1) = min(∞, 0 + 1) = 1\n  dp = [0, 1, ∞, ∞, ∞, ∞, ∞]\n\n对于金额 = 2：\n  尝试硬币 1：dp[2] = min(∞, dp[1] + 1) = min(∞, 1 + 1) = 2\n  dp = [0, 1, 2, ∞, ∞, ∞, ∞]\n\n对于金额 = 3：\n  尝试硬币 1：dp[3] = min(∞, dp[2] + 1) = min(∞, 2 + 1) = 3\n  尝试硬币 3：dp[3] = min(3, dp[0] + 1) = min(3, 0 + 1) = 1\n  dp = [0, 1, 2, 1, ∞, ∞, ∞]\n\n对于金额 = 4：\n  尝试硬币 1：dp[4] = min(∞, dp[3] + 1) = min(∞, 1 + 1) = 2\n  尝试硬币 3：dp[4] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2\n  尝试硬币 4：dp[4] = min(2, dp[0] + 1) = min(2, 0 + 1) = 1\n  dp = [0, 1, 2, 1, 1, ∞, ∞]\n\n对于金额 = 5：\n  尝试硬币 1：dp[5] = min(∞, dp[4] + 1) = min(∞, 1 + 1) = 2\n  尝试硬币 3：dp[5] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2\n  尝试硬币 4：dp[5] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2\n  dp = [0, 1, 2, 1, 1, 2, ∞]\n\n对于金额 = 6：\n  尝试硬币 1：dp[6] = min(∞, dp[5] + 1) = min(∞, 2 + 1) = 3\n  尝试硬币 3：dp[6] = min(3, dp[3] + 1) = min(3, 1 + 1) = 2\n  尝试硬币 4：dp[6] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2\n  dp = [0, 1, 2, 1, 1, 2, 2]\n\n最终结果：dp[6] = 2 (通过硬币 3 + 3 实现)\n此解决方案展示了动态规划的两个关键原则。它具有重叠子问题，因为找到金额 6 的最少硬币数需要知道金额 5、3 和 2 的解。这些相同的子问题在计算其他金额时也会出现。它具有最优子结构，因为任何金额的最优解都包含较小金额的最优解。如果我们知道金额 3 的最少硬币数是 1，那么组成金额 6 的一种方式就是使用该解再加上一枚面值为 3 的硬币。\n没有动态规划，我们需要尝试硬币的每种可能组合——可能性数量呈指数级增长。有了动态规划，我们系统地构建解：\n时间复杂度：O(金额 × 硬币数量) 而不是指数级。\n空间复杂度：O(金额) 用于 dp 数组。\n无冗余工作：每个子问题（为每个金额找到最少硬币数）只解决一次。\n可重用结果：一旦我们知道金额 3 的最少硬币数，我们就将这一知识用于所有能从中受益的更大金额。\n何时使用动态规划\n当满足以下条件时，动态规划是有效的：\n问题可以分解为重叠子问题。\n问题表现出最优子结构。\n朴素递归解决方案会涉及重复计算。\n你需要以空间复杂度为代价来优化时间复杂度。\n常见的动态规划模式包括优化问题（寻找最小/最大值）、计数问题（达成某目标的方式数量）以及可以分解为更小决策的决策问题。\n动态规划通过系统地存储和重用子问题的解，将复杂问题转化为可管理的问题。理解这一技术为高效解决各种计算挑战打开了大门。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>动态规划</span>"
    ]
  },
  {
    "objectID": "cp_2.html#处理循环loops和序列sequences",
    "href": "cp_2.html#处理循环loops和序列sequences",
    "title": "3  循环和序列",
    "section": "",
    "text": "3.1.1 列表（Lists）是什么？它们是如何工作的？\n在接下来的几节课中，我们将学习列表（lists）、元组（tuples）和范围（ranges），这是 Python 中使用的三种基本序列类型。\n列表（list）数据类型是由元素组成的有序序列，它可以包含字符串、数字，甚至其他列表。列表是可变的（mutable），并使用从零开始的索引（zero-based indexing），这意味着列表的第一个元素位于索引 0 处。\n以下是列表的基本语法：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\n要访问 cities 列表中的元素，你可以引用它在序列中的索引号。以下是访问 cities 列表第一个元素的例子：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\ncities[0] # 'Los Angeles'\n负索引（Negative indexing）用于从列表的末尾开始访问元素，而不是从索引 0 开始。要访问任何列表的最后一个元素，你可以像这样使用 -1：\n示例代码\ncities = ['Los Angeles', 'London', 'Tokyo']\ncities[-1] # 'Tokyo'\n创建列表的另一种方法是使用 list() 构造函数。list() 构造函数用于将一个可迭代对象转换为列表，像这样：\n示例代码\ndeveloper = 'Jessica'\nlist(developer) # ['J', 'e', 's', 's', 'i', 'c', 'a']\n可迭代对象（iterable）是一种特殊的对象类型，它可以一次循环遍历一个项目。你将在以后学习 Python 循环时了解更多相关内容。\n要获取列表中元素的总数，你可以使用 len() 函数，像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nlen(numbers) # 5\n如果你想更新特定索引处的值，你可以这样做：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\nprogramming_languages[0] = 'JavaScript'\nprint(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']\n由于列表是可变的，只要你传入一个有效的索引号，你就可以更新列表中的任何元素。如果你传入一个超出列表范围的索引（无论是正数还是负数），你将会收到一个 IndexError（索引错误）：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\nprogramming_languages[10] = 'JavaScript'\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nIndexError: list assignment index out of range\n\"\"\"\n如果你想从列表中删除一个元素，你可以使用 del 关键字，像这样：\n示例代码\ndeveloper = ['Jane Doe', 23, 'Python Developer']\ndel developer[1]\nprint(developer) # ['Jane Doe', 'Python Developer']\n有时检查一个元素是否在列表中会很有帮助。要做到这一点，你可以使用 in 关键字，像这样：\n示例代码\nprogramming_languages = ['Python', 'Java', 'C++', 'Rust']\n\n'Rust' in programming_languages # True\n'JavaScript' in programming_languages # False\n有时在一个列表中包含其他列表是很常见的，像这样：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\n在这个例子中，我们有一个嵌套列表，包含三种流行的编程语言。要访问这个嵌套列表，你需要使用索引 2 来访问它，因为列表是零索引的：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\ndeveloper[2] # ['Python', 'Rust', 'C++']\n然后要访问该嵌套列表中的第二种语言，你需要像这样使用索引 1：\n示例代码\ndeveloper = ['Alice', 25, ['Python', 'Rust', 'C++']]\ndeveloper[2][1] # 'Rust'\n列表的另一个常用技术是解包值（unpacking values）。\n从列表中解包值是一种将列表中的值分配给新变量的技术。以下是将一个 developer 列表解包为名为 name、age 和 job 的新变量的例子。\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, age, job = developer\n\nprint(name) # 'Alice'\nprint(age) # 34\nprint(job) # 'Rust Developer'\n在这里，name 的值是 ‘Alice’，age 的值是 34，job 的值是 ‘Rust Developer’。\n如果你需要收集列表中的任何剩余元素，你可以使用星号（*）操作符，像这样：\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, *rest = developer\n\nprint(name) # 'Alice'\nprint(rest) # [34, 'Rust Developer']\n在这个例子中，name 仍然有值 ‘Alice’，而 rest 是一个包含两个项目的列表：数字 34 和字符串 ‘Rust Developer’。\n如果赋值运算符左侧的变量数量与列表中的项目总数不匹配，你将会收到一个 ValueError（值错误）：\n示例代码\ndeveloper = ['Alice', 34, 'Rust Developer']\nname, age, job, city = developer\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError: not enough values to unpack (expected 4, got 3)\n\"\"\"\n我们将要学习的最后一个概念是切片操作符（slice operator）（:）。与字符串类似，你可以使用切片操作符来访问列表的一部分，像这样：\n示例代码\ndesserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie', 'Brownies']\ndesserts[1:4] # ['Cookies', 'Ice Cream', 'Pie']\n在这个例子中，起始索引是 1，因为它指向列表中的第二项。然后我们使用切片操作符，后跟一个结束索引 4，它包括从起始索引到（但不包括）该索引处的项目的所有内容。\n你可以用切片操作符（:）做的另一件事是指定一个步长间隔（step interval），它确定索引之间的增量。假设你有一个像这样的数字列表：\n示例代码\nnumbers = [1, 2, 3, 4, 5, 6]\n如果你想提取一个只包含偶数的列表，你可以像这样使用切片操作符：\n示例代码\nnumbers = [1, 2, 3, 4, 5, 6]\nnumbers[1::2] # [2, 4, 6]\n第一个偶数位于索引 1，所以那将是起始索引。由于我们想要遍历到列表的末尾，所以我们省略了结束索引。最后，我们为可选的步长间隔指定了 2，因此它只会以 2 为增量递增，而不是默认的 1。\n列表是一种非常有用且灵活的数据结构，你将在 Python 程序中大量使用它。在下一课中，你将学习可以与列表一起使用的常见方法。\n\n\n3.1.2 列表中有哪些常用的方法？\n在上一课中，你接触了列表（list）数据类型，并学习了如何访问列表中的元素以及列表切片。在本课中，你将继续学习关于列表的知识，以及与其相关的一些常见方法，如 append()、pop() 和 sort()。\n我们将要学习的第一个方法是 append() 方法。它用于将一个项目添加到列表的末尾。以下是使用 append() 方法将数字 6 添加到数字列表中的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.append(6)\nprint(numbers) # [1, 2, 3, 4, 5, 6]\n如果你想将一个列表添加到另一个列表的末尾，也可以像这样使用 append() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [6, 8, 10]\n\nnumbers.append(even_numbers)\nprint(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]\n请注意，整个 even_numbers 列表是如何作为嵌套列表被放入 numbers 列表中的。\n但是，如果你想将 even_numbers 列表中的所有单个数字添加到 numbers 列表的末尾，那么你可以使用 extend() 方法。\nextend() 方法与 append() 方法类似，但使用 extend() 你可以将一个列表中的多个元素添加到另一个列表中。以下是将数字 6、8 和 10 从一个列表添加到 numbers 列表末尾的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = [6, 8, 10]\n\nnumbers.extend(even_numbers)\nprint(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]\n正如你所见，嵌套列表消失了，现在它只是一个单纯的数字列表。\n要在列表的特定索引处插入一个元素，你可以使用 insert() 方法。该方法接受两个参数：你希望插入新项目的索引位置，以及你想要插入的项目。\n以下是使用 insert() 方法的例子：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.insert(2, 2.5)\n\nprint(numbers) # [1, 2, 2.5, 3, 4, 5]\n以下代码将把数字 2.5 插入到 numbers 列表的索引 2 处。\n如果你想从列表中移除一个元素，你可以使用 remove() 方法。remove() 方法将要移除的元素值作为参数：\n示例代码\nnumbers = [10, 20, 30, 40, 50, 50]\nnumbers.remove(50)\n\nprint(numbers) # [10, 20, 30, 40, 50]\n需要注意的是，此方法只会移除该项目的第一次出现，而不是全部：\n示例代码\nnumbers = [10, 20, 30, 40, 50, 50, 50]\nnumbers.remove(50)\n\nprint(numbers) # [10, 20, 30, 40, 50, 50]\n要移除列表中特定索引处的元素，你可以像这样使用 pop() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.pop(1) # 返回数字 2\n如果你没有为 pop 方法指定索引，那么它将移除最后一个元素。\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.pop() # 返回数字 5\n如果你需要清空列表，那么你可以像这样使用 clear() 方法：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nnumbers.clear()\n\nprint(numbers) # []\n我们将要学习的下一个方法是 sort() 方法。此方法用于对列表进行原地排序（in place）。以下是原地排序一个随机数字列表的例子：\n示例代码\nnumbers = [19, 2, 35, 1, 67, 41]\nnumbers.sort()\n\nprint(numbers) # [1, 2, 19, 35, 41, 67]\n与 sort() 方法相反，有一个 sorted() 函数，它可以用于任何可迭代对象，并返回一个新的已排序列表，而不是修改原始列表。例如：\n示例代码\nnumbers = [19, 2, 35, 1, 67, 41]\nsorted_numbers = sorted(numbers)\n\nprint(numbers) # [19, 2, 35, 1, 67, 41]\nprint(sorted_numbers) # [1, 2, 19, 35, 41, 67]\n提醒一下，可迭代对象（iterable）是一种特殊类型的对象，你可以循环遍历它，从而一次访问一个项目。你将在以后的课程中学习更多关于 Python 循环的知识。\nsort() 方法和 sorted() 函数都接受可选的 key 和 reverse 参数。当你学习元组时，将在以后的课程中了解更多关于这些可选参数的知识。你也将学习更多关于 sorted() 等其他内置函数的知识。\n我们将要学习的下一个方法是 reverse() 方法。此方法将原地反转列表中的元素，像这样：\n示例代码\nnumbers = [6, 5, 4, 3, 2, 1]\nnumbers.reverse()\n\nprint(numbers) # [1, 2, 3, 4, 5, 6]\n我们将要学习的最后一个方法是 index 方法。它用于查找列表中某个元素第一次出现的索引。以下是使用 index 方法在 programming_languages 列表中查找语言 ‘Java’ 的例子：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\nprogramming_languages.index('Java') # 1\n如果找不到该元素，Python 将抛出 ValueError：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\nprogramming_languages.index('JavaScript')\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: 'JavaScript' is not in list\n\"\"\"\nPython 列表还有一些其他方法，但这个初始方法列表是一个很好的开始。\n\n\n3.1.3 元组（Tuples）是什么？它们是如何工作的？\n元组（tuple）是一种 Python 数据类型，用于创建一个有序的值序列。元组可以包含一组混合的数据类型，像这样：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\n元组与列表类似，但列表是可变数据类型，而元组是不可变的。这意味着一旦元组被创建，其中的元素就不能被更改。\n如果你试图更新元组中的某一项，你会得到一个 TypeError（类型错误）：\n示例代码\nprogramming_languages = ('Python', 'Java', 'C++', 'Rust')\nprogramming_languages[0] = 'JavaScript'\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n\"\"\"\n要访问元组中的元素，你可以使用方括号表示法和索引号：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\ndeveloper[1] # 34\n如果你需要从元组的末尾开始访问元素，你可以使用负索引。以下是使用负索引访问元组中倒数第二个元素的例子：\n示例代码\nnumbers = (1, 2, 3, 4, 5)\nnumbers[-2] # 4\n如果你传入的索引号超出了元组的长度（即索引越界），你会收到一个 IndexError（索引错误），像这样：\n示例代码\nnumbers = (1, 2, 3, 4, 5)\nnumbers[7]\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nIndexError: tuple index out of range\n\"\"\"\n创建元组的另一种方法是使用 tuple() 构造函数，像这样：\n示例代码\ndeveloper = 'Jessica'\ntuple(developer) # ('J', 'e', 's', 's', 'i', 'c', 'a')\n对于 tuple() 构造函数，你可以传入不同的可迭代对象，如字符串、列表甚至其他元组。\n要检查某项是否在元组中，你可以使用 in 关键字，像这样：\n示例代码\nprogramming_languages = ('Python', 'Java', 'C++', 'Rust')\n\n'Rust' in programming_languages # True\n'JavaScript' in programming_languages # False\n你也可以像对列表那样，对元组进行解包（unpacking）操作：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\nname, age, job = developer\n\nprint(name) # 'Alice'\nprint(age) # 34\nprint(job) # 'Rust Developer'\n在这个例子中，name 的值是 ‘Alice’，age 的值是 34，job 的值是 ‘Rust Developer’。\n如果你需要收集元组中的任何剩余元素，你可以使用星号（*）操作符，像这样：\n示例代码\ndeveloper = ('Alice', 34, 'Rust Developer')\nname, *rest = developer\n\nprint(name) # 'Alice'\nprint(rest) # [34, 'Rust Developer']\n在这里，name 的值是 ‘Alice’，而 rest 是一个包含数字 34 和字符串 ‘Rust Developer’ 的列表。\n就像对列表一样，你可以在元组上使用切片操作符来提取其中的一部分。以下是将 ‘pie’ 和 ‘cookies’ 提取到一个新元组中的例子：\n示例代码\ndesserts = ('cake', 'pie', 'cookies', 'ice cream')\ndesserts[1:3] # ('pie', 'cookies')\n请记住，第一个数字表示提取的起始索引，第二个数字表示结束索引。但请注意，结束索引处的项目不包含在提取的新元组中。\n如果你想从元组中删除一个项目，那是不可能的，因为元组是不可变的。所以这个例子会产生一个错误：\n示例代码\ndeveloper = ('Jane Doe', 23, 'Python Developer')\ndel developer[1]\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: \"tuple\" object doesn't support item deletion\n\"\"\"\n那么，什么时候应该使用元组而不是列表呢？\n如果你需要一个动态的元素集合，其中可以添加、删除和更新元素，那么你应该使用列表。如果你知道你正在处理一组固定且不可变的数据，那么你应该使用元组。\n在下一课中，我们将看看处理元组时会使用的一些常见方法。\n\n\n3.1.4 元组中有哪些常用的方法？\n在上一课中，你学习了如何使用元组（tuple）数据类型。在本课中，你将学习处理元组时会使用的一些常见方法。\n我们将要介绍的第一个方法是 count()。此方法用于确定某项在元组中出现了多少次。以下是检查名为 programming_languages 的元组中字符串 “Rust” 出现了多少次的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count('Rust') # 2\n由于 Rust 在元组中出现了两次，count() 方法返回数字 2。如果 count() 函数中指定的项在元组中完全不存在，则返回值为 0：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count('JavaScript') # 0\n如果没有任何参数传入 count() 函数，Python 会引发 TypeError（类型错误）：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.count()\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nTypeError: tuple.count() takes exactly one argument (0 given)\n\"\"\"\n我们将要介绍的下一个方法是 index() 方法。此方法用于查找特定项在元组中的索引位置。以下是使用 index() 方法查找字符串 “Java” 索引的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.index('Java') # 1\n如果找不到指定的项，Python 会引发 ValueError（值错误）：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')\nprogramming_languages.index('JavaScript')\n\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError: tuple.index(x): x not in tuple\n\"\"\"\n使用 index() 方法的另一件事是可以传入可选的起始索引（start）和结束索引（stop）参数。以下是传入可选起始索引的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\nprogramming_languages.index('Python', 3) # 5\n在这个例子中，我们指定了从哪里开始搜索字符串 “Python”。通过将数字 3 作为第二个参数传入 index() 函数，我们指定了从索引 3 开始搜索。由于 “Python” 在元组中出现了两次，index() 函数将返回索引 5 而不是索引 2，这是因为使用了可选的起始索引参数。\n你也可以传入一个可选的结束索引。以下是同时指定起始索引和结束索引的修改示例：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')\nprogramming_languages.index('Python', 2, 5) # 2\n现在结果是索引 2，因为我们从索引 2 开始搜索，并搜索到（但不包括）索引 5。\n与元组一起使用的另一个常用函数是 sorted() 函数。在上一课中，你学习了列表的 sort() 方法。sorted() 函数可以用于任何可迭代对象，包括元组。\n以下是使用 sorted() 函数创建一个新数字列表的例子：\n示例代码\nnumbers = (13, 2, 78, 3, 45, 67, 18, 7)\nsorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]\nsorted() 函数总是会创建一个由排序后值组成的新列表。这与 sort() 方法不同，sort() 方法是在原地对列表元素进行排序，并且不会返回一个新列表。\n如果你需要自定义可迭代对象的排序行为，你可以使用可选的 reverse（反转）和 key（键）参数。以下是使用 key 参数按长度对元组中的项进行排序的例子：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\nsorted(programming_languages, key=len)\n\n# 结果\n# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']\n如果你想创建一个逆序的新值列表，你可以像这样使用 reverse 参数：\n示例代码\nprogramming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')\n\nprint(sorted(programming_languages, reverse=True))\n\n# 结果\n# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']\n元组是 Python 中一种常见的数据类型。理解如何使用它们，以及一些有用的方法和函数，将帮助你编写更高效的代码。\n\n\n3.1.5 循环是如何工作的？\n正如你在之前的模块中学到的，循环用于将一块代码重复执行指定的次数。在本课中，你将学习如何在 Python 中使用不同类型的循环。\n我们将要介绍的第一种循环是 for 循环。以下是使用 for 循环遍历列表并打印每一项到控制台的例子：\n示例代码\nprogramming_languages = ['Rust', 'Java', 'Python', 'C++']\n\nfor language in programming_languages:\n    print(language)\n结果将是：\n示例代码\nRust\nJava\nPython\nC++\n请注意，print(language) 在循环内部是缩进的。如果没有缩进，你会收到一个 IndentationError（缩进错误）：\n示例代码\n\"\"\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 4, in &lt;module&gt;\nIndentationError: expected an indented block after 'for' statement on line 3\n\"\"\"\n你也可以使用 for 循环来遍历其他可迭代对象，比如字符串。以下是使用 for 循环遍历字符串 “code” 并打印每个字符的例子：\n示例代码\nfor char in 'code':\n    print(char)\n结果将是：\n示例代码\nc\no\nd\ne\n就像在 JavaScript 中一样，你也可以在 Python 中嵌套 for 循环。以下是使用嵌套 for 循环的例子：\n示例代码\ncategories = ['Fruit', 'Vegetable']\nfoods = ['Apple', 'Carrot', 'Banana']\n\nfor category in categories:\n    for food in foods:\n        print(category, food)\n外层循环将遍历 categories 列表中的每个类别。对于每个类别，内层循环将遍历 foods 列表中的每种食物。以下是将被打印到控制台的结果：\n示例代码\nFruit Apple\nFruit Carrot\nFruit Banana\nVegetable Apple\nVegetable Carrot\nVegetable Banana\n你可以在 Python 中使用的另一种循环是 while 循环。这种循环将重复执行一块代码，直到条件为 False。以下是使用 while 循环制作猜数字游戏的例子：\n示例代码\nsecret_number = 3\nguess = 0\n\nwhile guess != secret_number:\n    guess = int(input('Guess the number (1-5): '))\n    if guess != secret_number:\n        print('Wrong! Try again.')\n\nprint('You got it!')\n在这个例子中，我们有一个值为 3 的 secret_number 变量和一个初始值为 0 的 guess。然后我们使用 input 函数获取用户的输入，然后使用 int() 函数将输入的字符串转换为整数，并将其赋值给 guess 变量。如果用户通过输入 3 猜对了，while 循环将被跳出，消息 “You got it!” 将被打印到控制台。否则，消息 “Wrong! Try again.” 将被打印到控制台，循环重复，提示用户再次猜测。\n以下是结果的一个例子：\n示例代码\nGuess the number (1-5): 2\nWrong! Try again.\nGuess the number (1-5): 1\nWrong! Try again.\nGuess the number (1-5): 3\nYou got it!\n就像在 JavaScript 中一样，Python 支持 break 和 continue 语句。\nbreak 语句用于停止循环的执行。以下是针对 developer_names 列表使用 break 语句的例子：\n示例代码\ndeveloper_names = ['Jess', 'Naomi', 'Tom']\n\nfor developer in developer_names:\n    if developer == 'Naomi':\n        break\n    print(developer)\n在这个例子中，我们遍历 developer_names 列表并打印每个名字到控制台。如果名字等于 ‘Naomi’，我们就跳出循环。这导致只有名字 ‘Jess’ 被打印到控制台。\ncontinue 语句用于跳过循环的当前迭代，并继续下一个迭代。让我们修改前面的例子，使用 continue 语句代替 break：\n示例代码\ndeveloper_names = ['Jess', 'Naomi', 'Tom']\n\nfor developer in developer_names:\n    if developer == 'Naomi':\n        continue\n    print(developer)\n现在控制台中的结果将不同。名字 ‘Jess’ 和 ‘Tom’ 被打印，因为当 developer 等于 ‘Naomi’ 时，continue 语句跳过了循环的第二次迭代，因此该名字没有被打印到控制台。\nfor 和 while 循环都可以与 else 子句结合使用，该子句仅在循环没有被 break 语句终止时执行。以下是使用多重 for 循环的例子：\n示例代码\nwords = ['sky', 'apple', 'rhythm', 'fly', 'orange']\n\nfor word in words:\n    for letter in word:\n        if letter.lower() in 'aeiou':\n            print(f\"'{word}' contains the vowel '{letter}'\")\n            break\n    else:\n        print(f\"'{word}' has no vowels\")\n在这个例子中，我们有一个随机单词列表，并使用 for 循环遍历每个单词。在外层 for 循环内部，我们有另一个 for 循环来遍历每个单词的每个字母。如果字母的小写版本是元音字母，我们打印单词以及它包含的元音字母，然后跳出内层循环。如果单词不包含元音字母，我们打印一条消息来指示这一点。\n以下是结果在控制台中的样子：\n示例代码\n'sky' has no vowels\n'apple' contains the vowel 'a'\n'rhythm' has no vowels\n'fly' has no vowels\n'orange' contains the vowel 'o'\n循环在 Python 中非常常见，因此熟悉它们非常重要。在接下来的几节课中，你将学习如何在循环中使用 enumerate() 和 range() 函数。\n\n\n3.1.6 什么是范围（range）？如何在循环中使用它？\nrange() 函数用于生成一个整数序列。以下是 range() 函数的基本语法：\n示例代码\nrange(start, stop, step)\n其中必选参数 stop 是一个整数，它代表生成数字序列的终点。以下是使用 range() 函数的例子：\n示例代码\nfor num in range(3):\n    print(num)\n以下代码生成了一个介于 0 和 2 之间的数字序列。整数 3 不包含在内，因为 stop 参数是不包含终点值的（非 inclusive）。\n如果未指定 start 参数，则默认值为 0。否则，你可以使用可选的 start 参数，让整数序列从非 0 的整数开始。以下是生成介于 1 和 4 之间整数序列的例子：\n示例代码\nfor num in range(1, 5):\n    print(num)\n默认情况下，整数序列将以 1 为步长递增。但如果你想更改这个默认值，可以使用可选的 step 参数。以下是生成介于 2 和 10 之间偶数序列的例子：\n示例代码\nfor num in range(2, 11, 2):\n    print(num)\n正如前面提到的，range() 函数只有一个必选参数。如果你不给 range() 传递任何参数，你会得到一个 TypeError：\n示例代码\nERROR!\nTraceback (most recent call last):\n  File \"&lt;main.py&gt;\", line 1, in &lt;module&gt;\nTypeError: range expected at least 1 argument, got 0\n需要注意的是，range() 函数只接受整数作为参数，不接受浮点数。请记住，浮点数是带有小数点的数字，比如 3.4。如果你尝试传递浮点数作为参数，你会得到一个 TypeError：\n示例代码\nERROR!\nTraceback (most recent call last):\n  File \"&lt;main.py&gt;\", line 1, in &lt;module&gt;\nTypeError: 'float' object cannot be interpreted as an integer\n如果你想生成一个按递减顺序排列的整数序列，可以为 step 参数使用负整数，像这样：\n示例代码\nfor num in range(40, 0, -10):\n    print(num)\n以下代码将按顺序在控制台打印数字 40、30、20 和 10。\n使用 range() 函数的另一件事是，你可以将其与列表构造函数（list constructor）结合使用，以创建一个整数列表。列表构造函数用于将一个可迭代对象转换为列表。以下是生成一个介于 2 和 10 之间偶数列表的例子：\n示例代码\nnumbers = list(range(2, 11, 2))\nprint(numbers) # [2, 4, 6, 8, 10]\nrange() 函数是在 Python 中生成整数序列的一种非常方便的方法。一旦你掌握了它，你可能会发现自己在 Python 程序中会频繁使用它。\n\n\n3.1.7 enumerate 和 zip 函数是什么？它们是如何工作的？\n在之前的课程中，你学习了如何使用 for 循环，它用于将一块代码重复执行指定的次数。以下是使用 for 循环将 languages 列表中的每种语言打印到控制台的例子：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor language in languages:\n    print(language)\n但是，如果你想要跟踪每个元素的索引怎么办？一种方法是创建一个索引变量，并在循环的每次迭代中将其加 1，像这样：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nindex = 0\n\nfor language in languages:\n    print(f'Index {index} and language {language}')\n    index += 1\n虽然这样做可行，但更简单的方法是使用 enumerate() 函数。enumerate() 函数会跟踪可迭代对象的索引，并返回一个枚举对象（enumerate object）。\n如果我们把 languages 列表传递给 enumerate() 函数，并使用 list() 函数将其返回值转换为列表，它看起来像这样：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nlist(enumerate(languages))\n#\n枚举对象（现在是一个列表）中的每个条目都是一个元组，其中包含一个计数器（count），后面跟着从传递给 enumerate() 函数的可迭代对象中获取的值。\n现在，让我们重构前面的例子，使用 enumerate() 函数：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor index, language in enumerate(languages):\n    print(f'Index {index} and language {language}')\n我们把枚举对象中每个元组的计数器和值解包（unpack）到分别名为 index 和 language 的变量中。最后，在循环的每次迭代中，这两个变量都被用于一个打印到控制台的 f-string（格式化字符串）中。\n示例代码\nIndex 0 and language Spanish\nIndex 1 and language English\nIndex 2 and language Russian\nIndex 3 and language Chinese\n这样就无需手动创建和更新索引变量了。\nenumerate() 函数还接受一个可选的 start 参数，用于指定计数的起始值。如果省略此参数，则计数将从 0 开始。以下是使用可选 start 参数的例子：\n示例代码\nlanguages = ['Spanish', 'English', 'Russian', 'Chinese']\n\nfor index, language in enumerate(languages, 1):\n    print(f'Index {index} and language {language}')\n以下是结果在控制台中的样子：\n示例代码\nIndex 1 and language Spanish\nIndex 2 and language English\nIndex 3 and language Russian\nIndex 4 and language Chinese\n到目前为止，我们只遍历了一个列表。但是，如果你需要并行地遍历多个可迭代对象怎么办？你可以使用 zip() 函数，它将列表组合成元素对，并返回一个元组迭代器。\n如果我们把一个开发者列表和一个 ID 列表传递给 zip() 函数，并使用 list() 函数将其返回值转换为列表，它看起来像这样：\n示例代码\ndevelopers = ['Naomi', 'Dario', 'Jessica', 'Tom']\nids = [1, 2, 3, 4]\n\nlist(zip(developers, ids))\n#\n以下是一个在 for 循环中使用 zip() 函数遍历开发者和 ID 的例子：\n示例代码\ndevelopers = ['Naomi', 'Dario', 'Jessica', 'Tom']\nids = [1, 2, 3, 4]\n\nfor name, id in zip(developers, ids):\n    print(f'Name: {name}')\n    print(f'ID: {id}')\n在这个例子中，zip() 将两个列表组合成元素对，并返回一个元组迭代器。for 循环然后将每个元组解包为 name 和 id。最后，对于每个打印语句，我们分别从 ids 和 developers 列表中打印每个名字和 ID。以下是结果在控制台中的样子：\n示例代码\nName: Naomi\nID: 1\nName: Dario\nID: 2\nName: Jessica\nID: 3\nName: Tom\nID: 4\nenumerate() 和 zip() 函数功能非常强大，当与循环结合使用时，可以使你的代码更加简洁。\n\n\n3.1.8 什么是列表推导式（List Comprehensions）？有哪些用于处理列表的实用函数？\n在过去的几节课中，你已经习惯了像这样使用循环：\n示例代码\neven_numbers = []\n\nfor num in range(21):\n    if num % 2 == 0:\n        even_numbers.append(num)\n\nprint(even_numbers)\n这个例子创建了一个名为 even_numbers 的新空列表，并遍历 0 到 20 之间的一系列数字。在循环内部，有一个条件判断，检查当前数字除以 2 的余数是否为 0。这用于确定该数字是否为偶数。如果条件为 True，则将当前的 num 添加到 even_numbers 列表的末尾。最后，我们将 even_numbers 列表打印到控制台。\n虽然这段代码可以工作，但有一种更简洁的写法，那就是使用列表推导式（list comprehension）。列表推导式允许你通过将循环和条件直接组合在方括号内，在一行代码中创建一个新列表。这使得代码更短，通常也更易读。\n以下是使用方括号重构后的例子：\n示例代码\neven_numbers = [num for num in range(21) if num % 2 == 0]\nprint(even_numbers)\n在这个重构的例子中，even_numbers 列表是使用单行代码创建的。列表推导式遍历 0 到 20 的数字，并且只包含那些能被 2 整除的数字。这种方法更紧凑，消除了对单独的循环和条件块的需求。\n让我们再看一个例子，以便更好地理解列表推导式是如何工作的：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\nresult = [(num, 'Even') if num % 2 == 0 else (num, 'Odd') for num in numbers]\nprint(result)\n在这个例子中，我们有一个数字列表，并想要创建一个新列表，其中包含指示哪些数字是偶数或奇数的元组。在列表推导式的第一部分，我们使用一个 if 语句来检查数字是否能被 2 整除。如果是，那么结果就是一个包含该数字后跟单词 ‘Even’ 的元组。否则，结果就是一个包含该数字后跟单词 ‘Odd’ 的元组。\n以下是结果打印在控制台中的样子：\n示例代码\n\n从现有可迭代对象创建列表的另一种方法是 filter() 函数。以下是创建一个仅包含超过四个字符的单词的新列表的例子：\n示例代码\nwords = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']\n\ndef is_long_word(word):\n    return len(word) &gt; 4\n\nlong_words = list(filter(is_long_word, words))\nprint(long_words) # ['mountain', 'river', 'cloud']\nfilter() 函数用于从可迭代对象中选择满足特定条件的元素。filter() 函数接受一个函数和一个可迭代对象作为其参数。在这个例子中，我们将一个 is_long_word 函数传递给 filter() 函数，以检查当前单词的长度是否大于 4。所有字符数大于 4 的单词都会被添加到一个新列表中，并赋值给 long_words 变量。\n除了 filter() 函数外，还有一些在处理列表时很有用的函数。另一个需要注意的函数是 map() 函数，它接受一个可迭代对象并将其每个元素都应用一个函数。以下是使用 map() 函数将摄氏度温度列表转换为华氏度的例子：\n示例代码\ncelsius = [0, 10, 20, 30, 40]\n\ndef to_fahrenheit(temp):\n    return (temp * 9/5) + 32\n\nfahrenheit = list(map(to_fahrenheit, celsius))\nprint(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]\n就像 filter() 函数一样，map() 接受一个函数和一个可迭代对象作为其参数。to_fahrenheit 函数接受一个温度值并将其从摄氏度转换为华氏度。\n我们将要介绍的最后一个函数是 sum() 函数。此函数用于获取像列表或元组这样的可迭代对象的总和。以下是使用 sum() 函数的例子：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers)\nprint(total) # 结果: 50\n你也可以传入一个可选的 start 参数，它设置求和的初始值。以下是使用 start 参数作为位置参数的更新示例：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers, 10) # 位置参数\nprint(total) # 60\n你也可以选择将 start 参数用作关键字参数，像这样：\n示例代码\nnumbers = [5, 10, 15, 20]\ntotal = sum(numbers, start=10) # 关键字参数\nprint(total) # 60\n这两个版本将产生相同的结果，但关键字参数的写法更明确一些。\n列表推导式以及像 map()、filter() 和 sum() 这样的其他函数一开始可能看起来有点令人困惑。但通过足够的练习和时间，你会开始在 Python 程序中使用它们时感到更加得心应手。\n\n\n3.1.9 什么是 lambda 函数？它们是如何工作的？\n在之前的课程中，你已经习惯了使用 def 关键字来定义函数，就像这样：\n示例代码\ndef square(num):\n    return num ** 2\n\nprint(square(4)) # 16\n但是，当涉及到像 map() 和 filter() 这样的高阶函数时，你可以使用匿名的内联函数。这就用到了 lambda 函数。\n以下是将 square() 函数重构为 lambda 函数后的样子：\n示例代码\nlambda num: num ** 2\n正如前面提到的，lambda 函数是匿名的，所以这个函数不再有 square 这个名字与之关联。当你需要在高阶函数中使用它们时，lambda 函数非常有用，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # [2, 4]\n在这个例子中，我们有一个数字列表，并想要创建一个只包含偶数的新列表。所以我们把一个 lambda 函数作为参数之一传递给 filter() 函数，以获取包含数字 2 和 4 的新列表。\n在使用 lambda 函数时，需要注意最佳实践。例如，将 lambda 函数赋值给一个变量并不是一个好的做法，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\nsquare = lambda x: x ** 2\nsquared_numbers = list(map(square, numbers))\nprint(squared_numbers) # [1, 4, 9, 16, 25]\n这样做违背了使用匿名函数的初衷。在这种情况下，你应该使用一个普通的函数，就像这样：\n示例代码\nnumbers = [1, 2, 3, 4, 5]\n\ndef square(num):\n    return num ** 2\n\nsquared_numbers = list(map(square, numbers))\nprint(squared_numbers) # [1, 4, 9, 16, 25]\n此外，你应该避免创建难以阅读或不必要地复杂的 lambda 函数，就像这样：\n示例代码\nresult = (lambda x: (x**2 + 2*x - 1) if x &gt; 0 else (x**3 - x + 4))(3)\nprint(result)  # 14\n虽然这个函数运行良好并产生了正确的结果 14，但它并不容易阅读或查看。在这种情况下，最好创建一个带有 if/else 语句的单独函数，然后调用该函数：\n示例代码\ndef calculate_expression(x):\n    if x &gt; 0:\n        return x**2 + 2*x - 1\n    else:\n        return x**3 - x + 4\n\nprint(calculate_expression(3))  # 14\n在 Python 程序中，普通函数和 lambda 函数都有它们的用武之地。如果你处理的是单行内联表达式，那么你可能会考虑使用 lambda 函数。否则，使用普通函数将是更好的选择。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>循环和序列</span>"
    ]
  },
  {
    "objectID": "cp_3.html#处理字典dictionaries和集合sets",
    "href": "cp_3.html#处理字典dictionaries和集合sets",
    "title": "4  字典和集合",
    "section": "",
    "text": "4.1.1 什么是字典，它是如何工作的?\n在 Python 中，字典（dictionaries）是内置的数据结构，用于存储键值对（key-value pairs）的集合。它们的工作方式与真实世界的字典非常相似，你通过查找一个单词来找到它对应的含义。\n在 Python 字典中，你使用一个键来找到它对应的值。当你需要将值关联到唯一的键时，就应该使用字典。当你需要根据键快速查找值，或者需要表示结构化数据时，字典非常有用。\n这是 Python 字典的一般语法：\n示例代码\ndictionary = {\n    key1: value1,\n    key2: value2\n}\n首先，我们看到一个变量用来存储字典。你不一定非要把字典赋值给一个变量，但这样做非常普遍，目的是将其保存在内存中，以便稍后在代码中使用。\n然后是花括号（有时也称为大括号）。在花括号内，包含着键值对。\n每个键都关联着一个值，因此你可以使用键来访问该值。除了最后一个键值对外，每个值后面都有一个逗号，用来分隔不同的键值对。字典中的键必须是唯一的，并且必须是不可变的数据类型。但是，值可以重复，并且可以是任何数据类型。\n这里有一个字典的例子，它存储了关于玛格丽塔披萨食谱的信息：\n示例代码\npizza = {\n    'name': 'Margherita Pizza',\n    'price': 8.9,\n    'calories_per_slice': 250,\n    'toppings': ['mozzarella', 'basil']\n}\n该字典被赋值给 pizza 变量。它包含四个键值对：name、price、calories_per_slice 和 toppings。\n另一种替代方法是使用 dict() 构造函数，它可以从一系列键值对中构建字典。\n这是我们披萨例子的等效语法。我们将一个元组列表作为参数传递给 dict() 构造函数。这些元组包含键作为第一个元素，值作为第二个元素。\n示例代码\npizza = dict()\n要访问键值对的值，你可以使用这种语法，称为方括号表示法（bracket notation）。它是持有字典的变量名，后跟方括号，以及你想要访问的键：\n示例代码\ndictionary[key]\n在我们的披萨例子中，如果你想访问 name 的值，你会写下变量名 pizza，后跟方括号，以及在引号内的键 name：\n示例代码\npizza['name']\n这将计算为：\n示例代码\n'Margherita Pizza'\n要更新一个值，你只需要添加赋值运算符，后跟新值。\n如果字典中不存在该键，将创建一个新的键值对。在 Python 的较新版本中，字典会保留插入顺序。当你需要遍历字典时，这非常有用：\n示例代码\npizza['name'] = 'Margherita'\n现在键 name 的值是 ‘Margherita’：\n示例代码\nprint(pizza['name']) # 'Margherita'\n字典还有一些有用的方法来执行常见操作。\n.get() 方法检索与键关联的值。它与我们刚才使用的方括号表示法类似，但它的优势是你可设置一个默认值，因此如果键不存在，你不会收到错误：\n示例代码\ndictionary.get(key, default)\n在这个例子中，如果 toppings 键不存在，它将返回一个空列表，这是我们作为第二个参数传递的默认值。但如果 toppings 存在，它将返回该值：\n示例代码\npizza.get('toppings', []) # ['mozzarella', 'basil']\n.keys() 和 .values() 方法分别返回一个视图对象（view object），其中包含字典中的所有键和所有值：\n示例代码\npizza.keys()\n# dict_keys(['name', 'price', 'calories_per_slice'])\n\npizza.values()\n# dict_values(['Margherita Pizza', 8.9, 250])\n视图对象只是查看字典内容的一种方式，而不会创建数据的单独副本。\n.items() 方法返回一个视图对象，其中包含字典中的所有键值对，包括键和值：\n示例代码\npizza.items()\n# dict_items()\n.clear() 方法从字典中移除所有键值对：\n示例代码\npizza.clear()\n.pop() 方法移除具有你指定为第一个参数的键的键值对，并返回其值。如果键不存在，它返回你指定为第二个参数的默认值。如果键不存在且你没有传递默认值，将引发 KeyError：\n示例代码\npizza.pop('price', 10)\npizza.pop('total_price') # KeyError\n在 Python 3.7 及更高版本中，.popitem() 方法移除最后插入的键值对：\n示例代码\npizza.popitem()\n最后，.update() 方法用另一个字典的键值对更新当前的键值对。如果它们有共同的键，它们的值将被覆盖。\n在这个例子中，我们正在更新 pizza 字典。price 键在两个字典中都存在，所以它的值将被替换为 15。\n但 total_time 是新的，所以它将作为新的键值对添加到 pizza 字典中：\n示例代码\npizza.update({ 'price': 15, 'total_time': 25 })\n这是具有更新后的价格和新的 total_time 的新字典。请注意，price 现在是 15，而 total_time 是一个新的键值对：\n示例代码\n{\n    'name': 'Margherita Pizza', \n    'price': 15, \n    'calories_per_slice': 250, \n    'toppings': ['mozzarella', 'basil'], \n    'total_time': 25\n}\n这些是一些最常用的字典方法，但还有很多其他方法。选择合适的方法对于高效地执行复杂操作非常有帮助。\n\n\n4.1.2 有哪些常见的方法可以遍历字典？\n如果你需要访问和处理字典的键值对，你可以对字典进行循环。这对于更新它们的值或应用某些逻辑非常有用。\n让我们看看你可以使用的一些技术。\n假设我们有一个 products 字典，它将每个产品与其价格关联起来：\n示例代码\nproducts = {\n    'Laptop': 990,\n    'Smartphone': 600,\n    'Tablet': 250,\n    'Headphones': 70,\n}\n如果我们想为所有产品提供 20% 的折扣，我们可以循环遍历所有键值对并修改价格。\n.values()、.keys() 和 .items() 方法对于这些技术至关重要。我们在上一课中简要地介绍过它们。\n它们返回一个视图对象，包含字典的值、键和键值对。你可以在 for 循环中使用这些视图对象来迭代元素。\n例如，你可以像这样迭代字典的所有值。\n你写 for，循环变量（在本例中为 price），products.values() 以获取 products 字典的所有值，一个冒号，然后是循环体，在那里你可以对值应用任何逻辑。在本例中，我们正在打印它们。\n循环变量将获取每一个值，每次迭代一个：\n示例代码\nfor price in products.values():\n    print(price)\n这是输出。如你所见，每个值都被打印到控制台，一次一个：\n示例代码\n990\n600\n250\n70\n如果你需要迭代字典的键，这与 .keys() 的工作方式完全相同。你只需要迭代 products.keys() 或直接迭代 products，并为循环变量分配一个描述性的名称：\n示例代码\nfor product in products.keys():\n    print(product)\n\n# 或者\n\nfor product in products:\n    print(product)\n这是输出。每个键都被打印到控制台，一次一个：\n示例代码\nLaptop\nSmartphone\nTablet\nHeadphones\n如果你需要同时迭代键及其对应的值，这与键值对的工作方式完全相同。你只需要迭代 products.items()：\n示例代码\nfor product in products.items():\n    print(product)\n这是输出。现在你得到单独的元组，包含键及其对应的值：\n示例代码\n('Laptop', 990)\n('Smartphone', 600)\n('Tablet', 250)\n('Headphones', 70)\n如果你想将键和值存储在单独的循环变量中，你只需要定义它们并用逗号分隔。然后，你可以在循环体中使用它们。\n在这里，我们定义了一个 product 循环变量和一个 price 循环变量。每一个都将持有其对应的值。按顺序定义它们很重要——首先是键，然后是值：\n示例代码\nfor product, price in products.items():\n    print(product, price)\n这是输出。我们将它们并排打印，但你可以在代码中根据需要使用这些值。\n示例代码\nLaptop 990\nSmartphone 600\nTablet 250\nHeadphones 70\n既然你对这个了解得更多了，我们可以回到我们最初的例子。如果我们想提供 20% 的折扣，我们将每个价格乘以 0.8 并将其重新赋值为该产品键的值。\n如果我们想使用整数，也可以将结果向下取整：\n示例代码\nproducts = {\n    'Laptop': 990,\n    'Smartphone': 600,\n    'Tablet': 250,\n    'Headphones': 70,\n}\n\nfor product, price in products.items():\n    products[product] = round(price * 0.8)\n\nprint(products)\n然后，如果我们打印字典，我们将得到这些具有折扣价格的键值对：\n示例代码\n{\n    'Laptop': 792, \n    'Smartphone': 480, \n    'Tablet': 200, \n    'Headphones': 56\n}\n最后，如果你需要在迭代键值对的同时跟踪一个计数器，你可以调用 enumerate() 函数。这个计数器本质上充当该元素在循环中的“索引”或“计数”。\n该函数返回一个枚举对象，它为每个键值对分配一个整数，就像一个计数器。你可以从任何数字开始计数，但默认情况下，它从 0 开始。\n在这里，我们正在迭代 products 字典的键：\n示例代码\nfor product in enumerate(products):\n    print(product)\n但 enumerate() 函数也为每个键分配一个整数，所以我们得到包含整数和键的元组。\n这是输出：\n示例代码\n(0, 'Laptop')\n(1, 'Smartphone')\n(2, 'Tablet')\n(3, 'Headphones')\n如果需要，你可以将这些值赋值给单独的循环变量。在这里，我们有两个循环变量（index 和 product）。这是你在处理 enumerate() 时经常会看到和使用的：\n示例代码\nfor index, product in enumerate(products):\n    print(index, product)\n如果你需要迭代值，你可以将 products 替换为 products.values()：\n示例代码\nfor price in enumerate(products.values()):\n    print(price)\n输出将有索引和价格在每个元组中：\n示例代码\n(0, 990)\n(1, 600)\n(2, 250)\n(3, 70)\n你也可以将它们赋值给单独的循环变量：\n示例代码\nfor index, price in enumerate(products.values()):\n    print(index, price)\n这将是输出。你可以在代码中根据需要使用它们：\n示例代码\n0 990\n1 600\n2 250\n3 70\n对于 products.items()，你还可以在“索引”或“计数器”的基础上获取整个键值对：\n示例代码\nfor index, product in enumerate(products.items()):\n    print(index, product)\n在这个例子中，我们得到索引，后面跟着一个包含对应键值对的键和值的元组：\n示例代码\n0 ('Laptop', 990)\n1 ('Smartphone', 600)\n2 ('Tablet', 250)\n3 ('Headphones', 70)\n要自定义计数的初始值，你可以向 enumerate() 传递第二个参数。例如，这里我们从 1 开始计数：\n示例代码\nfor index, product in enumerate(products.items(), 1):\n    print(index, product)\n你可以在输出中看到这个变化。现在第一个整数是 1 而不是 0：\n示例代码\n1 ('Laptop', 990)\n2 ('Smartphone', 600)\n3 ('Tablet', 250)\n4 ('Headphones', 70)\n这适用于我们到目前为止看到的任何变体。你只需要将初始数字作为第二个参数传递。\n循环字典有很多技术。这些是一些常见的方法，你需要为你的项目选择最好的一个。\n\n\n4.1.3 集合是什么？它是如何工作的？\n集合（Sets）是 Python 内置的数据结构之一。集合的核心特性之一是它不存储重复的值。如果你试图向集合中添加一个重复的值，只有其中一个会被存储。\n集合是可变的且无序的，这意味着它们的元素不以任何特定的顺序存储，因此你不能使用索引或键来访问它们。它们只能包含不可变数据类型的值，比如数字、字符串和元组。并且它们支持数学上的集合运算，包括并集、交集、差集和对称差集。\n要定义一个集合，你只需要将其元素写在花括号内并用逗号分隔。这是一个数字集合的例子：\n示例代码\nmy_set = {1, 2, 3, 4, 5}\n使用集合的一个小陷阱是，如果你需要定义一个空集合，必须使用 set() 函数。如果你只写空的花括号 {}，Python 会自动创建一个字典。\n示例代码\nset() # 集合\n{}    # 字典\n你可以使用 .add() 方法向集合中添加一个元素，并将新元素作为参数传递：\n示例代码\nmy_set.add(6)\n在我们的例子中，新的集合将是：\n示例代码\n{1, 2, 3, 4, 5, 6}\n如果你试图添加一个已经存在于集合中的元素，只有其中一个会被保留。在本例中，集合中已经包含数字 5：\n示例代码\nmy_set.add(5)\n因此集合不会改变：\n示例代码\n{1, 2, 3, 4, 5, 6}\n要从集合中移除一个元素，你有两个选项。你可以使用 .remove() 方法或 .discard() 方法，并将你想要移除的元素作为参数传递。\n如果元素未找到，.remove() 方法会引发 KeyError，而 .discard() 方法则不会：\n示例代码\nmy_set.remove(4)\nmy_set.discard(4)\n.clear() 方法会移除集合中的所有元素：\n示例代码\nmy_set.clear()\nPython 集合还有一些强大的方法，用于执行常见的数学集合运算。\n.issubset() 和 .issuperset() 方法分别检查一个集合是否是另一个集合的子集或超集。\n在这里，我们检查 your_set 是否是 my_set 的子集，结果是 False，因为 your_set 的所有元素并非都在 my_set 中。\n我们还检查了 my_set 是否是 your_set 的超集。这也是 False，因为 my_set 没有 your_set 的所有元素：\n示例代码\nmy_set = {1, 2, 3, 4, 5}\nyour_set = {2, 3, 4, 6}\n\nprint(your_set.issubset(my_set)) # False\nprint(my_set.issuperset(your_set)) # False\n.isdisjoint() 方法检查两个集合是否不相交，这意味着它们没有任何共同的元素。在本例中，结果是 False，因为 my_set 和 your_set 确实有共同的元素——2、3 和 4：\n示例代码\nprint(my_set.isdisjoint(your_set)) # False\n并集运算符 | 返回一个包含两个集合所有元素的新集合：\n示例代码\nmy_set | your_set # {1, 2, 3, 4, 5, 6}\n交集运算符 & 返回一个只包含集合共有元素的新集合：\n示例代码\nmy_set & your_set # {2, 3, 4}\n差集运算符 - 返回一个包含第一个集合中有但其他集合中没有的元素的新集合。在本例中，数字 1 和 5 在 my_set 中但不在 your_set 中：\n示例代码\nmy_set - your_set # {1, 5}\n对称差集运算符 ^ 返回一个包含仅在第一个或第二个集合中的元素（但不同时在两个集合中）的新集合。在本例中，1 和 5 在 my_set 中但不在 your_set 中，所以它们被包含在内。而数字 6 在 your_set 中但不在 my_set 中，所以它也被包含在内：\n示例代码\nmy_set ^ your_set # {1, 5, 6}\n这些运算符中的每一个都有其对应的复合赋值运算符，即在其后添加等号。这些运算符会自动将结果集合赋值给表达式中的第一个集合：\n示例代码\n|= &= -= ^=\n例如，-= 运算符找到集合的差集，并用该结果更新第一个集合：\n示例代码\nmy_set -= your_set\n在此之后，my_set 将被更新为 {1, 5}：\n示例代码\nprint(my_set) # {1, 5}\n你可以使用 in 运算符检查一个元素是否在集合中。在这里，我们检查 5 是否在 my_set 中。结果将是一个布尔值 True 或 False：\n示例代码\nprint(5 in my_set)\n这就是集合的基础知识。当你不需要以任何特定顺序存储值，并且只需要存储唯一值时，集合非常有用。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>字典和集合</span>"
    ]
  },
  {
    "objectID": "cp_3.html#使用模块modules",
    "href": "cp_3.html#使用模块modules",
    "title": "4  字典和集合",
    "section": "4.2 使用模块（Modules）",
    "text": "4.2 使用模块（Modules）\n\n4.2.1 什么是 Python 标准库？如何导入模块？\n在软件开发中，库（Library）就像是开发者的工具箱。\n你不必从头开始实现代码的每一个部分，库为你提供了预先编写好且可重用的代码，比如函数、类和数据结构，你可以在项目中直接使用它们。\nPython 拥有一个功能丰富的标准库，其中包含了许多不同的内置模块。它们都是标准化的、经过充分验证的解决方案，旨在解决程序员日常面临的许多问题和任务，例如：\n\n与操作系统交互。\n处理文件。\n网络编程。\n处理日期和时间。\n执行数学运算。\n使用正则表达式。\n测试和调试代码。\n以及更多功能！\n\n一些流行的内置模块示例包括 math、random、re（代表“正则表达式”）和 datetime。\n\nmath 模块包含有助于执行更复杂数学运算的函数。\nrandom 模块有助于生成随机数。\nre 模块用于处理正则表达式。\ndatetime 模块有助于在 Python 中处理日期和时间。\n\n但是，你如何访问这些内置模块中定义的变量、常量、函数和类呢？\n你需要使用导入语句（import statement）。这些语句允许你将模块导入到你的 Python 脚本中。导入语句通常写在文件的顶部。此外，你可以根据需要对其进行自定义。首先，你使用 import 语句，后跟模块的名称：\n示例代码\nimport module_name\n假设你想导入 math 模块。在这种情况下，你会在文件顶部写入：\n示例代码\nimport math\n然后，如果你需要在 Python 脚本中调用该模块的方法，你会使用点号表示法（dot notation），即模块的名称后跟方法的名称：\n示例代码\nmodule_name.method_name()\n例如，为了获取 36 的平方根，你会写 math 后跟一个点，然后是 sqrt（平方根的缩写），并在括号内传递任何必要的参数。在本例中，我们只需要传递我们想要开平方根的数字：\n示例代码\nmath.sqrt(36)\n这是导入语句最基本的形式，但还有其他替代方案。\n如果你需要以不同的名称（也称为“别名”）导入模块，可以使用这种语法，在 import 语句末尾使用 as 后跟别名：\n示例代码\nimport module_name as module_alias\n这通常用于缩短长模块名称，或避免命名冲突。\n例如，为了让 math 模块在你的代码中被称为 m，你可以为其分配一个别名，像这样：\n示例代码\nimport math as m\n然后，你可以使用别名访问模块的元素：\n示例代码\nm.sqrt(36)\n但有时你不需要从模块中导入所有内容。也许你只需要一两个特定的函数或类。在这种情况下，Python 提供了你正好需要的功能。\n现在导入语句以 from 开头，后跟模块的名称，然后是 import 关键字，后跟你想要导入的元素的名称：\n示例代码\nfrom module_name import name1, name2\n然后，你可以在 Python 脚本中直接使用这些名称，而无需模块前缀。\n如果你想为这些名称分配别名，可以通过在每个名称后使用 as 关键字，后跟你想要使用的别名来实现：\n示例代码\nfrom module_name import name1 as alias1, name2 as alias2\n假设你只想从 math 模块中导入 radians、sin 和 cos 函数。你会写：\n示例代码\nfrom math import radians, sin, cos\n现在你可以在代码中直接调用这些函数，而无需 math 模块作为前缀。\n这里有一个更详细的例子：\n为了找到最初以度数表示的特定角度的正弦和余弦值，我们可以调用 radians 函数将其转换为弧度，然后调用正弦和余弦函数，传递以弧度表示的角度：\n示例代码\nfrom math import radians, sin, cos\n\nangle_degrees = 40\nangle_radians = radians(angle_degrees)\n\nsine_value = sin(angle_radians)\ncos_value = cos(angle_radians)\n\nprint(sine_value) # 0.6427876096865393\nprint(cos_value)  # 0.766044443118978\n请注意，我们是如何直接调用函数的，而无需模块名称作为前缀。这是因为我们使用了这种替代语法导入了函数。\n这很有用，但如果在 Python 脚本本身中已经定义了同名的函数或变量，它可能会导致命名冲突。因此，这是在选择想要使用的导入语句类型时需要记住的一点。\n最后，我们看到这种以星号（*）结尾的导入语句。星号告诉 Python 你想要导入该模块中的所有内容，但你希望导入它们，以便你不需要使用模块名称作为前缀：\n示例代码\nfrom module_name import *\n例如，如果你在导入 math 模块时这样做，你将能够调用该模块中定义的任何函数，而无需指定模块名称作为前缀。以下是一些例子：\n示例代码\nfrom math import *\nprint(sqrt(36))  # 6.0\nprint(pow(5, 2)) # 25.0\nprint(exp(1))    # 2.718281828459045\n然而，这通常不被鼓励，因为它可能导致命名空间冲突，并使你更难知道某些名称来自哪里。\n导入语句对于模块中定义的函数、类、常量、变量以及任何其他元素的工作方式完全相同。\n这是一个来自 math 模块的常量示例，圆周率 π：\n示例代码\nimport math\nprint(math.pi)\n这是一个来自 datetime 模块的类的示例。我们创建一个代表 1959 年 7 月 15 日的日期对象。然后，我们将该日期对象赋值给一个变量，并使用点号表示法单独访问日、月和年：\n示例代码\nimport datetime\nbirthday = datetime.date(1959, 7, 15)\nprint(birthday.day)    # 15\nprint(birthday.month)  # 7\nprint(birthday.year)   # 1959\n你可以在该模块的官方 Python 文档中找到有关模块内容的更多信息。\n很好。既然你对模块有了更多了解，你也应该知道 Python 脚本中这个非常重要的习语（idiom），因为它们关系非常密切：\n示例代码\nif __name__ == '__main__': \n    # 代码\n__name__ 是 Python 中一个特殊的内置变量。\n当一个 Python 文件被直接执行时，Python 会将此变量的值设置为字符串 \"__main__\"。\n但是，如果该 Python 文件作为模块被导入到另一个 Python 脚本中，__name__ 变量的值会被设置为该模块的名称（通常是不带 .py 扩展名的文件名）。\n这就是为什么你经常会在 Python 脚本中找到这个条件语句的原因。它包含你只想在 Python 脚本作为主程序运行时执行的代码：\n示例代码\nif __name__ == '__main__': \n    # 代码\n但如果脚本作为模块被导入，该代码块内的代码不会运行。\n这很有用，因为它允许 Python 脚本具有双重用途。它们可以直接运行以执行其主要逻辑，或者它们可以被导入到另一个模块中而不执行其主要逻辑。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>字典和集合</span>"
    ]
  },
  {
    "objectID": "cp_4.html#理解错误处理error-handling",
    "href": "cp_4.html#理解错误处理error-handling",
    "title": "5  异常处理",
    "section": "",
    "text": "5.1.1 Python 中常见的错误信息有哪些？\n在编写 Python 代码时，经常会遇到错误。理解这些错误是快速高效调试代码的关键。只要你懂得如何阅读这些信息，它们会准确地告诉你哪里出了问题以及问题的原因。\n常见的 Python 错误包括 SyntaxError（语法错误）、NameError（名称错误）、TypeError（类型错误）、IndexError（索引错误）和 AttributeError（属性错误）。当 Python 无法理解你的代码，或者你的逻辑与正在处理的数据不匹配时，就会发生这些错误。\n以下是 SyntaxError 的示例：\n示例代码\nprint(\"Hello, world!\"\n# SyntaxError: unexpected EOF while parsing\n这一行代码缺少一个右括号。由于代码不符合正确的语法规则，Python 抛出了一个 SyntaxError。\n以下是 NameError 的示例：\n示例代码\nprint(name)\n# NameError: name 'name' is not defined\n你试图打印一个尚未定义的变量。当 Python 找不到该名称的变量时，会抛出 NameError。\n以下是 TypeError 的示例：\n示例代码\n5 + \"5\"\n# TypeError: unsupported operand type(s) for +: 'int' and 'str'\n你不能将一个整数和一个字符串相加。当你尝试对不兼容的数据类型执行操作时，Python 会抛出 TypeError。\n以下是 IndexError 的示例：\n示例代码\nmy_list = [1, 2, 3]\nprint(my_list[5])\n# IndexError: list index out of range\n你试图访问列表中不存在的索引。当你超出列表范围时，Python 会抛出 IndexError。\n以下是 AttributeError 的示例：\n示例代码\nnum = 42\nnum.append(5)\n# AttributeError: 'int' object has no attribute 'append'\n整数（int）对象没有 append() 方法。当你尝试使用该数据类型不存在的方法或属性时，Python 会抛出 AttributeError。\n识别常见的 Python 错误信息有助于你更快地解决问题。不要盲目猜测，仔细阅读错误信息，它通常会准确地告诉你哪里出了问题以及该去哪里查找。\n\n\n5.1.2 Python 中有哪些有效的调试技巧？\n调试是每个 Python 开发者必备的核心技能。掌握基础的调试技术可以帮助你高效地识别并解决问题。\n调试是指识别并解决代码中的错误或缺陷（bugs）的过程。它涉及检查代码、理解程序执行流程，并使用工具来精确定位问题的根源。\n在本节课中，我们将介绍在下一个 Python 项目中可以使用的常见调试技术。\n\n5.1.2.1 使用 print 函数和 f-string\n首先，可以在代码的各个位置使用 print() 函数和 f-string 来帮助你理解变量的流程和状态。例如：\n示例代码\ndef add(a, b):\n    result = a + b\n    print(f'Adding {a} and {b} gives {result}')\n    return result\n通过打印 a、b 和 result 的值，你可以验证函数的行为是否符合预期。\n\n\n5.1.2.2 使用 pdb 模块进行交互式调试\n其次，你可以利用 Python 内置的 pdb 模块进行交互式调试：\n示例代码\nimport pdb\n\ndef divide(a, b):\n    pdb.set_trace()\n    return a / b\n\nprint(divide(10, 2))\n通过使用 .set_trace() 方法设置断点，你可以逐行执行代码、检查变量并理解程序的行为。\n如果你运行上面的代码，你会看到一些输出，显示你正在运行的文件位置、调用 .set_trace() 方法的行以及紧随其后的代码，还有一个交互式的 pdb 提示符：\n示例代码\n&gt; /Users/fcc/Desktop/debugging.py(5)divide()\n-&gt; return a / b\n(Pdb)\n如果你在提示符中输入 help，你会看到可以使用的一系列命令列表：\n示例代码\n(Pdb) help\n\nDocumented commands (type help &lt;topic&gt;):\n========================================\nEOF    c          d        h         list      q        rv       undisplay\na      cl         debug    help      ll        quit     s        unt      \nalias  clear      disable  ignore    longlist  r        source   until    \nargs   commands   display  interact  n         restart  step     up       \nb      condition  down     j         next      return   tbreak   w        \nbreak  cont       enable   jump      p         retval   unalias  whatis   \nbt     continue   exit     l         pp        run      u        where    \n\nMiscellaneous help topics:\n==========================\nexec  pdb\n然后你可以使用这些命令来调试你的代码。\n例如，如果你想查看当时代码中各个元素的类型，可以使用 whatis 命令：\n示例代码\n(Pdb) whatis a\n&lt;class 'int'&gt;\n(Pdb) whatis divide\nFunction divide\n正如你所见，当你运行 .set_trace() 时，参数 a 的类型是整数，而 divide 是一个函数。\n然后，要继续执行你的代码，可以使用 continue 命令，或者它的别名之一 cont 或 c：\n示例代码\n(Pdb) continue\n5.0\n\n\n5.1.2.3 使用 IDE 调试工具\n许多集成开发环境（IDE）都提供了高级的调试工具，例如断点、单步执行和变量检查。\n\n\n5.1.2.4 使用 VS Code 调试器\n如果你使用 VS Code，你可以在代码中设置断点，并运行调试器在这些点暂停执行。以下是调试同一个 divide 函数的步骤：\n步骤 1：设置你的代码\n创建一个名为 main.py 的文件，内容如下：\n示例代码\ndef divide(a, b):\n    result = a / b\n    return result\n\nprint(divide(10, 2))\nprint(divide(15, 3))\n步骤 2：设置断点\n点击行号左侧的空白区域（装订线）在第 2 行 (result = a / b) 旁边设置断点。\n会出现一个红点，表示断点已设置。\n步骤 3：开始调试\n按 F5 键，或者点击菜单栏的 运行 (Run) &gt; 开始调试 (Start Debugging)。\n出现提示时，选择 “Python File”。\n调试器将在你的断点处暂停执行。\n步骤 4：检查变量\n将鼠标悬停在变量上以查看其当前值。\n使用左侧的“变量”面板查看所有局部变量。\n使用底部的“调试控制台”来评估表达式。\n步骤 5：单步执行代码\n使用调试工具栏来：\n\n继续 (F5)：继续执行，直到下一个断点。\n单步跳过 (F10)：执行当前行并移动到下一行。\n单步进入 (F11)：进入函数调用内部。\n单步跳出 (Shift+F11)：跳出当前函数。\n\nIDE 调试工具提供了一个可视化的界面来检查程序的状态，相比于仅使用 print 语句，这使得识别和解决问题变得更加容易。\n通过掌握这些基础的调试技术——使用 print() 语句、pdb 模块和 IDE 工具——你可以有效地识别并解决 Python 代码中的问题。每种技术都有其适用的场景：print() 语句用于快速检查，pdb 用于交互式探索，而 IDE 调试器则用于可视化检查。\n\n\n\n5.1.3 异常处理是如何工作的？\n在 Python 中，异常处理是编写健壮且容错程序的核心部分。它允许你以结构化的方式预见、捕获并响应错误。\n异常处理是指捕获和管理程序执行期间发生的错误的过程，这样你的代码就不会意外崩溃。\nPython 提供了 try、except、else 和 finally 代码块来优雅地处理错误。这是一个基本的例子：\n示例代码\ntry:\n    x = 10 / 0\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\n\ntry: 你预见到可能会发生错误的代码块。\nexcept: 如果在 try 块内引发了指定类型的错误，该代码块就会执行。\n\n在这种情况下，除以零会引发 ZeroDivisionError，然后该错误被捕获并处理。\n这里还有一个例子，展示了如何使用 else 和 finally 块：\n示例代码\ntry:\n    x = 10 / 2\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\nelse:\n    print('Division successful:', x)\nfinally:\n    print('This block always runs.')\n\nelse: 如果 try 块中没有引发任何异常，则执行该代码块。\nfinally: 无论是否发生异常，该代码块都会运行。这对于清理任务（如关闭文件或释放资源）非常有用。\n\n你还可以使用单独的 except 块来捕获多种异常：\n示例代码\ntry:\n    number = int('abc')\n    result = 10 / number\nexcept ValueError:\n    print('That was not a valid number.')\nexcept ZeroDivisionError:\n    print(\"Can't divide by zero.\")\n通过使用单独的 except 子句，你可以使你的错误响应更加具体和有用。\n你还可以使用异常对象，通常使用 as 关键字为其指定一个别名。在这里，我们使用 e 作为错误对象的别名：\n示例代码\ntry:\n    x = 1 / 0\nexcept ZeroDivisionError as e:\n    print(f'Error occurred: {e}')\n使用 e 可以让你访问实际的错误消息或对象，以便进行日志记录或调试。\n你也可以在单个 except 子句中捕获多种异常，方法是将异常指定为一个元组：\n示例代码\ntry:\n    number = int(input('Enter a number: '))\n    result = 10 / number\nexcept (ValueError, ZeroDivisionError) as e:\n    print(f'Error occurred: {e}')\n异常处理允许你的程序从错误中优雅地恢复。通过使用 try、except、else 和 finally，你可以预见潜在的问题，并构建更具弹性的应用程序。\n\n\n5.1.4 什么是 raise 语句？它是如何起作用的？\n在 Python 中，raise 语句是一个强大的工具，它允许你在代码中手动触发异常。它让你能够控制何时以及如何生成错误，从而创建自定义的错误条件并强制执行特定的程序行为。\nraise 语句用于在程序的任何位置显式地抛出（throw）一个异常，让你能够发出信号，表明发生了错误条件或者某些要求未得到满足。\nPython 的 raise 语句有几种用法来触发异常。最基本的是，你可以触发内置异常或创建自定义错误消息。这是一个简单的例子：\n示例代码\ndef check_age(age):\n    if age &lt; 0:\n        raise ValueError('Age cannot be negative')\n    return age\n\ntry:\n    check_age(-5)\nexcept ValueError as e:\n    print(f'Error: {e}') # Error: Age cannot be negative\n你可以看到这里的 raise 是触发异常的关键字。\n在这个例子中，当提供了无效的年龄时，我们触发了一个带有自定义消息的 ValueError。\nraise 语句也可以用来重新触发（re-raise）当前的异常，这在异常处理中特别有用：\n示例代码\ndef process_data(data):\n    try:\n        result = int(data)\n        return result * 2\n    except ValueError:\n        print('Logging: Invalid data received')\n        raise  # Re-raises the same ValueError\n\ntry:\n    process_data('abc')\nexcept ValueError:\n    print('Handled at higher level')\n这里的 raise 关键字（不带参数）会重新触发当前正在处理的异常。\n这允许你在仍然将错误向调用栈上游传播的同时，进行日志记录或执行清理操作。\n你可以通过定义自己的异常类来创建并触发自定义异常：\n示例代码\nclass InsufficientFundsError(Exception):\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        super().__init__(f'Insufficient funds: ${balance} available, ${amount} requested')\n\ndef withdraw(balance, amount):\n    if amount &gt; balance:\n        raise InsufficientFundsError(balance, amount)\n    return balance - amount\n\ntry:\n    new_balance = withdraw(100, 150)\nexcept InsufficientFundsError as e:\n    print(f'Transaction failed: {e}')\n你可以看到自定义的异常类继承自 Exception 或其子类。\n你将在未来的课程中学习更多关于类和继承的知识。目前，你只需要知道这是一种通过自定义逻辑创建自己异常的方法。\nraise 语句还可以与 from 关键字一起使用来链接异常，显示不同错误之间的关系：\n示例代码\ndef parse_config(filename):\n    try:\n        with open(filename, 'r') as file:\n            data = file.read()\n            return int(data)\n    except FileNotFoundError:\n        raise ValueError('Configuration file is missing') from None\n    except ValueError as e:\n        raise ValueError('Invalid configuration format') from e\n\nconfig = parse_config('config.txt')\n在这里你可以看到 raise ... from None 抑制了原始异常的上下文：\n示例代码\nTraceback (most recent call last):\n  File \"main.py\", line 12, in &lt;module&gt;\n    config = parse_config('config.txt')\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"main.py\", line 7, in parse_config\n    raise ValueError('Configuration file is missing') from None\nValueError: Configuration file is missing\n而 raise ... from e 将新异常链接到原始异常，保留了错误轨迹。\n示例代码\nTraceback (most recent call last):\n  File \"main.py\", line 5, in parse_config\n    return int(data)\n           ^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"main.py\", line 12, in &lt;module&gt;\n    config = parse_config('config.txt')\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"main.py\", line 9, in parse_config\n    raise ValueError('Invalid configuration format') from e\nValueError: Invalid configuration format\n你也可以使用 assert 语句有条件地触发异常，这本质上是 raise 与 AssertionError 的简写形式：\n示例代码\ndef calculate_square_root(number):\n    assert number &gt;= 0, 'Cannot calculate square root of negative number'\n    return number ** 0.5\n\ntry:\n    result = calculate_square_root(-4)\nexcept AssertionError as e:\n    print(f'Assertion failed: {e}')\nraise 语句对于创建健壮的应用程序至关重要，在这些应用程序中，你需要强制执行业务规则、验证输入并提供有意义的错误消息。通过战略性地使用 raise，你可以使你的代码更具可预测性且更易于调试，同时为用户提供关于哪里出错的清晰反馈。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>异常处理</span>"
    ]
  },
  {
    "objectID": "cp_5.html#类和对象",
    "href": "cp_5.html#类和对象",
    "title": "6  类和对象",
    "section": "",
    "text": "6.1.1 类（Classes）是如何工作的？它们与对象（Objects）有什么不同？\n在 Python 中，类（Class）和对象（Object）协同工作来组织和管理数据。你构建一个类来定义共享的行为，然后创建使用这些行为的对象。\n换句话说，一个类就像是你用来创建对象的蓝图或模板。\n让我们看看什么是类，以及如何使用它们来创建对象。\n要创建一个类，你使用 class 关键字，后跟类的名称和一个冒号。然后在类内部，你可以添加一个初始化器（initializer），以及任何属性（attribute）和方法（method）。\n属性就像是类内部的变量，用于存储数据。方法是在类内部定义的函数，是使用该类创建的对象可以执行的操作。\n这里是类的基本语法：\n示例代码\nclass ClassName:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def sample_method(self):               \n        print(self.name.upper())\n\nclass ClassName 由用于创建类的 class 关键字组成，后跟类的名称，在这里称为 ClassName。在 Python 中，命名类时通常使用大驼峰命名法（PascalCase）。\ndef __init__(self, name, age) 是一个特殊的方法，在创建新对象时自动调用。它初始化将使用该类创建的对象的属性。\n除此之外，__init__ 的第一个参数始终是对正在创建或使用的特定对象的引用。按照惯例，这个参数被命名为 self，但技术上，你可以使用任何名称。self 让你能够访问对象自己的属性和方法。\nself.name = name 和 self.age = age 是对象将拥有的属性。\ndef sample_method(self): 是每个创建的对象都可以调用的方法。\nprint(self.name.upper()) 是 sample_method 方法将要做的事情，在本例中，它打印大写的名称。\n\n如果这一切听起来很多，请不要担心。让我们看一个类似的 Dog 类的例子，以及如何从中创建对象：\n示例代码\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def bark(self):\n        print(f\"{self.name.upper()} says woof woof!\")\n使用这个 Dog 类，你可以创建一个对象。这里是使用类创建对象的基本语法：\n示例代码\nobject_1 = ClassName(attribute_1, attribute_2)\nobject_2 = ClassName(attribute_1, attribute_2)\n你也可以从每个对象调用在类中定义的任何方法：\n示例代码\nobject_1.method_name()\nobject_2.method_name()\n现在让我们使用 Dog 类作为蓝图来创建两只狗：\n示例代码\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def bark(self):\n        print(f\"{self.name.upper()} says woof woof! I'm {self.age} years old!\")\n\ndog_1 = Dog(\"Jack\", 3)\ndog_2 = Dog(\"Thatcher\", 5)\n\n# Call the bark method\ndog_1.bark()  # JACK says woof woof! I'm 3 years old!\ndog_2.bark()  # THATCHER says woof woof! I'm 5 years old!\n正如你所见，我们使用 Dog 类创建了两个狗对象。当初始化 dog_1 时，字符串 Jack 和数字 3 被传递，这设置了该实例的名称和年龄属性。而 dog_2 使用字符串 Thatcher 和数字 5 作为其名称和年龄进行初始化。\n然后当你对 dog_1 和 dog_2 调用 .bark() 方法时，你可以看到两个输出是如何不同的，并使用了你在创建每个对象时传递的唯一名称和年龄属性。\n总而言之，类和对象之间的区别在于，类是模板或蓝图，而对象是使用该模板创建的实体。\n此外，类定义了对象应该拥有什么数据和行为，而对象持有实际的数据并使用该行为。你只编写一次类，但你可以从中创建许多对象，每个对象拥有不同的数据。\n\n\n6.1.2 什么是方法（Methods）和属性（Attributes）？它们是如何起作用的？\n在上一节课中，你学习了类以及它们如何作为创建对象的蓝图。\n在这里，我们将更深入地探讨属性和方法。\n让我们先仔细看看属性，然后再看方法。\n属性是属于对象的变量，因此它们用于存储数据。属性有两种：实例属性和类属性。\n实例属性对于从类创建的每个对象来说都是唯一的，你通常使用 __init__ 方法来设置它们。而类属性则属于类本身，并且由该类的所有实例共享。\n要访问属性，你使用点号表示法。\n这里是实例属性和类属性的示例，以及如何从对象访问它们：\n示例代码\nclass Dog:\n    species = \"French Bulldog\" # 类属性\n\n    def __init__(self, name):\n        self.name = name # 实例属性\n\nprint(Dog.species) # French Bulldog\n\ndog1 = Dog(\"Jack\")\nprint(dog1.name)    # Jack\nprint(dog1.species) # French Bulldog\n\ndog2 = Dog(\"Tom\")\nprint(dog2.name)    # Tom\nprint(dog2.species) # French Bulldog\n请注意，你可以直接从类本身访问类属性，但在访问实例属性之前，你需要先创建一个对象并为其传递数据。\n汽车是另一个很好的例子，因为所有汽车都有型号和颜色：\n示例代码\nclass Car:\n    def __init__(self, color, model):\n        self.color = color\n        self.model = model\n\ncar_1 = Car(\"red\", \"Toyota Corolla\")\ncar_2 = Car(\"green\", \"Lamborghini Revuelto\")\n\nprint(car_1.model) # Toyota Corolla\nprint(car_2.model) # Lamborghini Revuelto\n\nprint(car_1.color) # red\nprint(car_2.color) # green\n方法是在类内部定义的函数。通过它们，从类定义的任何对象都可以执行操作或修改其自身数据的操作。你也使用点号表示法来访问方法。\n例如，狗可以叫。所以我们可以在 Dog 类中有一个 bark 方法，就像你在上一课中看到的那样：\n示例代码\nclass Dog:\n   species = \"French Bulldog\"\n\n   def __init__(self, name):\n     self.name = name\n\n   def bark(self):\n       return f\"{self.name} says woof woof!\"\n\njack = Dog(\"Jack\")\njill = Dog(\"Jill\")\n\nprint(jack.bark()) # Jack says woof woof!\nprint(jill.bark()) # Jill says woof woof!\nCar 类也可以有一个 describe 方法：\n示例代码\nclass Car:\n    def __init__(self, color, model):\n        self.color = color  # 实例属性\n        self.model = model  # 实例属性\n\n    def describe(self):\n        return f\"This car is a {self.color} {self.model}\"\n\ncar_1 = Car(\"red\", \"Toyota Corolla\")\ncar_2 = Car(\"green\", \"Lamborghini Revuelto\")\n\nprint(car_1.describe()) # This car is a red Toyota Corolla\nprint(car_2.describe()) # This car is a green Lamborghini Revuelto\n\n\n6.1.3 什么是特殊方法？它们的用途是什么？\nPython 中的特殊方法，也被称为“魔术方法”或“双下划线方法”（dunder methods），是一些以双下划线（__）开头和结尾的特殊 Python 方法。单词“dunder”本身来源于 double underscores（d 代表 double，under 代表 underscores）。\n你可能已经不知不觉地使用过特殊方法了。每次你编写类似 3 + 4 的代码时，Python 在后台都会悄悄地运行 3.__add__(4)。这就是一个特殊方法在起作用。因此，虽然你可以直接调用特殊方法，但你很少会这样做。相比于直接调用 3.__add__(4)，像 3 + 4 这样的写法显然更清晰、更易读。\n除了 __add__，__init__() 是另一个你最常看到和使用的特殊方法，因为它是类的初始化器。还有其他一些方法，如 __len__() 和 __str__()。\n可以把特殊方法看作是编程人员与 Python 语言解释器本身之间活动的导演。\n请记住，你不需要直接调用特殊方法。相反，当某些操作发生时，Python 会自动调用它们。这些操作包括：\n\n算术运算：如加法、减法、乘法、除法等。进行加法时调用 __add__()，减法调用 __sub__()，乘法调用 __mul__()，除法调用 __truediv__()。\n字符串运算：如拼接、重复、格式化以及转换为文本。拼接调用 __add__()，重复调用 __mul__()，格式化调用 __format__()，文本转换调用 __str__() 和 __repr__() 等。\n比较运算：如相等、小于、大于等。进行相等性检查时调用 __eq__()，小于调用 __lt__()，大于调用 __gt__() 等。\n迭代运算：如使对象可迭代以及遍历项目。调用 __iter__() 返回一个迭代器，调用 __next__() 获取下一项。\n\n通常，Python 的数据类型（如字符串和数字）已经知道如何进行加法、拼接、比较相等性、在循环中使用等操作。\n但是，当你创建自己的类时，Python 将不知道如何自动处理这些操作。\n这就是特殊方法的用武之地——它们让你可以自定义 Python 的内置行为。\n假设你想获取使用下面的类创建的书籍对象的页数，或者比较它们，并获取对象的可读字符串。如果没有特殊方法，会发生什么：\n示例代码\nclass Book:\n   def __init__(self, title, pages):\n       self.title = title\n       self.pages = pages\n\nbook1 = Book(\"Built Wealth Like a Boss\", 420)\nbook2 = Book(\"Be Your Own Start\", 420)\n\nprint(len(book1)) # TypeError: object of type 'Book' has no len()\nprint(str(book1)) # &lt;__main__.Book object at 0x102ed2900&gt;\nprint(book1 == book2) # False even though they have the same number of pages\n在示例中：\n\nlen(book1) 失败了，因为如果没有 __len__()，Python 不知道如何获取你的书籍对象的长度。\nstr(book1) 打印了类似 &lt;__main__.Book object at 0x102ed2900&gt; 的内容，因为这是在没有使用 __str__() 时的默认表示形式。\nbook1 == book2 结果为 False，因为 Python 只是检查两个对象在内存中是否是同一个对象，而不是按内容比较。\n\n以下是你如何定义自己的 __len__()、__str__() 和 __eq__() 特殊方法，以使处理 Book 类创建的对象变得更简单：\n示例代码\nclass Book:\n   def __init__(self, title, pages):\n       self.title = title\n       self.pages = pages\n\n   def __len__(self):\n       return self.pages\n\n   def __str__(self):\n       return f\"'{self.title}' has {self.pages} pages\"\n\n   def __eq__(self, other):\n       return self.pages == other.pages\n  \nbook1 = Book(\"Built Wealth Like a Boss\", 420)\nbook2 = Book(\"Be Your Own Start\", 420)\n\nprint(len(book1)) # 420\nprint(len(book2)) # 420\nprint(str(book1)) # 'Built Wealth Like a Boss' has 420 pages\nprint(str(book2)) # 'Be Your Own Start' has 420 pages\nprint(book1 == book2) # True\n另一个例子是一个购物车，你需要执行以下操作：\n\n将商品添加到购物车\n从购物车中移除商品\n获取购物车中商品的数量\n检查购物车中有哪些商品\n检查特定商品是否在购物车中\n返回或显示购物车中特定索引位置的商品\n\n虽然你可能有一个方法用于将商品添加到购物车，另一个方法用于从购物车中移除特定商品，但你可以为所有其他功能创建特殊方法：\n\n__len__()：获取购物车中商品的数量\n__iter__()：遍历购物车中的商品，以便你可以看到它们\n__contains__()：检查特定商品是否在购物车中\n__getitem__()：返回或显示购物车中特定索引位置的商品\n\n这是一个包含这些用户定义方法和特殊方法的 Cart 类示例：\n示例代码\nclass Cart:\n   def __init__(self):\n       self.items = []\n\n   def add(self, item):\n       self.items.append(item)\n\n   def remove(self, item):\n       if item in self.items:\n           self.items.remove(item)\n       else:\n           print(f'{item} is not in cart')\n\n   def list_items(self):\n       return self.items\n\n   def __len__(self):\n       return len(self.items)\n\n   def __getitem__(self, index):\n       return self.items[index]\n\n   def __contains__(self, item):\n       return item in self.items\n\n   def __iter__(self):\n       return iter(self.items)\n以下是你如何使用它们：\n示例代码\ncart = Cart()\ncart.add('Laptop')\ncart.add('Wireless mouse')\ncart.add('Ergo keyboard')\ncart.add('Monitor')\n\nfor item in cart:\n   print(item, end=' ') # Laptop Wireless mouse Ergo keyboard Monitor\n\nprint(len(cart)) # 4\nprint(cart[3]) # Monitor\n\nprint('Monitor' in cart) # True\nprint('banana' in cart) # False\n\ncart.remove('Ergo keyboard')\n\nprint(cart.list_items()) # ['Laptop', 'Wireless mouse', 'Monitor']\n\ncart.remove('banana') # banana is not in cart\n这就是在现实世界中使用 Python 特殊方法的几种方式。\n\n\n6.1.4 如何动态地处理对象属性？\n在上一节课中，你学习了属性是属于对象的变量。这意味着它们持有描述对象状态或行为的数据。\n例如，一辆汽车通常会有品牌和型号。品牌和型号可以作为 Car 类的属性：\n示例代码\nclass Car: \n    def __init__(self, brand, model): \n        self.brand = brand \n        self.model = model \n\nmy_car = Car('Lamborghini', 'Gallardo') \nprint(my_car.brand) # Lamborghini \nprint(my_car.model) # Gallardo\n但有时，你可能要等到程序运行时才知道需要哪些属性。想象一下，你正在编写一个脚本，从用户或配置文件中接收属性名称。这些属性不是你可以提前硬编码的。\n这就是动态处理属性的用武之地。通过这种方式，你可以使用变量名而不是代码中的固定名称来访问、修改、检查甚至删除属性。这赋予了你的程序灵活性，使其能够即时响应不同的数据或用户输入。\nPython 提供了四个方便的内置函数来动态处理对象属性。它们是 getattr()、setattr()、hasattr() 和 delattr()。\n它们让你可以使用变量名来访问、创建、检查和移除属性。让我们看看它们各自的实际应用。\ngetattr() 使得在你不知道属性名称直到运行时的情况下，仍能从对象中读取属性成为可能。如果属性不存在，它会引发 AttributeError，除非你提供一个默认值。\n要使用它，你需要传入对象、属性名称和一个可选的默认值：\n示例代码\ngetattr(object, attribute_name, default_value)\n这是一个示例：\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30) \n \nprint(getattr(person, 'name')) # John Doe \nprint(getattr(person, 'age')) # 30 \nprint(getattr(person, 'city', 'Milano')) # Milano\n在上面的示例中，Milano 是一个默认值，因为 Person 类中不存在 city。\n正如我们之前所说，getattr() 的真正威力在于属性名称来自变量时，例如来自用户输入或某个文件。\n在这种情况下，你不能使用常规的 object.attribute_name 语法，因为属性名称不是固定的。\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30)\n\nattr_name = input('Enter the attribute you want to see: ')\nprint(getattr(person, attr_name, 'Attribute not found'))\n在这种情况下，如果用户输入 name，他们会看到 John Doe；如果他们输入 age，他们会看到 30。如果他们输入类中不存在的内容（如 email），他们会看到 Attribute not found。\n这正是动态属性处理大放异彩的地方。它让你的代码能够响应它以前从未见过的输入和数据。\n此外，你可能想要查看对象拥有的所有属性，而不仅仅是那些你已经知道的属性。内置的 dir() 函数可以让你做到这一点。它返回对象上所有属性名称的列表。以下是使用方法：\n示例代码\nclass Person: \n    def __init__(self, name, age): \n        self.name = name \n        self.age = age \n\nperson = Person('John Doe', 30)\n\n# 使用 dir() 函数循环遍历 person 对象的所有属性\nfor attr in dir(person):\n    # 忽略像 __init__ 或 __str__ 这样的双下划线方法和普通方法\n    if not attr.startswith('__') and not callable(getattr(person, attr)): \n        value = getattr(person, attr)\n        print(f'{attr}: {value}')\n\n# 输出\n# age: 30\n# name: John Doe\nsetattr() 函数允许你动态地创建新属性或更新现有属性。语法如下：\n示例代码\nsetattr(object, attribute_name, value)\n这是一个根据某些配置或环境变量文件中的数据设置配置属性的示例：\n示例代码\nclass Configuration:\n    pass\n\n# 在运行时加载的数据（如从配置或环境文件）\nsettings_data = {\n    'server_url': 'https://api.example.com',\n    'timeout_sec': 30,\n    'max_retries': 5\n}\n\nconfig_obj = Configuration()\n\n# 使用字典的键和值动态设置属性\nfor attr_name, attr_value in settings_data.items():\n    setattr(config_obj, attr_name, attr_value)\n\nprint(config_obj.server_url) # https://api.example.com\nprint(config_obj.timeout_sec) # 30\n还有一个 hasattr()。在你对属性进行操作或删除它之前，最好先检查它是否存在。这就是 hasattr() 让你做的事情。它检查属性是否存在，并根据结果返回 True 或 False。\n以下是基本语法：\n示例代码\nhasattr(object, attribute_name)\n这是一个动态检查 Product 类实例中属性存在的示例：\n示例代码\nclass Product:\n    def __init__(self, name, price):\n        self.name = name\n        self.price = price\n\nproduct_a = Product('T-Shirt', 25)\n\nrequired_attributes = ['name', 'price', 'inventory_id']\n\nfor attr in required_attributes:\n    if not hasattr(product_a, attr):\n        print(f\"ERROR: Product is missing the required attribute: '{attr}'\")\n    else:\n        # 确认存在后，动态访问属性\n        print(f'{attr}: {getattr(product_a, attr)}')\n\n# 输出:\n# name: T-Shirt\n# price: 25\n# ERROR: Product is missing the required attribute: 'inventory_id'\n出现 ERROR 输出是因为 Product 类及其实例中缺少 inventory_id。\n最后，delattr() 让你可以动态地移除一个属性：\n示例代码\ndelattr(object, attribute_name)\n例如，想象一个对象已经被完全处理，然后你决定在保存最终版本之前清理可能存在的任何敏感或临时属性。之后，你可以使用 dir() 循环遍历剩余的属性：\n示例代码\nclass UserSession:\n    def __init__(self, user_id, token):\n        self.user_id = user_id\n        self.auth_token = token # sensitive\n        self.temp_counter = 0 # temporary\n\nsession = UserSession(101, 'a1b2c3d4e5')\n\n# 在“保存”会话之前要动态移除的属性列表\nattributes_to_clean = ['auth_token', 'temp_counter']\n\n# 动态移除指定的属性\nfor attr in attributes_to_clean:\n    if hasattr(session, attr):\n        delattr(session, attr)\n        print(f'Removed attribute: {attr}')\n\nprint('\\nFinal attributes remaining:')\n\n# 使用 dir() 循环遍历剩余的属性\nfor attr in dir(session):\n    # 忽略像 __init__ 或 __str__ 这样的双下划线方法和普通方法\n    if not attr.startswith('__') and not callable(getattr(session, attr)):\n        print(f' - {attr}: {getattr(session, attr)}')\n\n# 输出:\n# Removed attribute: auth_token\n# Removed attribute: temp_counter\n\n# Final attributes remaining:\n#  - user_id: 101\n这就是如何动态处理属性的方法！",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>类和对象</span>"
    ]
  },
  {
    "objectID": "cp_6.html#理解面向对象编程与封装encapsulation",
    "href": "cp_6.html#理解面向对象编程与封装encapsulation",
    "title": "7  面向对象编程（OOP）",
    "section": "",
    "text": "7.1.1 什么是面向对象编程？封装是如何工作的？\n面向对象编程（Object-oriented programming），也被称为 OOP，是一种编程风格，在这种风格中，开发者将其代码中的所有事物都视为现实世界中的对象。\n类就像是创建对象的蓝图。从类创建的每个对象都有定义数据的属性和定义对象行为的方法。\n在上一节课中，你学习了如何创建类。以下是语法的复习：\n示例代码\nclass ClassName:\n   def __init__(self, parameters):\n       attribute = value\n\n   def method_name(self):\n       # method logic\n这是一个类的示例，它使用 __init__ 特殊方法在使用该类创建对象时初始化 brand 和 color 属性：\n示例代码\nclass Car:\n   def __init__(self, brand, color):\n       self.brand = brand\n       self.color = color\n\n# 从 Car 类创建两个对象\ncar1 = Car('Toyota', 'red')\ncar2 = Car('Lambo', 'green')\n\nprint('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota\nprint('Car 1 Color:', car1.color) # Car 1 Color: red\n\nprint('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo\nprint('Car 2 Color:', car2.color) # Car 2 Color: green\n面向对象编程有四个关键原则，它们能帮助你有效地组织和管理代码。它们是封装（encapsulation）、继承（inheritance）、多态（polymorphism）和抽象（abstraction）。\n本节课的其余部分将重点关注封装是如何工作的。\n封装是将对象的属性和方法捆绑到一个单一单元（即类）中的过程。\n通过封装，你可以将对象的内部状态隐藏在一组简单的公共方法和属性后面，这些公共方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制着数据如何变化以及谁可以看到它。\n假设你想追踪钱包余额。你想允许人们向钱包中存款或取款，但不应该有人能够直接篡改余额。\n在这种情况下，你可以使 deposit() 和 withdraw() 成为公共方法，并将余额隐藏在 _balance 属性下：\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self._balance = balance # 按照约定，仅供内部使用\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self._balance += amount # 安全地增加余额\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self._balance:\n           self._balance -= amount # 安全地减少余额\n按照约定，以单个下划线为前缀的属性和方法意味着它们仅供内部使用。任何人都不应该直接从类的外部访问它们，因为这违背了封装的原则，可能会导致错误。\n虽然单下划线前缀只是一个约定，但以双下划线为前缀的属性和方法实际上阻止了它们从类的外部被访问，从而使这些属性和方法成为私有的。\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self.__balance = balance # 私有属性\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self.__balance += amount # 安全地增加余额\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self.__balance:\n           self.__balance -= amount # 安全地减少余额\n\naccount = Wallet(500)\nprint(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'\n要获取 __balance 的当前值，你可以定义一个 get_balance 方法。例如：\n示例代码\nclass Wallet:\n   def __init__(self, balance):\n       self.__balance = balance\n\n   def deposit(self, amount):\n       if amount &gt; 0:\n           self.__balance += amount\n\n   def withdraw(self, amount):\n       if 0 &lt; amount &lt;= self.__balance:\n           self.__balance -= amount\n  \n   def get_balance(self):\n       return self.__balance\n\n\nacct_one = Wallet(100)\nacct_one.deposit(50)\nprint(acct_one.get_balance()) # 150\n\nacct_two = Wallet(450)\nacct_two.withdraw(28)\nprint(acct_two.get_balance()) # 422\n\nacct_two.deposit(150)\nprint(acct_two.get_balance()) # 572\n你还可以定义一个私有的 __validate 方法来检查每次存款或取款金额是否为正数：\n示例代码\nclass Wallet:\n   def __init__(self):\n       self.__balance = 0\n\n   def __validate(self, amount):\n       if amount &lt; 0:\n           raise ValueError('Amount must be positive')\n\n   def deposit(self, amount):\n       self.__validate(amount)\n       self.__balance += amount\n\n   def withdraw(self, amount):\n       self.__validate(amount)\n       if amount &gt; self.__balance:\n           raise ValueError('Insufficient funds')\n       self.__balance -= amount\n\n   def get_balance(self):\n       return self.__balance\n\nacct_one = Wallet()\nacct_one.deposit(3)\nprint(acct_one.get_balance()) # 3\n\nacct_one.deposit(50)\nprint(acct_one.get_balance()) # 53\n\nacct_one.deposit(-4)  # ValueError: Amount must be positive\nacct_one.withdraw(-8) # ValueError: Amount must be positive\nacct_one.withdraw(58) # ValueError: Insufficient funds\n正如你所见，__validate 方法是私有的，并在 deposit() 和 withdraw() 公共方法的后台运行，以确保金额始终有效。\n在接下来的课程中，你将学习更多关于以双下划线为前缀的属性是如何工作的。\n总而言之，封装通过清晰的公共方法锁定内部数据。这就是你如何保护你的类免受篡改并将验证集中在一个地方的方法。你可以自由地更新或扩展你的代码，因为你知道外部代码只能接触到你暴露的接口。\n\n\n7.1.2 什么是 Getter 和 Setter\nGetter 和 Setter 是让你控制如何访问和修改类属性的方法。通过 Getter 你获取值，通过 Setter 你设置值。\n这些操作是通过所谓的 属性（Properties） 来完成的。属性是连接 Getter 和 Setter 的桥梁，允许对数据进行访问。\n属性看起来像属性，但在后台表现得像方法。可以把它们看作是像方法一样定义的数据，但像属性一样工作。这意味着你可以使用点号表示法（而不是括号或圆括号）来访问属性。\n属性的主要作用是，当你使用它们获取、设置或删除值时，会在后台运行额外的逻辑。这使得它们成为当你想要在对象内访问或操作数据时的绝佳选择。\n那么，为什么要为此使用属性而不是方法呢？这主要是关于可读性和约定的问题。它们使你的代码更简洁、更易读。\n当你使用方法时，你总是必须用括号来调用它。但使用属性时，你可以像访问普通属性一样使用点号表示法来访问它。这使得你的代码看起来很简单，即使它在后台正在做额外的工作。\n例如，你可能想要计算一个值，或者在保存新值之前检查它是否有效。你可以使用属性的方式来做这件事，而不是调用一个方法。\n要创建一个属性，你定义一个方法，并在它上面放置 @property 装饰器。这告诉 Python 将该方法视为一个属性。\n这就引出了 Getter。以下是使用 @property 装饰器创建一个 Getter 的方法：\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self): # 用于获取半径的 Getter\n        return self._radius\n  \n    @property\n    def area(self):  # 用于计算面积的 Getter\n        return 3.14 * (self._radius ** 2)\n\nmy_circle = Circle(3)\n\nprint(my_circle.radius) # 3\nprint(my_circle.area) # 28.26\n这个示例获取了圆的半径和面积。\n请注意我们在类内部如何使用 _radius 而不是 radius。下划线是 Python 中的一个常见约定，表示该属性是私有的。换句话说，它表示该属性仅供内部使用，不应直接从类的外部访问。\n要创建一个 Setter 来设置半径，例如，你必须定义另一个同名的方法，并在它上面使用 @&lt;property_name&gt;.setter：\n在 __init__ 中使用 self.radius 确保在对象创建期间调用 Setter，因此无效的半径值会立即被捕获。\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius # 调用 Setter\n\n    @property\n    def radius(self):  # 用于获取半径的 Getter\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):  # 用于设置半径的 Setter\n        if value &lt;= 0:\n            raise ValueError('Radius must be positive')\n        self._radius = value\n\nmy_circle = Circle(3)\nprint('Initial radius:', my_circle.radius) # Initial radius: 3\n\nmy_circle.radius = 8\nprint('After modifying the radius:', my_circle.radius) # After modifying the radius: 8\n在这个示例中，radius Setter 不仅仅是为圆设置半径，它还在运行一个验证，确保半径不是负数。\n一旦你定义了 Getter 和 Setter，Python 会在你使用普通属性语法时在后台自动调用它们：\n示例代码\nmy_circle.radius # 这将调用 Getter\nmy_circle.radius = 4 # 这将调用 Setter\n请注意，在 Setter 内部，你不能在赋值新值时使用属性的相同名称。这是因为 self.radius = value 会在 Setter 方法本身内调用 Setter，导致无限递归和 RecursionError。所以你必须始终使用带下划线的前缀形式 self._radius = value。\n就像你可以通过 Getter 控制如何访问属性，通过 Setter 控制如何修改属性一样，你也可以通过 Deleter 控制如何删除属性。\n当你对属性使用 del 语句时，Deleter 会运行自定义逻辑。要创建一个 Deleter，你使用 @&lt;property_name&gt;.deleter 装饰器：\n示例代码\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    # Getter\n    @property\n    def radius(self):\n        return self._radius\n\n    # Setter\n    @radius.setter\n    def radius(self, value):\n        if value &lt;= 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n\n    # Deleter\n    @radius.deleter\n    def radius(self):\n        print(\"Deleting radius...\")\n        del self._radius\n以下是 Deleter 的使用方法：\n示例代码\n# 创建带有半径的圆对象\nmy_circle = Circle(33)\nprint(\"Initial radius:\", my_circle.radius)  # 33\n\n# 删除半径\n# 这将调用 Deleter\ndel my_circle.radius # Deleting radius...\nprint(\"Radius deleted!\") # Radius deleted!\n\n# 尝试在删除后访问半径\ntry:\n    print(my_circle.radius)\nexcept AttributeError as e:\n    print(\"Error:\", e) # Error: 'Circle' object has no attribute '_radius'\n本节课的要点是：\n\nGetter 让你检索一个值，甚至动态计算一个值。\nSetter 让你在赋值前运行检查，从而安全地修改值。\n属性 是将这些 Getter 和 Setter 绑定在一起的东西，让你可以编写逻辑，同时仍然使用点号表示法。\nDeleter 让你定义删除属性时发生的事情。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_6.html#理解-inheritance-和-polymorphism",
    "href": "cp_6.html#理解-inheritance-和-polymorphism",
    "title": "7  面向对象编程（OOP）",
    "section": "7.2 理解 Inheritance 和 Polymorphism",
    "text": "7.2 理解 Inheritance 和 Polymorphism\n\n7.2.1 什么是继承（Inheritance）？它如何促进代码复用？\n继承是我们将要探讨的面向对象编程（OOP）的下一个关键概念。\n让我们深入了解一下这个概念，以及它如何让你编写可重用的代码。\n通过继承，子类（或称派生类）可以使用基类（或称父类）的属性和方法。这允许你重用代码、创建清晰的类层次结构，并在不重写所有内容的情况下自定义行为。你可以通过扩展现有方法或在子类中重写它们来实现自定义。\n以下是继承的基本语法：\n示例代码\nclass Parent:\n    # 父类的属性和方法\n\nclass Child(Parent):\n    # 子类继承、扩展和/或在必要时重写\n为了让 Child 类继承自 Parent 类，你必须将 Parent 作为参数传递给 Child。\n这种风格被称为单继承，因为子类恰好从一个父类继承。\n这是一个示例：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack makes a sound\nprint(jack.bark)  # woof! woof!! woof!!!\n你可以看到，我们能够在子类 Dog 中重用父类 Animal 的 self.name 属性和 sound() 方法。\n让我们重写子类 Dog 中父类 Animal 的 sound() 方法，以便我们可以让 sound() 使用 bark 类变量：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound.'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\n    # 重写 sound() 以使用 bark 类变量\n    def sound(self):\n        return f'{self.name} barks {self.bark}'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack barks woof! woof!! woof!!!\n如果你想保留 sound() 的返回值，然后稍后添加 bark 类变量，你可以使用 super() 函数来扩展 sound()：\n示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def sound(self):\n        return f'{self.name} makes a sound'\n\nclass Dog(Animal):\n    bark = 'woof! woof!! woof!!!'\n\n    # 调用 Animal.sound()，然后追加 bark\n    def sound(self):\n        base = super().sound()\n        return f'{base}, then {self.name} barks {self.bark}'\n\njack = Dog('Jack')\nprint(jack.sound())  # Jack makes a sound, then Jack barks woof! woof!! woof!!!\n在这个示例中，base 是调用 Animal 类的 sound() 方法的结果，然后我们将其追加到 Dog 类特有的声音中。这样，你可以在保留父类 Animal 原始行为的同时，扩展其功能。\n还有一种多重继承，即子类可以从多个父类继承。\n以下是多重继承的基本语法：\n示例代码\nclass Parent:\n    # 父类的属性和方法\n\nclass Child:\n    # 子类的属性和方法\n\nclass GrandChild(Parent, Child):\n    # GrandChild 从 Parent 和 Child 继承\n    # GrandChild 可以组合或重写来自每个父类的行为\n演示多重继承的一个简单方法是使用青蛙，它既可以在陆地上行走，也可以在水中游泳：\n示例代码\nclass Walker:\n    def walk(self):\n        return 'I can walk on land'\n\nclass Swimmer:\n    def swim(self):\n        return 'I can swim in water'\n\n# Amphibian 从 Walker 和 Swimmer 继承\nclass Amphibian(Walker, Swimmer):\n    def __init__(self, name):\n        self.name = name\n\n    def introduce(self):\n        return f\"I'm {self.name} the frog. {self.walk()} and {self.swim()}.\"\n\nfrog = Amphibian('Freddy')\nprint(frog.introduce())\n# Output: I'm Freddy the frog. I can walk on land and I can swim in water.\n\n\n7.2.2 什么是多态（Polymorphism）？它如何促进代码复用？\n多态性（Polymorphism）是我们将要讨论的面向对象编程（OOP）的下一个关键概念。\n通过多态性，你可以访问一个接口，通过它与许多同类型的对象进行交互。\n让我们深入了解一下多态性以及它如何让你重用代码。\n多态性允许不同类中的方法共享相同的名字，但执行不同的任务。你对不同的对象调用相同的方法名，每个对象会以自己的方式响应。\n以下是多态性的基本示例：\n示例代码\nclass A:\n   def action(self): ...\n\nclass B:\n   def action(self): ...\n\nclass C:\n   def action(self): ...\n\nClass().method()  # 对 A、B 或 C 都适用\n这是一个使用不同动物声音来描述多态性的示例：\n示例代码\nclass Cat:\n   def speak(self):\n       return \"A cat meow\"\n\nclass Bird:\n   def speak(self):\n       return \"A bird tweet\"\n  \nclass Monkey:\n   def speak(self):\n       return \"A monkey ooh ooh aah aah ooh ooh aah aah\"\n\ndef animal_sound(animal):\n   print(animal.speak())\n\nanimal_sound(Cat())\nanimal_sound(Bird())\nanimal_sound(Monkey())\n在这个示例中，animal_sound() 是一个接受任何具有 speak() 方法的对象的函数。\n当你传入 Cat、Bird 或 Monkey 时，它会调用该对象的 speak() 方法并打印结果。因为每个类都以不同的方式定义了 speak()，所以同一个函数会得到不同的输出。这就是多态性的实际应用。\n这是另一个示例，这次涉及实例和属性：\n示例代码\nclass Twitter:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"🐦 Tweet: '{self.content}' (280 chars max)\"\n\nclass Instagram:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"📸 Instagram Post: '{self.content}' + ✨ filters\"\n\nclass LinkedIn:\n   def __init__(self, content):\n       self.content = content\n\n   def post(self):\n       return f\"💼 LinkedIn Article: '{self.content}' (Professional Mode)\"\n\ndef start(social_media):\n   print(social_media.post())  # 对任何对象调用 .post()\n\n# 实例\ntweet = Twitter('Just learned Python polymorphism!')\nphoto = Instagram('Sunset vibes 🌅')\narticle = LinkedIn('Why OOP matters in 2024')\n\n# 多态性调用 - 相同的函数，不同的输出\nstart(tweet) # 🐦 Tweet: 'Just learned Python polymorphism!' (280 chars max)\nstart(photo) # 📸 Instagram Post: 'Sunset vibes 🌅' + ✨ filters\nstart(article) # 💼 LinkedIn Article: 'Why OOP matters in 2024' (Professional Mode)\n还有一种多态性被称为基于继承的多态性（inheritance-based polymorphism）。\n在基于继承的多态性中，父类定义一个方法，多个子类以自己的方式重写该方法。然后，你可以对任何子对象调用相同的方法，它会根据它是哪个子类而表现不同。\n这是一个示例：\n示例代码\nclass Animal:\n   def speak(self):\n       return 'Some generic sound'\n\nclass Cat(Animal):\n   def speak(self):\n       return 'A cat meow'\n\nclass Dog(Animal):\n   def speak(self):\n       return 'A dog barks woof woof'\n\nclass Monkey(Animal):\n   def speak(self):\n       return 'A monkey ooh ooh aah aah ooh ooh aah aah'\n  \nprint(Cat().speak()) # A cat meow\nprint(Dog().speak()) # A dog barks woof woof\nprint(Monkey().speak()) # A monkey ooh ooh aah aah ooh ooh aah aah\nprint(Animal().speak()) # Some generic sound\n你可以看到，父类 Animal 的每个子类都重写了 speak() 方法以提供自己的实现。因此，当你对每个子类的实例调用 speak() 方法时，它会返回与该动物相关的特定声音。\n你还可以更进一步，在列表中进行调用，然后遍历列表以显示 speak() 方法为每个子类返回的内容：\n示例代码\nanimals = [Cat(), Dog(), Monkey()]\n\nfor animal in animals:\n   print(animal.speak())\n\n# Output:\n# A cat meow\n# A dog barks woof woof\n# A monkey ooh ooh aah aah ooh ooh aah aah\n\n\n7.2.3 什么是名称改写（Name Mangling）？它是如何工作的？\n在上一节课中，你学习了如何使用单下划线和双下划线为属性命名。\n为了让你回顾一下它们之间的区别：单下划线是一种约定，意味着该属性仅供类内部使用，不应从类的外部直接访问。而双下划线则阻止该属性从类的外部被直接访问。\n这是一个演示两者如何工作的示例：\n示例代码\nclass Example:\n    def __init__(self):\n        self._internal = 'I can be accessed from outside the class, but should not'\n        self.__private = 'You cannot access me directly from outside the class'\n\nobj = Example()\n\nprint(obj._internal) # I can be accessed from outside the class, but should not\nprint(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'\n为属性加上双下划线前缀会触发 Python 的名称改写（name mangling）过程，在这个过程中，Python 会在内部通过添加一个下划线和类名作为前缀来重命名该属性，将 __attribute 变成 _ClassName__attribute。\n要看到这一点，你可以创建一个类的实例，并使用该实例的 __dict__ 特殊属性，它是一个包含对象属性的字典：\n示例代码\nclass Example:\n    def __init__(self, internal, private):\n        self._internal = internal\n        self.__private = private\n\nexample1 = Example(\n    'I can be accessed from outside the class, but should not',\n    'I cannot be accessed directly from outside the class'\n)\n\nprint(example1.__dict__)\n结果将是：\n示例代码\n{\n  '_internal': 'I can be accessed from outside the class, but should not',\n  '_Example__private': 'I cannot be accessed directly from outside the class'\n}\n正如你所见，__private 属性被存储为 _Example__private。这意味着你仍然可以通过这种方式从类的外部访问该属性：\n示例代码\nclass Example:\n    def __init__(self, internal, private):\n        self._internal = internal\n        self.__private = private\n\nexample1 = Example(\n    'I can be accessed from outside the class, but should not',\n    'I cannot be accessed directly from outside the class'\n)\nexample2 = Example(\n    'I should not be accessed from outside the class',\n    'But I can be accessed from outside the class with name mangling'\n)\n\nprint(example1._Example__private) # I cannot be accessed directly from outside the class\nprint(example2._Example__private) # But I can be accessed from outside the class with name mangling\n那么，为什么 Python 要进行名称改写呢？\n名称改写的主要目的是在使用继承时防止意外覆盖属性和方法。这是一个明确说明这一点的示例：\n示例代码\nclass Parent:\n    def __init__(self):\n        self.__data = 'Parent data'\n\nclass Child(Parent):\n    def __init__(self):\n        super().__init__()\n        self.__data = 'Child data'\n\nc = Child()\nprint(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}\n你可以看到，父类 Parent 和继承它的子类 Child 都有它们各自的 _class__data 属性。这是通过名称改写实现的。否则，子类就会意外地覆盖父类的数据。\n以下是如果不允许 Python 进行名称改写会发生的情况，即如果你不在两个类的属性前加上双下划线：\n示例代码\nclass Parent:\n   def __init__(self):\n       self.data = 'Parent data'\n\nclass Child(Parent):\n   def __init__(self):\n       super().__init__()\n       self.data = 'Child data'\n\nc = Child()\nprint(c.__dict__)  # {'data': 'Child data'}\n那么，在单下划线（_）和双下划线（__）之间，你应该使用哪一个来为属性命名呢？这取决于具体情况。如果一个属性仅供类内部使用，请坚持使用单下划线。\n但如果你正在处理一个将被继承的类，你应该使用双下划线，这样父类的属性就不会被覆盖。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_6.html#理解抽象abstraction",
    "href": "cp_6.html#理解抽象abstraction",
    "title": "7  面向对象编程（OOP）",
    "section": "7.3 理解抽象（Abstraction）",
    "text": "7.3 理解抽象（Abstraction）\n\n7.3.1 什么是抽象？它如何帮助保持复杂系统的组织性？\n现在我们已经讨论了封装、继承和多态，接下来让我们探讨面向对象编程的下一个关键概念——抽象（Abstraction）。\n抽象是隐藏复杂的实现细节，只展示对象或系统的基本特征的过程。可以把它理解为专注于“某物做什么”，而不是“它是如何做的”。\n抽象并不仅限于 Python。它是一种编程概念，可以在许多支持面向对象编程的语言中实现。\n为了说明抽象，想象一下你正在驾驶一辆汽车。当你坐在驾驶座上时，你与方向盘、换挡杆、油门和刹车踏板等必要部件进行交互。你不需要知道发动机是如何工作的、变速箱是如何换挡的，或者刹车系统背后的物理原理，因为所有这些都属于复杂的实现细节。\n这就是抽象在起作用！它为你提供了一个简化的接口来与复杂的系统进行交互。\n再次以汽车为例，简化的接口是方向盘、刹车和油门，而复杂的系统是汽车本身。\n至于 Python 如何实现抽象，它通过 abc 模块来实现。\n该模块提供了 ABC 类（代表“抽象基类”）和 @abstractmethod 装饰器。\nABC 是打算被继承的类，但你不能直接从中创建对象。它定义了其子类必须实现的公共方法和属性接口。\n另一方面，抽象方法是在抽象基类（ABC）中使用 @abstractmethod 装饰器声明的方法。它可能没有实现，或者有一个基本的默认实现。但是，任何子类都必须重写它才能被视为具体类并可实例化，即使提供了默认实现也是如此。\n以下是 Python 中抽象类的基本语法：\n示例代码\nfrom abc import ABC, abstractmethod\n\n# 定义一个抽象基类\nclass AbstractClass(ABC):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\n# 实现抽象方法的具体子类\nclass ConcreteClassOne(AbstractClass):\n    def abstract_method(self):\n        print('Implementation in ConcreteClassOne')\n\n# 另一个具体子类\nclass ConcreteClassTwo(AbstractClass):\n    def abstract_method(self):\n        print('Implementation in ConcreteClassTwo')\n这是一个基本示例：\n示例代码\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC): # 继承自抽象基类\n   @abstractmethod # 抽象方法装饰器\n   def make_sound(self):  # 子类必须重写的方法\n       pass\n\n# 具体类，将重写抽象方法\nclass Dog(Animal):\n   def make_sound(self):\n       print('Woof!')\n\n# 另一个具体类，将重写抽象方法\nclass Cat(Animal):\n   def make_sound(self):\n       print('Meow!')\n\n# 另一个具体类，将重写抽象方法\nclass Monkey(Animal):\n   def make_sound(self):\n       print('Ooh ooh aah aah!')\n\n# 创建每个具体类的实例\nanimals = [Dog(), Cat(), Monkey()]\n\n# 遍历实例以调用 make_sound 方法\nfor animal in animals:\n   animal.make_sound()\n\n# 输出:\n# Woof!\n# Meow!\n# Ooh ooh aah aah!\n在这个示例中：\n\n我们从 abc 模块导入了 ABC 类和 abstractmethod。\n然后我们创建了一个继承自 ABC 的 Animal 类，并在其中创建了一个抽象方法 make_sound，每个 Animal 的子类都必须重写它。\n我们创建了具体类 Dog、Cat 和 Monkey，它们必须重写 make_sound 抽象方法。\n我们实例化了具体类并调用了它们的 make_sound 方法，以展示它们各自如何以自己的方式实现 make_sound 抽象方法。\n\n请记住，你不能创建 Animal 类的实例。如果你尝试这样做，会发生以下情况：\n示例代码\ndog = Animal() \n# TypeError: Can't instantiate abstract class Animal \n# without an implementation for abstract method 'make_sound'\n同样的规则适用于未为抽象方法提供实现的子类。即使你定义了 Animal 的子类，除非它重写了 make_sound，否则你无法实例化它。以下是一个示例：\n示例代码\nclass Bird(Animal):\n    pass\n\nbird = Bird()\n# TypeError: Can't instantiate abstract class Bird \n# without an implementation for abstract method 'make_sound'\n这是另一个示例，这次带有一个实例属性，你可以将其传递给具体方法的实例：\n示例代码\nfrom abc import ABC, abstractmethod\n\n# 任何可以说话的玩具的蓝图\nclass TalkingToy(ABC):\n   def __init__(self, name):\n       self.name = name\n   @abstractmethod\n   def speak(self):\n       pass\n\nclass RobotToy(TalkingToy):\n   def speak(self):\n       print(f'{self.name} says beep boop! I am a robot!')\n\nclass TeddyBearToy(TalkingToy):\n   def speak(self):\n       print(f\"{self.name} says hug me! I'm cuddly!\")\n\nclass DinosaurToy(TalkingToy):\n   def speak(self):\n       print(f'{self.name} says ROOOOAR!')\n\n# 创建玩具\nrusty = RobotToy('Rusty')\nfluffy = TeddyBearToy('Fluffy')\nrex = DinosaurToy('Rex')\n\ntoys = [rusty, fluffy, rex]\nfor toy in toys:\n   toy.speak()\n\n# 输出:\n# Rusty says beep boop! I am a robot!\n# Fluffy says hug me! I'm cuddly!\n# Rex says ROOOOAR!\n在这个示例中：\n\n我们有一个抽象基类 TalkingToy，它为任何可以说话的玩具定义了一个蓝图。\n子类 RobotToy、TeddyBearToy 和 DinosaurToy 以自己的方式实现了 speak 方法。\n当我们创建这些子类的实例并调用 speak 方法时，每个玩具都以自己独特的方式说话。\n\n总之，Python 中的抽象通过增加可重用来简化复杂的系统。\n你已经看到了如何从抽象类中重用单个方法到多个子类中，同时强制每个子类提供其特定的行为。\n这种方法使你的代码保持井井有条、灵活且易于维护，尤其是当你的应用程序不断增长时。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>面向对象编程（OOP）</span>"
    ]
  },
  {
    "objectID": "cp_7.html#处理常见数据结构",
    "href": "cp_7.html#处理常见数据结构",
    "title": "8  线性数据结构",
    "section": "",
    "text": "8.1.1 什么是算法？大O记法（Big O Notation）是如何工作的？\n在你的设备上运行的每个计算机程序都有一组特定的指令，这些指令按特定顺序执行以完成任务。\n该任务可能是对一组数字进行排序、修改图像、跟踪库存，甚至是运行你最喜欢的视频游戏。\n这就是算法发挥作用的地方。算法是用于解决问题或执行任务的一组明确的指令。\n你可以把算法看作是“食谱”。当你做饭时，食谱会列出你所需的所有食材，并提供准备菜肴的分步说明。\n同样，你可以把算法看作是“食谱”，它精确地告诉计算机应该做什么以及如何做。\n算法有两个关键特征：\n\n它们不能无限期地继续。它们必须在有限的步骤内完成。\n每个步骤都必须精确且明确。\n\n它们可能有零个、一个或多个输入，并生成一个或多个输出。\n算法的步骤独立于任何编程语言。\n但要让它们真正在计算机上运行，你需要用编程语言（如 Python 或 JavaScript）来实现它们。\n如果一个算法是正确的，那么对于任何有效输入，其输出都应该与预期输出匹配。\n除了正确性，算法还应该高效。\n算法的效率可以通过它们运行所需的时间以及完成任务所需的内存空间来衡量。\n了解算法的效率非常重要，因为它让你了解随着输入规模的增长，算法的性能会如何变化。\n例如，对 15 个整数进行排序与对 100 万个整数进行排序是不一样的。\n随着过程规模和复杂性的增长，如果算法效率不够高，你最终可能会得到一个非常慢的计算机程序，甚至可能导致整个系统崩溃。\n这就是为什么开发和选择尽可能高效的算法非常重要。\n这就是大 O 表示法（Big O notation）变得非常重要的地方。\n大 O 表示法描述了随着输入规模的增加，算法的最坏情况性能或增长速率。\n算法的增长速率是指随着输入规模的增长，它所需的资源如何增加。\n大 O 表示法关注最坏情况性能，因为了解即使在最坏情况下算法的效率如何非常重要，无论输入如何。\n回到我们的排序示例，直观上对 100 万个整数进行排序比对 15 个整数进行排序需要更多的时间和资源。\n但要多多少呢？\n这实际上取决于你选择用来排序的算法。\n大 O 表示法不会给出一个精确的数字来描述算法的效率，但它会根据算法执行的操作数，让你了解随着输入规模的增长，算法的扩展性如何。\n在大 O 表示法中，我们通常用字母 n 表示输入规模。例如，如果输入是一个列表，n 将表示该列表中的元素数量。\n在根据操作数确定算法的时间复杂度时，不考虑常数因子和低阶项。因为随着 n 的规模增长，这些较小项在执行的总操作数中的影响会变得越来越小。\n将主导算法整体行为的将是 n 的最高阶项，即输入规模。\n例如，如果一个算法执行 7n + 20 个操作才能完成，随着 n 的增长，常数 20 对最终结果的影响会变得越来越小。项 7n 将倾向于主导，这将定义算法的整体行为和效率。\n另一个例子是一个执行 20n² + 15n + 7 个操作才能完成的算法。随着 n 的增长，项 20n² 将倾向于主导，因此该算法将具有二次时间复杂度，因为主导项是 n²。\n二次时间复杂度是算法世界中你可能遇到的许多不同类型的时间复杂度之一。\n让我们了解一些最常见的类型。\nO(1) 被称为“常数时间复杂度”。当算法具有常数时间复杂度时，无论输入规模如何，它运行所需的时间都相同。\n例如，检查一个数字是偶数还是奇数总是需要相同的时间，无论数字本身是多少。\n示例代码\ndef check_even_or_odd(number):\n    if number % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'\nO(log n) 被称为“对数时间复杂度”。这意味着算法所需的时间随着输入规模的增长而缓慢增加。这在问题规模反复以恒定分数减少的问题中很常见。\n例如，一种名为二分查找（Binary Search）的流行搜索算法具有 O(log n) 的最坏情况时间复杂度。这是因为它在每次比较中都会消除一半的剩余元素，这使得它整体上更高效。\nO(n) 被称为“线性时间复杂度”。具有这种时间复杂度的算法的运行时间与输入规模成正比地增加。\n例如，一个遍历列表所有元素的 for 循环，随着列表元素数量的增加，它将执行更多的迭代。如果列表大小翻倍，操作数量也将大致翻倍。\n示例代码\nfor grade in grades:  # grades 是一个列表。\n    print(grade)\nO(n log n) 被称为“对数线性时间复杂度”。这是高效排序算法（如归并排序（Merge Sort）和快速排序（Quick Sort））的常见时间复杂度。\nO(n²) 被称为“二次时间复杂度”。这些算法的运行时间相对于输入规模呈二次方增加，这对于现实世界的问题通常效率不高。\n嵌套循环是二次时间复杂度的一个常见例子。内层循环将对外层循环的每个 n 次迭代执行 n 次迭代，从而导致 n 的平方次迭代。\n示例代码\nfor i in range(n):\n    for j in range(n):\n        print(\"Hello, World!\")\n其他时间复杂度包括“指数时间复杂度”，表示为 O(2^n)，以及“阶乘时间复杂度”，表示为 O(n!)。两者在现实场景中效率都不高。\n在这张图中，你可以比较代表最常见时间复杂度的数学函数的增长。将 x 轴（水平）视为输入规模，将 y 轴（垂直）视为算法的运行时间。\n你可以看到二次时间复杂度（O(n²)）（黄色）比其他增长快得多，而常数时间复杂度（O(1)）（红色）保持不变，即使输入变大也是如此。\n比较时间复杂度的图表\n太好了。到目前为止，你已经从时间要求的角度了解了大 O 表示法，但这个表示法也可以应用于空间要求的上下文。\n在这种情况下，它描述了随着输入规模的增长，算法所需的内存空间如何增长。\n具有“常数空间复杂度” O(1) 的算法总是需要恒定量的内存空间，即使输入变大也是如此。\n一个例子是只在内存中创建和存储几个变量的算法。\n相比之下，具有“线性空间复杂度” O(n) 的算法所需的空间随着输入规模的增长而成比例地增加。\n一个例子是创建和存储长度为 n 的列表副本的算法。\n最后，具有“二次空间复杂度” O(n²) 的算法的空间需求随着输入规模的增长而呈二次方增加。\n一个例子是创建一个二维矩阵，其中维度由输入规模确定，存储所有可能的对。\n算法是计算机程序的构建块，而大 O 表示法是一个强大的框架，用于分析它们的效率，基于它们在最坏情况下的时间和空间要求如何随着输入规模的增长而扩展。了解它们的效率对于开发在现实场景中高效运行的软件非常重要。\n\n\n8.1.2 什么是有效的问题解决技巧？应如何应对算法类挑战？\n在学习的过程中，你应该致力于培养强大的解决问题的能力。这些核心技能对于解决日常工作中的实际问题至关重要。\n解决算法挑战是练习的绝佳方式。它需要一种分析性的思维方式，能够将问题分解为其核心组件，并找到一种能高效生成正确输出的解决方案。\n但你该从哪里开始呢？\n你可以使用几种问题解决技术来开始应对这些挑战。\n作为一个例子，我们将在 Python 中反转一个字符串。\n这是挑战内容：\n“给定一个字符串，编写一个算法，返回一个字符顺序相反的新字符串。”\n当你遇到这种类型的问题时，你应该做的第一件事是多次阅读描述，以确保你理解了它的意思。如果你跳过这一步或读得太快，你可能会错过关键信息。\n然后，一旦你熟悉了问题，开始将其分解为其核心组件。\n问问自己：\n“输入是什么？”\n“期望的输出是什么？”\n“我如何将输入转换为期望的输出？”\n在这个问题中，你可以确定输入是一个字符串，因为挑战以“给定一个字符串…”开头。\n输出是“一个字符顺序相反的新字符串。”\n所以你需要取原始字符串并将其反转。\n这种初步分析一开始可能看起来有点重复，但它对于确保你完全理解需求非常有帮助。\n然后，你应该开始思考你将开发的算法将如何将输入转换为输出。\n在这个规划和分析阶段，使用伪代码（Pseudocode）来规划必要的步骤是很常见的。\n伪代码是算法逻辑的高级描述，本质上是通用的，不基于任何特定的编程语言。\n伪代码不像实际代码那么正式，因为它仅用于人类阅读。它应该是一目了然的。它的主要目的是给出将执行的步骤序列的清晰思路。\n伪代码通常是通用的书面语言（如英语）与编程结构（如 IF、ELSE、FOR 和 WHILE）的混合。\n这是你为解决“反转字符串”挑战可能编写的伪代码示例。\n示例代码\nGET original_string\n\nSET reversed_string = \"\"\n\nFOR EACH character IN original_string:\n  ADD character TO THE BEGINNING OF reversed_string\n\nDISPLAY reversed_string\n请注意这些步骤是如何以易于理解的方式概述的。单词和结构本身可能因你遵循的标准而异。\n如果你愿意，你可以使用多种编程语言实现这些步骤，遵循相同的逻辑，因为伪代码独立于编程语言。\n到这一点，你可能已经意识到这个问题可以用许多不同的方式解决。这不是反转字符串的唯一方法。\n但请记住，选择正确的算法很重要。\n在之前的课程中，你了解了算法复杂度以及为什么选择在时间和空间上高效的算法很重要。\n这就是作为开发人员你将发挥关键作用的地方。你需要选择最高效的算法来解决挑战。\n思考不同的可用算法是你应该练习的一项重要问题解决技能。花点时间问问自己，你在伪代码中提出的解决方案是否是最好的。\n例如，有许多不同的算法用于排序元素，但其中一些比其他的更高效。例如，冒泡排序（Bubble sort）对于排序大列表非常低效，而快速排序（Quick Sort）通常更高效。\n对于我们的“反转字符串”挑战，我们可以使用以下任一方法，假设我们计划在 Python 中实现我们的算法：\n\n使用扩展切片语法 [::-1] 来获取新的反转字符串。\n从左到右循环遍历字符，并将新字符添加到新字符串的开头。\n调用 reversed() 函数来获取一个包含所有字符按相反顺序的迭代器，然后调用 ““.join() 方法将它们连接回一个字符串。\n\n你应该使用哪一个？这是你的选择。\n基于你的知识和经验做出这些决定会对你的应用程序的最终性能产生巨大影响。考虑不同的方法、它们的效率、影响和实现。\n问问自己：\n“我将如何处理这个问题？”\n“我将使用什么数据结构？”\n“我选择的数据结构是针对当前问题最高效的数据结构吗？”\n“我是否涵盖了所有可能的边缘情况？”\n边缘情况（Edge cases）是特定的有效输入或条件，发生在算法应处理的边界上。\n例如，在“反转字符串”挑战中，边缘情况将是采用空字符串作为输入。你是否正确处理了它？如果没有，请考虑处理此边缘情况的最佳方式，并将其添加到你的伪代码中。\n然后，一旦你对你的计划感到满意，你就可以进入实施阶段。在这个阶段，你将在编程语言中实现你的算法。\n在构建你的程序时，你应该编写模块化代码，使其易于阅读和理解。\n基于你当前的知识使用编程语言的工具。一些编程语言包括针对常见问题和任务的内置解决方案。如果可能，请使用它们。\n为了保持一致，请遵循你选择的编程语言的最佳实践。\n在编写代码时对其进行测试，并确保你适当地处理了边缘情况。\n一旦你的解决方案实现，检查它是否对所有示例都正确工作，并可能重构你的代码以使其更清晰或更简单。\n回到你的解决方案非常重要。开发不一定是一个线性的、循序渐进的过程。你总是可以回到你的代码，并使用你的批判性思维技能来改进它。\n这些是你在应对算法挑战时可以遵循的一些常见问题解决技术。如果你持续练习，你会逐渐发展你的问题解决技能。\n\n\n8.1.3 动态数组与静态数组有什么不同？?\n数组是计算机科学中一种基础的数据结构。所有的数组都存储有序的数据集合，但根据其类型的不同，它们在底层的工作方式可能不同。\n它们底层的行为会对程序的效率产生重要影响，因此让我们来了解一下动态数组和静态数组以及它们的区别，这样你就可以为你的程序选择最高效的一种。\n我们将从静态数组开始。\n静态数组具有固定的大小。它们将元素存储在相邻的内存位置中。\n静态数组的大小是在数组初始化时确定的。一旦分配了那个特定的内存块，它就是固定的，在程序运行时无法更改。这是静态数组的一个关键特征。\n将元素存储在相邻的内存位置中使数据检索过程更高效，因为程序可以存储第一个元素的位置，然后使用索引来执行简单的计算并找到内存中的其他元素。\n因此，访问静态数组的值需要恒定的时间 O(1)，这是非常高效的。\n当你预先知道将要存储的元素数量时，可以使用静态数组。当值将被非常频繁地访问时，它也很有用，因为访问操作非常高效。\n然而，这种数据结构不能增长或缩小，所以如果要存储的元素数量可能变化，你应该使用动态数组。\n尝试增加静态数组的大小将涉及创建一个新数组并将所有元素从旧数组复制到新数组，这是低效的。在这种情况下，动态数组会好得多，因为它会自动处理这个过程。\nPython 不包含作为内置数据结构的传统静态数组。\n但其他编程语言，如 Java，确实支持它们。这是一个在 Java 中可以存储三个整数的静态数组的示例：\n示例代码\nint[] numbers = new int[3];\nPython 中的数组是动态的，所以让我们来看看它们。\n动态数组更灵活，因为它们可以在程序运行时自动增长或缩小。\n它们通过一种自动调整大小的机制工作，当原始数组满时，将元素复制到一个新数组中。这个过程是高效的，因为新数组的大小是以一种高效的方式选择的，使这些计算成本高昂的操作不那么频繁。\n访问动态数组的元素需要恒定的时间 O(1)，所以这个操作非常高效。\n在数组中间插入一个元素需要线性时间 O(n)，因为它后面的元素需要重新定位。\n在数组末尾插入一个元素，如果动态数组中仍有可用空间，则需要恒定的时间 O(1)，但如果数组已满且需要调整大小，这个操作具有 O(n) 的复杂度。\n当你不知道预先需要存储的值的数量时，应该使用动态数组。当你将频繁插入和删除元素时，它们也很有用。\nPython 的内置列表数据结构作为动态数组工作。你可以通过在方括号内编写元素来创建一个列表，元素之间用逗号分隔。\n示例代码\nnumbers = [3, 4, 5, 6]\n你可以通过编写保存列表的变量的名称，后跟方括号，并在方括号内编写相应的索引来访问一个元素。\n索引从第一个元素的 0 开始，并为每个后续元素递增 1：\n示例代码\nnumbers[0]  # 3\nnumbers[1]  # 4\nnumbers[2]  # 5\nnumbers[3]  # 6\n要更新一个值，你只需要重新分配它：\n示例代码\nnumbers[2] = 16\n你可以使用 .append() 方法将元素追加到列表中：\n示例代码\nnumbers.append(7)\n你可以使用 .insert() 方法在特定索引处插入元素，将索引作为第一个参数，将元素本身作为第二个参数。\n示例代码\nnumbers.insert(3, 15)\n你可以使用 .pop() 方法在特定索引处删除一个元素：\n示例代码\nnumbers.pop(2)\n如果你不指定索引，.pop() 将删除最后一个元素。\n在文档中还有其他内置的列表方法，你可以查看，以便非常轻松地添加和删除元素。\n这就是动态数组，或在这种情况下列表的强大之处。\n总的来说，当你预先知道元素数量并且需要频繁访问它们时，应该使用静态数组，当元素数量未知或随时间变化时，应该使用动态数组。\n你应该始终考虑静态数组的简单性与动态数组的灵活性之间的权衡。它们对于特定的用例和场景都有帮助。能够为给定的问题选择最佳的一个，是你将通过练习逐渐发展的解决问题的技能的一部分。\n\n\n8.1.4 栈和队列是如何工作的?\n栈（Stacks）和队列（Queues）是计算机科学中常用的数据结构。\n它们是线性数据结构，遵循特定的规则来添加和移除元素。\n我们从栈开始。\n栈是一种后进先出（Last-in, First-out, LIFO）的数据结构。\n这意味着最后一个添加到栈中的元素将是第一个被移除的元素。\n栈有两个端，我们称之为栈顶（top）和栈底（bottom）。\n元素从栈的顶部被添加和移除。\n你可以把栈想象成一摞盘子，你只能在盘子堆的顶部放置盘子，也只能从盘子堆的顶部取走盘子。\n\n在这种情况下，添加和移除元素的操作有特殊的名字。\n向栈中添加元素被称为“入栈（push）”操作。当我们将元素添加到栈顶时，我们说我们将元素“压入（push）”栈。\n\n从栈中移除元素被称为“出栈（pop）”操作。当我们将元素从栈顶移除时，我们说我们将元素“弹出（pop）”栈。\n\n你可以看到我们实际上不在栈底执行任何操作，但我们保留它作为参考。\n入栈和出栈操作的时间复杂度通常是 O(1)，即常数时间复杂度。\n当你将元素压入栈时，该元素被简单地添加到栈顶。\n当你从栈中弹出元素时，栈顶的元素被移除。\n因此，无论栈的大小如何，执行这些操作所需的时间都是恒定的。\n入栈和出栈操作的空间复杂度通常是常数 O(1)。这意味着无论栈的大小如何，执行这些操作所需的内存量都是恒定的。\n既然你对栈有了更多了解，让我们来学习队列。\n队列是一种先进先出（First-in, First-out, FIFO）的线性数据结构。这意味着第一个添加到队列中的元素将是第一个被移除的元素。\n队列有两个端：队头（front）和队尾（back）。\n\n元素被添加到队列的尾部，从队列的头部移除。\n你可以把队列想象成在超市等待结账的一排人。排在最前面的人是第一个去收银台结账的人，而新来的人则在队尾加入队伍。\n在队列的上下文中，添加和移除元素的操作也有特殊的名字。\n向队列的尾部添加元素被称为“入队（enqueue）”操作。\n在入队操作中，新元素被添加到队列的末尾，成为队列的末尾。\n\n从队列的头部移除元素被称为“出队（dequeue）”操作。\n在出队操作中，队列头部的元素被移除，下一个元素成为新的队头。\n\n入队和出队操作的时间复杂度是 O(1)，即常数时间。无论队列的大小如何，执行这些操作所需的时间都是恒定的。\n入队和出队操作的空间复杂度通常是常数 O(1)。这意味着无论队列的大小如何，执行这些操作所需的内存量都是恒定的。\n栈和队列是计算机科学中用于组织和管理元素的数据结构。理解它们对于在各种编程应用中构建高效的算法至关重要。\n\n\n8.1.5 单向链表是如何工作的？它与双向链表有什么不同？\n链表（Linked List）是一种线性数据结构，其中每个节点都连接到序列中的下一个节点。\n这些连接创建了一个看起来像节点链的数据结构，其中每个节点存储数据以及对链表中下一个节点的引用。\n\n我们使用这些引用从第一个节点移动到下一个节点，以此类推。\n链表通常用于实现其他数据结构，例如栈、队列和双端队列。它们也可以用于实现基本的图算法，例如深度优先搜索和广度优先搜索。\n单向链表\n单向链表是一种链表，其中每个节点都连接到序列中的下一个节点。\n每个节点通过存储对下一个节点的引用来连接到下一个节点。\n每个节点的单个引用允许你单向遍历链表，从头到尾。\n搜索只能向前移动，不能向后移动。\n在此示例中，你将从头节点（Head Node）开始，即节点 A。\n头节点是链表中的第一个节点。\n在单向链表中，头节点通常是唯一可以直接访问的节点。当你试图找到特定节点时，搜索过程将从这里开始。\n\n遍历过程将从节点 A 开始，然后继续到节点 B，然后是节点 C，最后是节点 D（尾节点）。如果你在代码中实现了特定逻辑，它也可能在此之前停止。\n尾节点（Tail Node）是最后一个节点。它用于确定过程何时到达链表的末尾。\n插入节点\n关于链表的一件好事是它们没有固定大小。它们可以根据需要通过简单地更新节点之间的连接来扩展或缩小。\n你可以在链表的开头、中间和末尾插入节点。\n链表不一定需要以特定顺序存储节点。顺序将由节点之间的连接决定。\n然而，如果你确实需要为你的特定用例保持节点的特定顺序，你可以通过在代码中实现该逻辑来实现，你实现的标准将确定节点是在开头、中间还是末尾插入。\n要在链表的开头插入节点，你只需要在新节点和曾经是头节点的节点之间创建一个连接，并使新节点成为头节点。\n在此示例中，我们在开头插入节点 E，并使这个新节点成为链表的头节点。\n\n在链表开头插入节点具有常数时间复杂度 O(1)，因为它只需要更新对头节点的引用以及新头节点和序列中下一个节点之间的连接。\n在此示例中，我们将节点 E 插入链表的开头。这将正常工作。但如果我们想保持链表按字母顺序排序，节点 E 将不得不插入链表的末尾。\n要在链表的末尾插入节点，首先你需要到达末尾，然后添加一个连接到新节点，使其成为新的尾节点。\n\n此操作具有线性时间复杂度 O(n)，其中 n 是链表中存储的节点数量，因为首先你需要到达链表的末尾以进行插入，这将需要从一个节点移动到下一个节点，以此类推，直到到达末尾。\n如果节点必须插入链表的中间，节点之间的连接也必须更新。序列中的前一个节点应该连接到新节点，新节点应该连接到下一个节点，如下图所示。\n\n插入操作具有常数空间复杂度 O(1)，因为插入新节点只需要创建它并更新节点之间的连接。此操作不依赖于链表本身的大小。\n删除节点\n正如你可以插入节点一样，你也可以从链表的开头、中间和末尾删除它们。\n要从开头删除节点，你需要更新对头节点的引用，它应该是序列中的下一个节点。\n此操作具有常数时间复杂度 O(1)，因为它只需要更新链表对头节点的引用。\n\n要从链表中间删除节点，你需要更新前一个节点的引用，以将其连接到序列中的下一个节点，在它们之间形成一种“桥”，如你在此图中所见。\n\n这将从连接序列中删除你想要删除的节点（在此情况下是节点 B），因此下次你遍历时将无法到达它。\n要从链表末尾删除节点，你需要删除前一个节点的连接，并使此节点成为新的尾节点。现在链表将在新的尾节点处结束。\n此操作具有线性时间复杂度 O(n)，因为你首先必须到达链表的末尾。\n\n删除操作具有常数空间复杂度 O(1)，因为删除节点不需要额外的内存。\n双向链表\n既然你对单向链表有了更多了解，让我们来谈谈双向链表。\n在双向链表中，每个节点存储两个引用：一个对下一个节点的引用和一个对序列中前一个节点的引用。\n这意味着双向链表可以在两个方向上遍历。\n\n在这种类型的链表中，通常也会在链表本身中保留对尾节点的引用，以便在必要时从末尾开始遍历。\n听起来很棒，对吧？它们比单向链表更灵活。\n然而，双向链表确实比单向链表需要更多的内存，因为每个节点存储两个引用而不是一个。\n这是你在为你的项目选择正确的数据结构时应该记住的事情。\n这是一个要权衡的事。\n插入和删除操作的工作原理完全相同。唯一的区别是，现在你需要更新每个节点的两个引用，并跟踪对尾节点的引用，以便非常高效地在双向链表末尾插入元素，并在必要时从后面开始遍历过程。\n单向和双向链表是计算机科学中用于以顺序方式存储和操作元素的基本数据结构。理解它们的区别对于为你的特定应用选择正确的一个至关重要。\n\n\n\n\n\n8.1.6 映射（Maps）、哈希映射（Hash Maps）和集合是如何工作的？\n在本节课中，我们将介绍映射（Maps）、哈希映射（Hash Maps）和集合（Sets）。但在开始之前，让我们先定义一下抽象数据类型（Abstract Data Types）。\n抽象数据类型（ADT）是对数据类型的概念性表示，包括可以在数据上执行哪些操作以及数据的属性。\n抽象数据类型就像蓝图，它们描述了可以执行哪些操作，而不是如何执行它们。它们将接口与操作的实际实现分离开来。\n映射是一种以非常特定且高效的方式管理键值对（key-value pairs）及其操作的抽象数据类型。\n在映射中，每个值都与一个特定的键相关联。\n映射的一个关键特征是每个键必须是唯一的。这种唯一性允许进行直接查找，从而使检索信息的过程更加高效。\n只需要键是唯一的，值可以重复。\n映射抽象数据类型还定义了重要的操作，例如插入键值对、获取与键关联的值、更新与键关联的值、移除键值对以及检查映射中是否存在某个键。\n它实际上并没有指定这些操作应该如何执行，它只是将它们作为数据类型可用的操作的一部分列出。\n哈希映射，也称为哈希表，是映射抽象数据类型的的具体实现。\n哈希映射使用一种称为“哈希（Hashing）”的技术来非常高效地执行常见操作。\n哈希本质上是通过使用哈希函数为每个元素生成一个哈希值来工作的。\n哈希值是基于键值对的键生成的，它用于计算底层数组中的索引，底层数组是存储键值对的实际数据结构。\n但你可能会问自己：如果两个键导致相同的索引会发生什么？\n哈希映射通过巧妙的策略来解决这些冲突。\n一种选择是使用“链地址法（Chaining）”策略，其中每个数组索引指向一个链表（另一种数据结构），所有具有相同索引的元素都存储在该链表中。\n另一种策略是使用“开放寻址法（Open Addressing）”，它涉及基于预定义的搜索序列在数组中搜索下一个可用的索引。\n哈希映射的平均情况时间复杂度对于插入、检索和删除键值对操作是“常数时间”O(1)。\n这些操作的最坏情况时间复杂度是“线性时间”O(n)，当发生许多哈希冲突时会发生这种情况，因此必须多次应用冲突解决策略。\n插入到哈希映射中的空间复杂度在平均情况下是常数 O(1)，即存储新对所需的恒定量的内存。然而，在最坏情况下，由于底层数组的调整大小操作，它可能具有线性空间复杂度 O(n)。通常，删除元素具有常数空间复杂度 O(1)。\n这将哈希表变成类似于线性数据结构的东西，其中必须扫描 n 个元素才能找到目标键。然而，如果正确实现哈希映射，这种情况相对较少。\nPython 的字典在底层是作为哈希映射实现的。\n要创建一个 Python 字典，你只需要在花括号内编写键值对，并用逗号分隔它们。每个键应该用冒号与其对应的值分隔。\n示例代码\nmy_dictionary = {\n  'A': 1,\n  'B': 2, \n  'C': 3\n}\n在此代码中，‘A’ 是键，1 是值：\n示例代码\n'A': 1\n或者，你可以使用 dict()：\n示例代码\nmy_dictionary = dict(A=1, B=2, C=3)\n你可以通过其对应的键获取值：\n示例代码\nmy_dictionary['A']  # 1\n你也可以更新与键关联的值：\n示例代码\nmy_dictionary['A'] = 4\n你可以移除键值对：\n示例代码\ndel my_dictionary['A']\n你还可以检查一个键是否在字典中（或不在）：\n示例代码\n'C' in my_dictionary\n你可以调用这些方法分别获取字典的键、值和项。\n示例代码\nmy_dictionary.keys()\nmy_dictionary.values()\nmy_dictionary.items()\n太好了。既然你对映射和哈希映射有了更多了解，让我们来谈谈集合。\n集合是唯一元素的无序集合。\n让我们将这个概念分解为其关键组件：\n集合是无序的。集合的元素不以任何特定顺序存储，因此你不能通过索引访问它们。\n集合只包含唯一元素。如果你尝试两次添加相同的值，将只保留一个该值的副本。\n它们类似于数学中的集合，它们实现了相同的集合操作，如交集、并集和差集。\n集合的一个主要优点是它们保证元素将是唯一的（无重复）。这就是为什么它们经常用于从列表和其他数据结构中删除重复项。\n它们也是动态的。它们可以调整以适应当前存储的元素数量。这使它们相当强大。\n添加、移除、获取集合长度以及检查元素是否在集合中的平均情况时间复杂度是“常数时间”O(1)，这是非常高效的。\n由于集合是作为哈希表实现的，添加、移除和检查成员资格的最坏情况时间复杂度是“线性时间”O(n)。当发生多个哈希冲突时可能会发生这种情况，将哈希表变成类似于线性数据结构的东西，其中需要 n 次扫描才能找到键。\n在空间复杂度方面，在平均情况下，插入一个元素将具有常数复杂度 O(1)，因为一个新唯一元素需要恒定量的内存。然而，在最坏情况下，底层数组的调整大小操作可能需要线性空间复杂度 O(n)。通常，移除一个元素将具有常数空间复杂度 O(1)。\nPython 有一个内置的集合数据结构，你可以在程序中使用它来处理集合。\n在底层，Python 集合是使用仅存储键而不存储任何关联值的哈希表实现的。\n集合只能存储不可变数据类型的对象，因为它们的哈希值始终保持不变。相比之下，可变对象的哈希值在它们被改变时可能会改变。这就是为什么它们不能成为集合的一部分。如果存储在集合中的对象的哈希值发生变化，程序将无法再找到它。\n要在 Python 中定义一个集合，你只需要用花括号将元素括起来，并用逗号分隔它们：\n示例代码\nnumbers = {1, 2, 3, 4}\n要创建一个空集合，你可以调用 set()：\n示例代码\nnumbers = set()\n请注意，如果你使用空花括号，这将自动创建一个 Python 字典，而不是集合，因此你必须调用 set() 函数来创建一个空集合。\n你可以使用 .add() 方法向集合中添加一个元素：\n示例代码\nnumbers.add(5)\n你也可以使用 .remove() 方法从集合中移除元素：\n示例代码\nnumbers.remove(5)\n如果未找到元素，这将引发 KeyError。但如果你不希望在这种情况下引发错误，你可以改用 .discard() 方法。\n.pop() 方法返回集合中的一个任意元素，而 .clear() 方法从集合中移除所有元素。\n你可以使用 in 运算符测试一个元素是否在集合中：\n示例代码\n5 in numbers\nPython 还支持集合操作，包括并集、差集、对称差集和交集，你可以使用这些方法执行：\n示例代码\nset_a = {1, 2, 3, 4}\nset_b = {2, 3, 4, 5, 6}\n\nset_a.union(set_b)\nset_a.intersection(set_b)\nset_a.symmetric_difference(set_b)\nset_a.difference(set_b)\n或使用它们的等效运算符：\n示例代码\nset_a | set_b\nset_a & set_b\nset_a ^ set_b\nset_a - set_b\n添加、移除和测试成员资格的平均情况时间复杂度是“常数时间”O(1)。\n由于哈希映射的最坏情况冲突场景，这些操作的最坏情况时间复杂度是“线性时间”O(n)。\n你还可以检查一个集合是否是另一个集合的子集或超集：\n示例代码\nset_a.issubset(set_b)\nset_a.issuperset(set_b)\n总的来说，当你需要存储唯一项的集合并频繁检查项的存在时，应该使用集合。\n映射、哈希映射和集合是为高效的数据组织和检索而设计的强大数据结构。它们每一个都有其独特的特征和用例。作为开发人员，你需要为你的项目选择最佳的一个。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>线性数据结构</span>"
    ]
  },
  {
    "objectID": "cp_8.html#搜索searching和排序sorting算法",
    "href": "cp_8.html#搜索searching和排序sorting算法",
    "title": "9  算法",
    "section": "",
    "text": "9.1.1 什么是二分查找？它与线性搜索有什么不同？\n在计算机科学中，遍历列表查找项目是一项常见任务。关于搜索，有两种关键算法是你应该了解的：线性搜索（Linear Search）和二分查找（Binary Search）。\n线性搜索从列表的开头开始，依次遍历每个项目，直到找到它要查找的目标值。\n如果找到了目标值，则返回该值在列表中的索引。如果未找到目标值，则返回 -1。我们返回 -1 是因为它在大多数编程语言中不是一个有效的索引。\n以下是线性搜索的代码示例：\n示例代码\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n如果我们要搜索的列表是 [13, 4, 7, 9, 10]，目标值是 9，函数将返回 3，因为 9 位于索引 3 处。\n如果我们把目标值改为 5，函数将返回 -1，因为列表中没有 5。\n虽然这是一个相对简单的算法，但它并不是最高效的。如果你有一个包含大量项目的列表，线性搜索可能需要很长时间才能找到目标值。\n线性搜索的时间复杂度是 \\(O(n)\\)，因为搜索列表所需的时间随着列表大小的增加而线性增长。\n线性搜索的空间复杂度是 \\(O(1)\\)，因为搜索列表不需要任何额外的空间。\n二分搜索是一种在大量项目列表中进行搜索的更高效算法。其前提是列表必须按升序排序。\n二分搜索通过将列表一分为二，并检查目标值是否位于列表中间来工作。如果目标值在列表中间，则返回目标值的索引。否则，算法会检查目标值在列表的左半部分还是右半部分。\n它会继续将列表剩余的部分一分为二，直到找到目标值。如果列表中没有目标值，则返回 -1。\n以下是二分搜索的代码示例：\n示例代码\ndef binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n\n    while low &lt;= high:\n        mid = (low + high) // 2  \n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n我们首先确定一个最低索引 low 和一个最高索引 high。这代表了我们要搜索的列表范围。\n然后我们检查 low 小于或等于 high 的条件。如果 low 大于 high，说明我们已经搜索了整个列表但未找到目标值。在这种情况下，我们停止搜索并返回 -1。\n如果 low 小于或等于 high，我们计算列表的中间索引 mid。然后检查目标值是否在中间索引处。如果是，我们返回中间索引。\n否则，我们检查中间点的值是否小于目标值。如果是，我们将 low 索引更新为中间索引加一。这意味着我们将搜索列表的右半部分。\n最后，如果其他条件都不为真，我们将 high 索引更新为中间索引减一。这意味着我们将搜索列表的左半部分。\n我们继续重复这个过程，直到找到目标值或确定目标值不在列表中。\n二分搜索的时间复杂度是 \\(O(\\log n)\\)，因为搜索列表所需的时间随着列表大小的增加而对数增长。\n二分搜索的空间复杂度是 \\(O(1)\\)，因为搜索列表不需要任何额外的空间。\n线性搜索和二分搜索可以用于你在计算机科学中遇到的各种问题。理解这两种算法之间的区别以及何时使用哪种算法非常重要。\n\n\n9.1.2 什么是分治（Divide and Conquer）思想？归并排序（Merge Sort ）是如何工作的？\n计算机科学中的分治法（Divide and Conquer）范式是一种将问题递归地分解为更小的子问题的技术。这项技术的一个关键方面是递归，即当一个函数反复调用自身，直到达到一个基础情况（base case）为止。在本节课中，我们将通过研究归并排序（Merge Sort）算法来更好地理解分治法是如何工作的。\n假设我们有以下数字列表：\n示例代码\n42 37 53 17\n我们的目标是使用归并排序算法将该列表按从小到大的顺序进行排序。第一步是将该列表一分为二：\n示例代码\n42 37 | 53 17\n然后我们需要看列表的左侧部分：\n示例代码\n42 37\n我们取这个子列表并再次将其一分为二，直到每个子列表只包含一个项目：\n示例代码\n42 | 37\n只包含一个项目的列表在默认情况下是已排序的。接下来我们需要将这些单元素子列表合并成一个已排序的列表：\n示例代码\n37 42\n然后我们对原始列表的右侧部分遵循相同的过程：\n示例代码\n# 原始列表的右侧\n53 17\n\n# 将列表一分为二\n53 | 17\n\n# 将列表合并为已排序的顺序\n17 53\n现在原始列表的两半都已排序，我们将这两半合并在一起并对元素进行排序：\n示例代码\n17 37 42 53\n以下是该算法在代码中的样子：\n示例代码\ndef merge_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    sorted_list = []\n    i = 0\n    j = 0\n\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt;= right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n\n    return sorted_list\n归并排序的时间复杂度是 \\(O(n \\log n)\\)，因为列表被持续地一分为二（\\(\\log n\\)），然后合并在一起（\\(O(n)\\)）。与其他排序算法（如冒泡排序）不同，归并排序不是原地排序的，其空间复杂度为 \\(O(n)\\)。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>算法</span>"
    ]
  },
  {
    "objectID": "cp_9.html#理解图和树",
    "href": "cp_9.html#理解图和树",
    "title": "10  图和树",
    "section": "",
    "text": "10.1.1 计算机科学中的Graphs是什么\n图（Graphs）是一种数据结构，用于表示对象或实体之间的连接或关系。它们通常用于对网络进行建模。\n你可以用图来建模各种类型的网络，包括社交网络、交通网络、通信网络，甚至推荐系统。\n例如，图可以表示社交媒体平台上用户之间的连接，或者公路网上城市之间的连接。它们的用途非常广泛。\n图通常被表示为由线条连接的一组点或圆圈。这些圆圈和线条代表了图的两个主要组成部分：节点（Nodes）和边（Edges）。\n\n节点（Nodes），也称为顶点（Vertices），代表了图所建模网络中的对象或实体。它们可以是用户、产品、车站、城市或模型中的任何其他实体。在这个例子中，节点被表示为圆圈，并用字母 A、B、C、D 和 E 标记，以便视觉上区分。\n边（Edges）是节点之间的连接。如果两个节点由一条边连接，则意味着它们在网络中以某种方式相关联。\n在这个例子中，有五条边连接着不同的节点对。节点 A 连接到节点 B，节点 B 连接到节点 A、C 和 D，以此类推。\n连接的具体含义取决于上下文。它可能是物理上的，比如连接两个城市的真正道路；也可能是更抽象的，比如社交媒体平台上两个用户之间的关系。\n如果两个节点由一条边直接连接，比如例子中的节点 A 和 B，它们被称为相邻节点（Adjacent Nodes）。\n\n\n🌐 图的类型\n图有不同的类型，具有不同的特征和应用场景。让我们来了解一下其中一些。\n\n10.1.1.1 无向图\n无向图是指边没有特定方向的图。这种类型的边通常用节点之间的一条直线表示。\n\n这意味着，如果有一条边连接节点 A 和 B，连接在两个方向上都有效：从节点 A 到节点 B，以及从节点 B 到节点 A。\n根据图所建模的网络，这种连接有不同的含义。\n例如，如果你在建模社交媒体平台上的用户连接，这意味着用户 A 与用户 B 相连，用户 B 也与用户 A 相连。这种连接是双向的。\n\n\n10.1.1.2 有向图\n相比之下，有向图是指边具有特定方向的图。\n如果有一条从节点 A 到节点 B 的连接，并不一定意味着存在一条从节点 B 到节点 A 的连接。\n有向图的边通常表示为带有箭头的直线，以指示方向。\n这里有一个例子。在这个图中，你可以从节点 A 前往节点 B，但不能从节点 B 前往节点 A，因为边的方向如此。\n\n例如，如果你在建模道路网络，这对于建模单行道或单向道路非常有用。你可以通过这条路从城市 A 前往城市 B，但不能从城市 B 前往城市 A。你需要选择不同的路线。\n如果有向图中的节点之间存在双向连接，你可以用两条连接它们的有向边来表示。\n在这里你可以看到一个例子。你可以从节点 B 前往节点 D，也可以从节点 D 前往节点 B，因为有两条边连接它们，但每条边都有一个方向。\n\n\n\n10.1.1.3 顶点标记图（vertex labeled graph）\n顶点标记图是一种图，其中每个节点除了其数据外，还与一个标签或标识符相关联。这些标签用于识别节点、在视觉上表示它们以及存储有关它们的附加信息。\n例如，在交通网络图中，节点可以是城市，它们的标签可以是它们的名称、坐标或对模型目的有帮助的任何其他特征。\n\n\n10.1.1.4 有环图（Cyclic Graphs）\n循环图是指至少包含一个环路的有向图。\n环路是指你可以沿着图的边走的一条路径，它会带你回到你开始时的初始节点。\n在这个例子中，我们有一个有向图。如果你仔细观察，你会注意到它有一个环路。如果我们从节点 B 开始，前往节点 C，然后前往节点 D，我们可以再次通过有向边回到节点 B。\n这是一个环路，所以这是一个循环图。\n\n\n\n10.1.1.5 边标记图（Edge Labeled Graphs）\n在边标记图中，边与标签相关联。这些标签通常画在它们对应的边旁边。\n\n\n10.1.1.6 加权图（Weighted Graphs）\n加权图是边标记图的一种特定类型，其中边上的标签表示可以比较并用于执行算术运算的值。\n一些边具有较高的权重，而另一些边具有较低的权重。这些权重代表了边的“成本”。\n例如，它们可能代表两个城市之间的距离，或者从一个城市到另一个城市所需的时间。\n这是一个加权图的例子。我们在每条边旁边写下每个权重。从节点 B 到节点 D 的“成本”是 3，由于这是一个无向图，从节点 D 回到节点 B 的成本也是 3。\n\n\n\n10.1.1.7 有向无环图（Directed Acyclic Graph）\n在计算机科学中另一种非常常见的图类型是有向无环图，即具有没有环路的有向图。\n下面是一个例子。它是一个有向图，因为每条边都有一个方向。\n它是无环的，因为它没有任何环路。为什么呢？请注意，如果你从一个特定的节点开始，由于边的方向，你无法回到原位。\n\n\n\n10.1.1.8 不连通图（Disconnected Graph）\n我们在本节课中将介绍的最后一种图类型是不连通图。\n不连通图是指有两个或更多组节点，它们之间没有任何边连接的图。\n一个现实世界中的例子是社交网络，你有两组或多组互不认识且没有任何共同朋友的人。\n这是一个例子。第一个组件有节点 A、B 和 C。第二个组件有节点 D 和 E。这些组件之间没有任何边，所以这是一个不连通图。\n你可以用各种方式实现图，包括集合、函数和数组。你将在接下来的课程中了解更多关于这方面的内容。\n理解图以及不同类型图的特征对于解决计算机科学和其他领域中的广泛问题是至关重要的。\n\n\n\n\n10.1.2 Depth First 和 Breadth First Search是如何工作的?\n当你开始处理数据结构和算法时，很快就会意识到你需要执行的一项常见操作是访问每个节点。\n这个过程被称为对数据结构进行“遍历（Traversing）”。\n遍历用于对数据结构中的每个节点执行某些操作，比如打印它们的值、查找特定值，或者对节点执行特定操作。\n通过系统地访问每个节点，你确保该过程不会遗漏任何节点。\n但是，你如何确定遍历数据结构的顺序呢？该过程应该从哪里开始，以及如何选择下一个节点？\n如果没有清晰的方法来遍历数据结构，那么遍历它就像在迷宫中行走而没有特定路径可循一样。\n这就是像广度优先搜索（BFS）和深度优先搜索（DFS）这样的算法变得非常重要的地方。它们通常用于遍历图以及在两个节点之间寻找路径。\n当它们用于遍历数据结构时，它们定义了应该访问节点的顺序，以确保不会遗漏任何一个节点。\n让我们从广度优先搜索（BFS）开始。\n广度优先搜索（BFS）是一种在移动到图的下一级之前，先访问所有相邻节点的算法。\n它可用于在无权图中找到两个节点之间的最短路径，因为它会分析每一级的所有节点，所以它首先找到边数最少的路径。\n该算法通常使用队列（Queue）数据结构来跟踪已访问的节点。队列遵循 FIFO（先进先出）方法，其中第一个添加到队列的节点是第一个被移除的节点。\n该算法的工作原理如下：\n\n从特定节点开始。\n将该节点标记为已访问并添加到队列中。\n当队列不为空时，从队列中移除（出队）当前节点。然后，对于它的每个邻居，如果邻居尚未被访问，则将其标记为已访问并添加到队列中。\n\n一个重要的考虑是，由于广度优先搜索（BFS）需要在内存中存储一个队列，并且这个队列可能包含大量节点，因此该算法的空间需求可能相当大。对于在同一级别上有大量节点的图来说尤其如此。\n让我们看一个将 BFS 应用于一种称为树（Tree）的特定类型图的示例。\n你将在接下来的课程中了解更多关于树的知识，但它们本质上是没有环路的图，其中节点以层次结构组织。环路是开始和结束于同一节点的路径。\n让我们将广度优先搜索（BFS）算法应用于这棵树：\n\n步骤 1：\n我们从树的根节点 A 开始。我们将 A 添加到队列中并立即将其标记为已访问。\n队列：[A]\n已访问：{A}\n步骤 2：\n我们从队列中移除节点 A。我们将它的未访问子节点（节点 B，然后是节点 C）添加到队列中，并将它们标记为已访问。\n队列：[B, C]\n已访问：{A, B, C}\n在同一级别上将节点添加到队列的顺序由数据结构的实现和图表示中存储边（连接）的顺序定义。\n如果实现是一致的，那么在同一级别上遍历节点的具体顺序不会影响算法的正确性。它仍然会逐级访问每个节点。\n步骤 3：\n我们从队列中移除节点 B。我们将它的未访问子节点（节点 D，然后是节点 E）添加到队列中，并将它们标记为已访问。\n队列：[C, D, E]\n已访问：{A, B, C, D, E}\n步骤 4：\n我们从队列中移除节点 C。我们将它的未访问子节点（节点 F，然后是节点 G）添加到队列中，并将它们标记为已访问。\n队列：[D, E, F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 5：\n我们从队列中移除节点 D。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[E, F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 6：\n我们从队列中移除节点 E。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[F, G]\n已访问：{A, B, C, D, E, F, G}\n步骤 7：\n我们从队列中移除节点 F。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[G]\n已访问：{A, B, C, D, E, F, G}\n步骤 8：\n我们从队列中移除节点 G。该节点没有任何未访问的子节点，因此已访问集合没有变化。\n队列：[]\n已访问：{A, B, C, D, E, F, G}\n当队列为空时，遍历完成。\n节点的遍历顺序如下：\nA → B → C → D → E → F → G\n\n请注意算法是如何按级别访问节点的。\n我们从节点 A 开始，然后移动到下一级以访问节点 B 和 C，然后移动到下一级以访问节点 D、E、F 和 G。这就是广度优先搜索（BFS）的核心原理。\n深度优先搜索 (DFS)\n虽然广度优先搜索（BFS）首先访问同一级别的所有相邻节点，但深度优先搜索（DFS）会将每个分支尽可能深入地跟随，然后才回溯。\n你可以将该算法想象为通过选择特定路径并沿着它走，直到你到达死胡同或出口来探索迷宫。如果你到达死胡同，你会往回走并选择不同的路径。\n深度优先搜索（DFS）通常用于解决具有单一解决方案的谜题、检测图中的环路以及查找图的连通分量。\n该算法可以使用递归或栈（Stack）数据结构来跟踪已访问的节点。\n栈遵循 LIFO（后进先出）方法，其中最后一个添加到栈的节点是第一个从栈中被移除的节点。\n该算法的工作原理如下：\n\n从特定节点开始。\n将该节点标记为已访问并添加到栈中。\n当栈不为空时，当前节点被弹出（移除）。此时我们“访问”或处理它（例如，通过打印它的值）。然后，它所有的未访问邻居被标记为已访问并添加到栈中。\n\n该算法的一个限制是，它并不总是能保证在无权图中找到两个节点之间的最短路径。\n让我们看一个将深度优先搜索（DFS）应用于我们的树示例的例子。\n\n步骤 1：\n我们从根节点 A 开始。我们将其标记为已访问并添加到栈中。\n栈：[A]\n已访问：{A}\n步骤 2：\n我们从栈中弹出节点 A。\n然后，我们将它的未访问子节点，节点 B 和节点 C，添加到栈中。我们将它们按相反顺序添加，C 然后是 B，这样 B 在顶部（LIFO）并将首先被处理。我们还将它们标记为已访问。\n栈：[C, B]\n已访问：{A, B, C}\n步骤 3：\n我们从栈中弹出节点 B。\n然后，我们将它的未访问子节点，节点 D 和节点 E，按相反顺序（E 然后是 D）添加到栈中。我们还将它们标记为已访问。\n栈：[C, E, D]\n已访问：{A, B, C, D, E}\n步骤 4：\n我们从栈中弹出节点 D。该节点没有要添加到栈的子节点。\n栈：[C, E]\n已访问：{A, B, C, D, E}\n步骤 5：\n我们从栈中弹出节点 E。该节点没有要添加到栈的子节点。\n栈：[C]\n已访问：{A, B, C, D, E}\n步骤 6：\n我们从栈中弹出节点 C。\n然后，我们将它的子节点，节点 F 和节点 G，按相反顺序（节点 G 然后是节点 F）添加到栈中，我们将它们标记为已访问。\n栈：[G, F]\n已访问：{A, B, C, D, E, F, G}\n步骤 7：\n我们从栈中弹出节点 F。该节点没有要添加到栈的子节点。\n栈：[G]\n已访问：{A, B, C, D, E, F, G}\n步骤 8：\n我们从栈中弹出节点 G。该节点没有要添加到栈的子节点。\n栈：[]\n已访问：{A, B, C, D, E, F, G}\n当栈为空时，遍历完成，所有节点都已被访问。\n算法访问节点的顺序如下：\nA → B → D → E → C → F → G\n\n请注意我们是如何从节点 A 开始，然后沿着树一直向下到节点 B，以及节点 D 和 E，在我们再次向上移动到节点 C，然后到节点 F 和 G 之前。这是深度优先搜索（DFS）的核心原理，在回溯并寻找其他路径之前遍历完整的路径。\n在这种情况下，我们使用栈解决了这个示例。或者，深度优先搜索（DFS）可以使用递归实现，其中函数处理当前节点，然后为它的每个未访问邻居调用自身。函数调用栈隐式地管理 LIFO（后进先出）顺序。\n广度优先搜索（BFS）和深度优先搜索（DFS）都是遍历图和树的基本算法。广度优先搜索（BFS）逐级探索节点，这非常适合在无权图中找到最短路径。另一方面，深度优先搜索（DFS）将一个分支尽可能深入地跟随，然后才回溯，这非常适合解决迷宫和检测环路。了解它们的优缺点有助于为特定问题选择正确的一个。\n\n\n\n\n\n10.1.3 Matrices and Adjacency Lists是怎样工作的?\n图（Graphs）是一种非常强大的数据结构，由一组节点（也称为顶点）以及连接它们的边组成。\n在代码中，有两种常见的方法来实现图：\n\n邻接矩阵（Adjacency Matrices）\n邻接表（Adjacency Lists）\n\n让我们深入了解一下它们各自的优缺点。\n邻接矩阵\n我们从邻接矩阵开始。\n邻接矩阵是一个二维列表（数组），其中的行和列代表图的顶点。\n矩阵中的值代表节点之间的边或连接。\n例如，如果你有一个存储在变量 matrix 中的矩阵，那么存储在 matrix[i][j]（其中 i 是行，j 是列）位置的值就代表了节点 i 和节点 j 之间的边。\n这些值的含义会根据图是有权图还是无权图而有所不同：\n\n如果图是无权图，值为 1 表示这两个节点之间有一条边，值为 0 表示它们之间没有边。\n如果图是有权图，该值将代表连接节点的边的权重。\n\n使用邻接矩阵的一个巨大优势是，检查两个节点之间是否存在边的时间是恒定的 O(1)。这是因为程序只需要在二维列表中查找那个特定的值。\n然而，这种查找边的高效率是有代价的。邻接矩阵的空间需求很大，其空间复杂度为二次方级 O(V²)，其中 V 是图中节点的数量。\n这对于稀疏图（Sparse Graphs，即只有少数边的图）来说效率很低。为什么？因为如果图是稀疏的，你会在矩阵中存储大量的 0 来表示节点之间没有边，而这些 0 依然会占用内存空间。\n邻接矩阵在查找某个节点的邻居时效率也不高，因为程序必须遍历整行或整列来查找代表边的 0 和 1。在最坏的情况下，这个过程可能需要 O(V) 的时间，其中 V 是图中节点的数量。\n让我们看一个针对特定图的邻接矩阵示例：\n\n在这个邻接矩阵中：\n\n每一行代表一个节点。第一行代表节点 A，第二行代表节点 B，以此类推。\n每一列也代表一个节点。\n矩阵中的每个值代表每一对节点之间是否存在边。值为 0 表示这两个节点之间没有边，值为 1 表示存在一条边。\n对角线上的值代表每个节点是否有自环（Self-loop，即连接节点自身的边）。在我们的例子中，它们都是 0，因为该图没有任何自环。\n\n这是一个视觉表示，让你了解行和列如何代表相应的节点。\n例如，第一行是 [0, 1, 1, 1]，因为节点 A 有连接到节点 B、C 和 D 的边：\n示例代码\n#      A  B  C  D\n# A   [0, 1, 1, 1],\n# B   [1, 0, 0, 1],\n# C   [1, 0, 0, 0],\n# D   [1, 1, 0, 0]\n这是同一个邻接矩阵，但在 Python 代码中的实现：\n示例代码\nadjacency_matrix = [\n    [0, 1, 1, 1],  # 节点 A 的邻居是 B, C, 和 D\n    [1, 0, 0, 1],  # 节点 B 的邻居是 A 和 D\n    [1, 0, 0, 0],  # 节点 C 的唯一邻居是 A\n    [1, 1, 0, 0]   # 节点 D 的邻居是 A 和 B\n]\n邻接表\n表示图的另一种常见方法是使用邻接表。\n邻接表是一个数组或字典，用于存储每个节点的所有邻居。\n有两种方法来实现邻接表：\n\n作为数组，其中每个索引代表一个节点，该索引处存储的列表包含该节点的邻居。\n作为字典，其中每个键代表一个节点，与该键关联的值（一个列表）包含该节点的邻居。\n\n在空间需求方面，邻接表比邻接矩阵更高效。它们的空间复杂度为 O(V + E)，其中 V 是顶点（节点）的数量，E 是边的数量。\n查找所有邻居节点也很高效，因为此操作只需要访问与该节点关联的列表。\n然而，这也是一种权衡。\n与邻接矩阵相比，邻接表在确定两个节点之间是否存在边时效率较低。\n在最坏的情况下，搜索过程可能需要 O(V) 的时间，因为它可能必须遍历一个非常长的邻居列表（如果该节点连接到图中所有其他节点的话）。\n这是一个针对此图的邻接表示例：\n\n这个邻接表是作为字典实现的。字典中的每个键代表一个节点，与该键关联的值是一个包含对应节点所有邻居的列表：\n示例代码\nadjacency_list = {\n    'A': ['B', 'C', 'D'],\n    'B': ['A', 'D'],\n    'C': ['A'],\n    'D': ['A', 'B']\n}\n或者，我们可以将其实现为一个二维列表，其中每个索引代表一个节点。例如，索引 0 代表节点 A，索引 1 代表节点 B，以此类推：\n示例代码\nadjacency_list = [\n    ['B', 'C', 'D'],  # 节点 A (索引 0) 的邻居\n    ['A', 'D'],       # 节点 B (索引 1) 的邻居\n    ['A'],            # 节点 C (索引 2) 的邻居\n    ['A', 'B']        # 节点 D (索引 3) 的邻居\n]\n请注意，即使这个二维列表看起来可能与邻接矩阵相似，但它们有很大的不同。\n\n邻接矩阵存储 0、1 或代表图中边或边权重的其他值。\n邻接表存储每个节点所有邻居的实际列表。\n\n这是一个非常重要的区别，你应该熟悉它。\n邻接矩阵和邻接表对于实现图都非常重要。在它们之间进行选择取决于图的大小以及你需要如何使用数据。邻接矩阵对于具有许多边的稠密图（Dense Graphs）很有用，而邻接表通常是现实场景中的首选，因为在现实场景中稀疏图更为常见。\n\n\n10.1.4 什么是Trees、Tries以及他们如何工作?\n树（Trees）在计算机科学领域中非常重要。\n树是一种特定类型的图。\n要将一个图归类为树，它必须：\n\n没有环路或循环（起点和终点节点相同的路径）。\n是连通的（可以从每个其他节点到达每个节点）。\n\n树是一种非线性的数据结构，用于以层级方式组织节点，其中节点可以有子节点、兄弟节点以及父节点。\n根节点（Root Node）是树的最顶端。它是树中唯一没有父节点的节点。这是你开始遍历整个数据结构的节点，通常使用像广度优先搜索（BFS）或深度优先搜索（DFS）这样的算法。\n这是一个树的图形示例：\n\n由于节点是按层级结构组织的，它们之间存在相互关系。\n父节点（Parent Node）是立即连接到其下方其他节点的节点。在图中，节点 A 是节点 B 和 C 的父节点。\n子节点（Child Node）是立即连接到其上方节点的节点。在图中，节点 D 和 E 是节点 C 的子节点。\n节点 D 和 E 也被归类为叶节点（Leaves）。叶节点是没有子节点的节点。你可以把它们看作是树的“分支”的末端。\n树节点也有重要属性：\n\n深度（Depth）：从根到该节点的路径长度。例如，在图中，节点 D 的深度是 2，因为如果你从根开始，你必须经过两条边才能到达它。\n高度（Height）：从当前节点向下到叶节点的路径长度。例如，节点 C 的高度是 1，因为它比叶节点高一级。\n度（Degree）：每个节点拥有的子节点数量。在图中，节点 B 的度是 0，因为它是叶节点，所以它没有子节点。节点 C 的度是 2，因为它有两个子节点。\n\n树也有高度。树的高度是其根节点的高度。\n有许多不同类型的树，包括二叉树（Binary Trees）、二叉搜索树（Binary Search Trees）、AVL 树、红黑树（Red-Black Trees）和 B 树（B-Trees）。\n二叉树和二叉搜索树\n这是两种最常用的树类型。\n二叉树（Binary Tree）是一种每个节点最多可以有两个子节点的树，一个左子节点和一个右子节点。是的，这意味着你到目前为止看到的示例就是一棵二叉树！\n\n二叉树示例\n二叉搜索树（Binary Search Tree）是二叉树的一种更具体的形式，具有非常特殊的排序属性。\n要理解它，首先你需要理解子树（Subtrees）。子树是它本身也是一棵树的树的一部分。\n在我们的树示例中，节点 C、D 和 E 自身形成一棵树，所以它们被认为是一个子树。\n\n二叉搜索树（BST）的排序属性规定，对于每个节点，其左子树中的所有值都小于该节点的值，而其右子树中的所有值都大于该节点的值。\n左子树和右子树本身也必须是二叉搜索树。\n如果树是平衡的，这种排序使搜索、插入和删除操作非常高效。\n平衡树（Balanced Tree）是指任何节点的左子树和右子树的高度非常相似的树，以确保操作保持高效。\n字典树\n既然你对树和二叉搜索树有了更多了解，让我们深入了解一下字典树（Tries）。\n字典树是用于存储一组字符串的树数据结构。\n字典树也被称为前缀树（Prefix Trees），因为它们对于需要根据字符串前缀查找字符串的操作非常高效。\n字典树中的每个节点代表字符串的一个单个字符。\n根节点不代表任何特定字符，所以你可以把它看作代表一个空字符串。\n当你从根向下遍历字典树时，到一个节点的路径定义了一个特定的前缀。要查找一个单词，你沿着该前缀走，直到你到达有你正在寻找的单词的节点。\n代表完整单词的节点被分配了单词结束标记（End-of-word markers）。\n这是一个包含单词 “top”、“tea” 和 “ten” 的字典树示例。\n请注意单词 “tea” 和 “ten” 如何共享相同的前缀 “te”，所以数据结构遵循相同的路径，直到最后一个字符，该字符被标记为单词结束字符。在这个图中，这由节点周围的红色边框表示。\n搜索操作的最坏情况时间复杂度是 O(L)，其中 L 是你正在寻找的字符串的长度。\n插入也很高效。此操作只需要为字典树中尚不存在的字符创建新节点。\n这种数据结构的巨大优势是，当多个字符串共享相同的前缀时，它们的路径重叠，所以前缀本身只存储一次。\n这种效率使字典树非常适合实现自动补全和拼写检查器等功能。\n然而，字典树并非对所有字符串集都高效。如果字符串集有许多唯一字符，它们可能效率不高。这将需要将许多唯一字符存储为单独的节点。必须遍历这些节点才能找到单词，这不会是最优的。\n既然你熟悉了不同类型的树以及它们的用途，你可以在现实场景中开始使用它们。当你需要在日常工作中应对挑战时，知道如何选择正确的一个是一项宝贵的技能。\n\n\n\n\n\n10.1.5 优先队列（Priority Queues）和 堆（Heaps）如何工作?\n优先队列（Priority Queue）是一种抽象数据类型（ADT），它的工作方式与队列或栈类似，但有一个关键区别。\n众所周知，标准队列遵循 FIFO（先进先出）原则，即第一个添加到队列的元素也是第一个从队列中移除的元素。\n栈则遵循 LIFO（后进先出）原则，即最后一个添加到栈的元素是第一个被移除的元素。\n队列和栈只考虑元素的插入顺序。\n然而，优先队列会考虑元素的“优先级”。优先级用于确定下一个应该移除哪个元素。\n通常，优先级最高的元素会先被移除，但某些实现也可能选择先移除优先级最低的元素。这取决于你程序的具体需求。\n优先队列在实际应用中非常有用，例如寻找两个位置之间的最短路径、在操作系统中进行任务调度、模拟交通、数据压缩以及网络管理。\n在实践中，优先队列通常使用堆（Heap）数据结构来实现。\n堆是一种树数据结构，具有一种非常特定的属性，称为堆属性（Heap Property）。该属性基于堆的类型，决定了每个节点与其子节点之间的关系。\n主要有两种类型的堆：\n\n最大堆（Max-heap）\n最小堆（Min-heap）\n\n在最大堆中，每个节点的值都大于或等于其子节点的值。\n在此示例中，你可以看到一个具有节点 8、7、5、2 和 1 的树结构。请注意，节点 7 大于节点 2 和节点 1，符合堆属性。其他所有节点也是如此。\n\n相比之下，在最小堆中，每个节点的值都小于或等于其子节点的值。\n在此示例中，我们有值为 4、7、9、12 和 15 的节点。例如，节点 7 小于节点 12 和节点 15，符合堆属性。其他所有节点也是如此。\n\n堆属性至关重要，因为它确保了最大值（或最小值，取决于堆的类型）始终位于顶部，这使得移除它变得非常容易。\n在实践中，堆通常被实现为数组，以便高效地访问父节点和子节点。\n使用数组简化了访问这些值或“节点”的逻辑，因为在幕后，如果堆保持完全二叉树的结构，数组实现只需要基于索引的简单数学运算，即可找到元素在内存中的位置。\nPython 有一个内置的 heapq 模块，你可以用来操作最小堆的实现。\n它通过直接在 Python 列表上操作来工作，遵循特定的步骤，将元素作为堆来处理，同时保持堆属性。\n要使用此模块，你只需要导入它：\n示例代码\nimport heapq\n然后，你需要定义一个空列表。这将是堆的底层数据结构：\n示例代码\nmy_heap = []\n要向堆中添加元素，你可以调用 heappush()，传入堆的名称和要添加的元素作为参数。这会自动将元素添加到列表中应处的位置，以保持堆属性：\n示例代码\nheapq.heappush(my_heap, 9)\n要获取优先级最低（在此情况下，值最小）的元素，你可以调用 heappop()：\n示例代码\nheapq.heappop(my_heap)\nheappushpop() 将这两个操作合并为一个调用。\n这比单独依次调用它们更高效，特别是当堆很大时，因为它只执行一次“堆化”操作来重新排序列表。\n示例代码\nheapq.heappushpop(my_heap, 15)\n如果你已经有一个列表，并希望将其转换为堆，你可以调用 heapify()，传入堆作为参数：\n示例代码\nheapq.heapify(my_heap)\n但目前，我们是按元素的值进行排序，对吧？\n如果我们想按它们的“优先级”排序怎么办？\n你可以通过存储具有此结构的元组来实现：(priority, element)。\n由于元组是从左到右逐个元素进行比较的，因此会先比较优先级，并基于它们做出决定。\n请注意，在这种情况下，较低的值代表较高的优先级。这意味着优先级为 1 的元组比优先级为 3 的元组具有更高的优先级：\n示例代码\nmy_heap = []\n\nheapq.heappush(my_heap, (3, \"A\"))\nheapq.heappush(my_heap, (2, \"B\"))\nheapq.heappush(my_heap, (1, \"C\"))\n如果你需要优先级相同的元素按它们插入的顺序被移除，你可以考虑在元组中包含一个唯一的计数器作为第二个元素来打破平局，像这样 (priority, counter, element)。\n现在让我们谈谈堆的效率。\n插入元素以及从堆中提取最小值或最大值（取决于堆的类型）的平均和最坏时间复杂度是对数级的，即 \\(O(\\log n)\\)，因为所需的交换次数通常与堆的高度成正比，而堆的高度是 \\(\\log(n)\\)。\n“查看”操作（Peek）的平均和最坏时间复杂度是常数级的，即 \\(O(1)\\)。查看是指获取最小值或最大值（取决于堆的类型）而不移除它。\n“堆化”操作（Heapify），即从一个未排序的列表构建堆，在平均和最坏情况下的时间复杂度是线性的，即 \\(O(n)\\)。\n同样，搜索和删除任意元素在平均和最坏情况下的时间复杂度也是线性的，即 \\(O(n)\\)，因为它们可能需要遍历整个堆。\n那么它们需要多少空间呢？\n堆的空间复杂度是线性的，即 \\(O(n)\\)，其中 \\(n\\) 是它包含的元素数量。它只需要存储元素以及列表对象本身的一小部分额外开销。\n优先队列和堆在计算机科学中非常重要。它们让你能够快速找到并使用列表中最重要的元素。这种效率对于执行关键现实任务（例如在地图上寻找最快路线）的许多计算机程序至关重要。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>图和树</span>"
    ]
  },
  {
    "objectID": "index.html#python当下的处境",
    "href": "index.html#python当下的处境",
    "title": "Python Book",
    "section": "1.5 Python当下的处境",
    "text": "1.5 Python当下的处境\n截至今日，Python 的处境可以用一句不夸张但也不悲观的话来概括：它仍然处在主流核心位置，但已经从“快速上升期”进入了“高度依赖、持续承压、稳态演化”的阶段。\n从使用层面看，Python 依然是全球范围内使用最广泛的编程语言之一，在教育、科研、数据分析、自动化、人工智能和通用工程领域保持着极强的现实存在感。高校教学、科研原型、数据管道、AI 模型训练与推理的上层逻辑，大量真实系统仍然以 Python 作为主要表达语言。这种地位并不是口号，而是由现有代码规模、人才储备和生态惯性共同支撑的结果，短期内不存在被整体替代的现实条件。\n从生态角度看，Python 目前最重要的支柱仍然是其成熟而庞大的第三方库体系，尤其是在科学计算、数据处理和机器学习方向。大量关键基础设施依旧围绕 Python 构建，许多新工具、新框架即便在底层使用 C、C++、Rust 或其他语言实现，对外接口仍然优先提供 Python 绑定。这意味着 Python 在系统中的角色更加清晰：它是“控制层、表达层和胶水层”，而不是所有性能问题的直接承担者。\n从技术处境看，Python 的局限在今天反而是被公开承认和广泛接受的。单线程性能、并发模型、内存效率这些问题并没有被“解决”，但也没有被回避。现实中的应对方式是分层：对性能敏感的部分用其他语言实现，对复杂业务逻辑、数据流和实验性工作继续使用 Python。这种模式在工程上已经高度成熟，而不是权宜之计。\n从语言自身演进来看，Python 目前处在一个相对保守但稳定的阶段。语言设计方向以兼容性、可维护性和渐进改进为主，而不是激进重构。类型注解、异步语法、解释器性能优化等方向都在持续推进，但整体节奏谨慎，核心价值没有发生方向性变化。这使得 Python 对大型组织和长期项目来说依然是一个风险可控的选择。\n从外部环境看，Python 面临的压力是真实存在的。新语言在性能、安全性、并发模型和系统级开发方面各有优势，在某些新项目中会被优先选择。同时，AI 工具本身正在降低“必须手写大量 Python 代码”的需求，一部分原本依赖 Python 的工作正在被更高层工具抽象掉。但这些变化更多是结构性的分工调整，而不是对 Python 生存空间的直接挤压。\n综合来看，Python 当前并不处在衰退或边缘化的状态，但也不再是那种“什么问题都用 Python 就对了”的扩张期语言。它的处境更像是一种基础设施语言：使用范围极广，依赖程度极高，替代成本极大，同时必须长期承受性能、规模和新范式带来的压力。它的价值不在于新鲜感，而在于已经深度嵌入现实世界的软件系统之中，并且在可预见的未来仍然会持续存在。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface｜为什么要了解 Python</span>"
    ]
  },
  {
    "objectID": "cp_10.html#理解动态规划dynamic-programming",
    "href": "cp_10.html#理解动态规划dynamic-programming",
    "title": "11  动态规划",
    "section": "",
    "text": "11.1.1 什么是动态规划？有哪些常见的算法？\n动态规划是一种算法技术，它通过将复杂问题分解为更简单的子问题并存储结果以避免重复计算来解决问题。这种方法将通常需要指数时间的问题转化为可以在多项式时间内解决的问题。\n动态规划的核心原则\n当一个问题中存在两个关键条件时，动态规划就有效。\n\n重叠子问题：在解决较大问题时，相同的较小问题会多次出现。与其反复重新计算这些子问题，不如存储它们的解。\n最优子结构：问题的最优解包含其子问题的最优解。这意味着我们可以通过组合较小部分的最优解来构建最佳解。\n\n让我们使用经典的“爬楼梯”问题来考察这些概念。\n朴素递归的问题\n考虑爬楼梯问题：你正在爬一个有 n 级台阶的楼梯，每次可以爬 1 级或 2 级。有多少种不同的方式可以到达顶部？\n示例代码\ndef climb_stairs_recursive(n):\n    \"\"\"递归方法\"\"\"\n    if n &lt;= 2:\n        return n  # 基本情况：1 级台阶有 1 种方式，2 级台阶有 2 种方式\n    # 要到达第 n 级台阶，我们可以从第 (n-1) 级或第 (n-2) 级上来\n    return climb_stairs_recursive(n-1) + climb_stairs_recursive(n-2)\n由于大量重复计算，这种实现具有指数级时间复杂度。在计算climb_stairs(5)时，会发生以下情况：\nclimb_stairs(5)调用 climb_stairs(4)和 climb_stairs(3)\nclimb_stairs(4) 调用 climb_stairs(3) 和climb_stairs(2)\n现在 climb_stairs(3) 被计算了两次\nclimb_stairs(3) 调用 climb_stairs(2) 和 climb_stairs(1)\nclimb_stairs(2) 总共被计算了 3 次\n仅对于 n=5，我们就进行了 9 次函数调用，而实际上只需要 5 次唯一计算。随着 n 增大，这种冗余呈指数级爆炸——climb_stairs(30) 将需要超过 10 亿次函数调用！时间复杂度变为 O(2^n)，对于较大的 n 值来说效率低下且不切实际。\n动态规划解决方案\n动态规划通过两种主要方法消除这种冗余计算：\n记忆化（Memoization，自顶向下方法）\n记忆化存储昂贵函数调用的结果，并在再次出现相同输入时返回缓存结果：\n示例代码\ndef climb_stairs_memo(n, memo={}):\n    \"\"\"带记忆化的动态规划\"\"\"\n    # 检查是否已计算过该值\n    if n in memo:\n        return memo[n]  # 返回缓存结果 - O(1) 查找！\n\n    # 基本情况\n    if n &lt;= 2:\n        return n\n\n    # 计算一次并存储在 memo 中供将来使用\n    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)\n    return memo[n]\n记忆化之所以高效得多，是因为从 1 到 n 的每个唯一值只计算一次。当我们再次需要 climb_stairs(3) 时，不再重新计算（这会触发更多递归调用），而是简单地在 memo 字典中以 O(1) 时间查找。\n让我们追踪使用自顶向下方法执行 climb_stairs(5) 的过程，看看记忆化如何消除冗余工作：\n示例代码\nCall: climb_stairs_memo(5)\n  memo = {} (空)\n\n  Call: climb_stairs_memo(4) \n    memo = {} (空)\n\n    Call: climb_stairs_memo(3)\n      memo = {} (空)\n\n      Call: climb_stairs_memo(2) → 返回 2 (基本情况)\n      Call: climb_stairs_memo(1) → 返回 1 (基本情况)\n\n      Result: 2 + 1 = 3\n      memo = {3: 3} (已存储!)\n\n    Call: climb_stairs_memo(2) → 返回 2 (基本情况)\n\n    Result: 3 + 2 = 5\n    memo = {3: 3, 4: 5} (已存储!)\n\n  Call: climb_stairs_memo(3) → 返回 3 (来自 MEMO - 无递归!)\n\n  Result: 5 + 3 = 8\n  memo = {3: 3, 4: 5, 5: 8}\n效率比较\n朴素递归：进行 9 次函数调用，包含重复计算\n记忆化：仅进行 5 次唯一计算，然后复用存储的结果\n时间复杂度：从 O(2^n) 降低到 O(n)，因为我们只进行 n 次唯一计算\n空间复杂度：O(n)，用于 memo 存储和调用栈\n实际影响：climb_stairs(30) 从 10 亿多次调用减少到仅 30 次调用！\n表格法（自底向上方法）\n表格法从底层开始构建解，用子问题的解填充一张表：\n示例代码\ndef climb_stairs_tabulation(n):\n    \"\"\"带表格法的动态规划\"\"\"\n    if n &lt;= 2:\n        return n\n\n    # 创建数组以存储从 0 到 n 所有台阶的结果\n    dp = [0] * (n + 1)\n    dp[1] = 1  # 到达第 1 级台阶有 1 种方式\n    dp[2] = 2  # 到达第 2 级台阶有 2 种方式\n\n    # 迭代构建解\n    for i in range(3, n + 1):\n        # 到达第 i 级台阶的方式数 = 到达 (i-1) 的方式数 + 到达 (i-2) 的方式数\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n表格法通过从最小的子问题开始迭代构建解，完全消除了递归。\n让我们看看自底向上方法的实际运行过程，了解我们如何系统地构建解。以下是 climb_stairs(5) 的迭代构建过程：\n示例代码\n初始状态：\ndp = [0, 1, 2, 0, 0, 0]\n     [0, 1, 2, 3, 4, 5] ← 索引（台阶编号）\n\n逐步构建：\n\ni = 3:\n  dp[3] = dp[2] + dp[1] = 2 + 1 = 3\n  dp = [0, 1, 2, 3, 0, 0]\n\ni = 4:\n  dp[4] = dp[3] + dp[2] = 3 + 2 = 5\n  dp = [0, 1, 2, 3, 5, 0]\n\ni = 5:\n  dp[5] = dp[4] + dp[3] = 5 + 3 = 8\n  dp = [0, 1, 2, 3, 5, 8]\n\n最终结果：dp[5] = 8\n表格法的主要优势\n无递归开销：与记忆化不同，没有递归调用栈。\n可预测的执行：我们按预定顺序（1, 2, 3, 4, 5…）计算值。\n缓存友好：顺序数组访问优化了内存使用。\n易于优化：由于我们只需要最后两个值，可以将空间复杂度降低到 O(1)。\n示例代码\ndef climb_stairs_optimized(n):\n    if n &lt;= 2:\n        return n\n\n    prev2, prev1 = 1, 2  # 仅存储最后两个值\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2, prev1 = prev1, current\n    return prev1\n效率比较\n朴素递归：n=5 时进行 9 次函数调用，呈指数增长。\n表格法：n=5 时进行 3 次简单加法，呈线性增长。\n时间复杂度：O(n)而不是 O(2^n)。\n空间复杂度：使用数组时为 O(n)，优化后为 O(1)。\n性能可预测：对于大输入没有栈溢出风险。\n两种方法都将时间复杂度从指数级 O(2^n) 降低到线性 O(n)，这是一个巨大的改进，使得解决问题的时间从毫秒级变为对于较大输入等待数年之间的区别。\n实际应用\n动态规划在计算机科学及更广泛领域有广泛应用：\n路线优化：GPS 系统使用动态规划算法查找地点之间的最短路径。\n文本处理：拼写检查器和自动补全功能经常依赖动态规划来计算单词之间的编辑距离。\n金融建模：投资策略和投资组合优化经常采用动态规划技术。\n资源分配：背包问题及其变体出现在调度、预算和资源管理中。\n实际示例：硬币找零问题\n硬币找零问题是一个经典编程挑战，当使用动态规划解决时，展示了动态规划的两个关键原则：最优子结构和重叠子问题。\n硬币找零问题问：“组成目标金额所需的最少硬币数量是多少？”\n以下是使用动态规划的一种解决方案：\n示例代码\ndef min_coins(amount, coins):\n    \"\"\"查找组成给定金额所需的最少硬币数量\"\"\"\n    # 用“无穷大”初始化 dp 数组 - 表示无法组成\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 基本情况：金额 0 需要 0 枚硬币\n\n    # 对于从 1 到目标金额的每个金额\n    for i in range(1, amount + 1):\n        # 尝试每种硬币面额\n        for coin in coins:\n            if coin &lt;= i:  # 只有当硬币不超过当前金额时才能使用\n                # 更新最小值：当前最小值 vs (剩余金额所需硬币数 + 1)\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    # 如果可能则返回结果，否则返回 -1\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n# 示例用法：\n# coins = [1, 3, 4], amount = 6\n# dp[6] = min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3+1, 1+1, 2+1) = 2\n# 结果：2 枚硬币 (3 + 3)\n\n不关心前面怎么选，只假设最后一枚硬币是什么；一旦最后一枚确定，问题就退化为一个已经解决过的更小金额的问题。\n\n以下是动态规划硬币找零算法对 coins = [1, 3, 4], amount = 6 的逐步工作过程：\n示例代码\n初始状态：\ndp = [0, ∞, ∞, ∞, ∞, ∞, ∞]\n     [0, 1, 2, 3, 4, 5, 6] ← 金额\n\n逐步构建解：\n\n对于金额 = 1：\n  尝试硬币 1：dp[1] = min(∞, dp[0] + 1) = min(∞, 0 + 1) = 1\n  dp = [0, 1, ∞, ∞, ∞, ∞, ∞]\n\n对于金额 = 2：\n  尝试硬币 1：dp[2] = min(∞, dp[1] + 1) = min(∞, 1 + 1) = 2\n  dp = [0, 1, 2, ∞, ∞, ∞, ∞]\n\n对于金额 = 3：\n  尝试硬币 1：dp[3] = min(∞, dp[2] + 1) = min(∞, 2 + 1) = 3\n  尝试硬币 3：dp[3] = min(3, dp[0] + 1) = min(3, 0 + 1) = 1\n  dp = [0, 1, 2, 1, ∞, ∞, ∞]\n\n对于金额 = 4：\n  尝试硬币 1：dp[4] = min(∞, dp[3] + 1) = min(∞, 1 + 1) = 2\n  尝试硬币 3：dp[4] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2\n  尝试硬币 4：dp[4] = min(2, dp[0] + 1) = min(2, 0 + 1) = 1\n  dp = [0, 1, 2, 1, 1, ∞, ∞]\n\n对于金额 = 5：\n  尝试硬币 1：dp[5] = min(∞, dp[4] + 1) = min(∞, 1 + 1) = 2\n  尝试硬币 3：dp[5] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2\n  尝试硬币 4：dp[5] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2\n  dp = [0, 1, 2, 1, 1, 2, ∞]\n\n对于金额 = 6：\n  尝试硬币 1：dp[6] = min(∞, dp[5] + 1) = min(∞, 2 + 1) = 3\n  尝试硬币 3：dp[6] = min(3, dp[3] + 1) = min(3, 1 + 1) = 2\n  尝试硬币 4：dp[6] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2\n  dp = [0, 1, 2, 1, 1, 2, 2]\n\n最终结果：dp[6] = 2 (通过硬币 3 + 3 实现)\n此解决方案展示了动态规划的两个关键原则。它具有重叠子问题，因为找到金额 6 的最少硬币数需要知道金额 5、3 和 2 的解。这些相同的子问题在计算其他金额时也会出现。它具有最优子结构，因为任何金额的最优解都包含较小金额的最优解。如果我们知道金额 3 的最少硬币数是 1，那么组成金额 6 的一种方式就是使用该解再加上一枚面值为 3 的硬币。\n没有动态规划，我们需要尝试硬币的每种可能组合——可能性数量呈指数级增长。有了动态规划，我们系统地构建解：\n时间复杂度：O(金额 × 硬币数量) 而不是指数级。\n空间复杂度：O(金额) 用于 dp 数组。\n无冗余工作：每个子问题（为每个金额找到最少硬币数）只解决一次。\n可重用结果：一旦我们知道金额 3 的最少硬币数，我们就将这一知识用于所有能从中受益的更大金额。\n何时使用动态规划\n当满足以下条件时，动态规划是有效的：\n问题可以分解为重叠子问题。\n问题表现出最优子结构。\n朴素递归解决方案会涉及重复计算。\n你需要以空间复杂度为代价来优化时间复杂度。\n常见的动态规划模式包括优化问题（寻找最小/最大值）、计数问题（达成某目标的方式数量）以及可以分解为更小决策的决策问题。\n动态规划通过系统地存储和重用子问题的解，将复杂问题转化为可管理的问题。理解这一技术为高效解决各种计算挑战打开了大门。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>动态规划</span>"
    ]
  }
]